// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.KubernetesClient -o kubernetes_client_mock.go -n KubernetesClientMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// KubernetesClientMock implements mm_pkg.KubernetesClient
type KubernetesClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcApply          func(ctx context.Context, obj runtime.ApplyConfiguration, opts ...client.ApplyOption) (err error)
	funcApplyOrigin    string
	inspectFuncApply   func(ctx context.Context, obj runtime.ApplyConfiguration, opts ...client.ApplyOption)
	afterApplyCounter  uint64
	beforeApplyCounter uint64
	ApplyMock          mKubernetesClientMockApply

	funcCreate          func(ctx context.Context, obj client.Object, opts ...client.CreateOption) (err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, obj client.Object, opts ...client.CreateOption)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mKubernetesClientMockCreate

	funcDelete          func(ctx context.Context, obj client.Object, opts ...client.DeleteOption) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, obj client.Object, opts ...client.DeleteOption)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mKubernetesClientMockDelete

	funcDeleteAllOf          func(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption) (err error)
	funcDeleteAllOfOrigin    string
	inspectFuncDeleteAllOf   func(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption)
	afterDeleteAllOfCounter  uint64
	beforeDeleteAllOfCounter uint64
	DeleteAllOfMock          mKubernetesClientMockDeleteAllOf

	funcDynamic          func() (i1 dynamic.Interface)
	funcDynamicOrigin    string
	inspectFuncDynamic   func()
	afterDynamicCounter  uint64
	beforeDynamicCounter uint64
	DynamicMock          mKubernetesClientMockDynamic

	funcGet          func(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption) (err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mKubernetesClientMockGet

	funcGroupVersionKindFor          func(obj runtime.Object) (g1 schema.GroupVersionKind, err error)
	funcGroupVersionKindForOrigin    string
	inspectFuncGroupVersionKindFor   func(obj runtime.Object)
	afterGroupVersionKindForCounter  uint64
	beforeGroupVersionKindForCounter uint64
	GroupVersionKindForMock          mKubernetesClientMockGroupVersionKindFor

	funcIsObjectNamespaced          func(obj runtime.Object) (b1 bool, err error)
	funcIsObjectNamespacedOrigin    string
	inspectFuncIsObjectNamespaced   func(obj runtime.Object)
	afterIsObjectNamespacedCounter  uint64
	beforeIsObjectNamespacedCounter uint64
	IsObjectNamespacedMock          mKubernetesClientMockIsObjectNamespaced

	funcList          func(ctx context.Context, list client.ObjectList, opts ...client.ListOption) (err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, list client.ObjectList, opts ...client.ListOption)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mKubernetesClientMockList

	funcPatch          func(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption) (err error)
	funcPatchOrigin    string
	inspectFuncPatch   func(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption)
	afterPatchCounter  uint64
	beforePatchCounter uint64
	PatchMock          mKubernetesClientMockPatch

	funcRESTMapper          func() (r1 meta.RESTMapper)
	funcRESTMapperOrigin    string
	inspectFuncRESTMapper   func()
	afterRESTMapperCounter  uint64
	beforeRESTMapperCounter uint64
	RESTMapperMock          mKubernetesClientMockRESTMapper

	funcScheme          func() (sp1 *runtime.Scheme)
	funcSchemeOrigin    string
	inspectFuncScheme   func()
	afterSchemeCounter  uint64
	beforeSchemeCounter uint64
	SchemeMock          mKubernetesClientMockScheme

	funcStatus          func() (s1 client.SubResourceWriter)
	funcStatusOrigin    string
	inspectFuncStatus   func()
	afterStatusCounter  uint64
	beforeStatusCounter uint64
	StatusMock          mKubernetesClientMockStatus

	funcSubResource          func(subResource string) (s1 client.SubResourceClient)
	funcSubResourceOrigin    string
	inspectFuncSubResource   func(subResource string)
	afterSubResourceCounter  uint64
	beforeSubResourceCounter uint64
	SubResourceMock          mKubernetesClientMockSubResource

	funcUpdate          func(ctx context.Context, obj client.Object, opts ...client.UpdateOption) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, obj client.Object, opts ...client.UpdateOption)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mKubernetesClientMockUpdate
}

// NewKubernetesClientMock returns a mock for mm_pkg.KubernetesClient
func NewKubernetesClientMock(t minimock.Tester) *KubernetesClientMock {
	m := &KubernetesClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApplyMock = mKubernetesClientMockApply{mock: m}
	m.ApplyMock.callArgs = []*KubernetesClientMockApplyParams{}

	m.CreateMock = mKubernetesClientMockCreate{mock: m}
	m.CreateMock.callArgs = []*KubernetesClientMockCreateParams{}

	m.DeleteMock = mKubernetesClientMockDelete{mock: m}
	m.DeleteMock.callArgs = []*KubernetesClientMockDeleteParams{}

	m.DeleteAllOfMock = mKubernetesClientMockDeleteAllOf{mock: m}
	m.DeleteAllOfMock.callArgs = []*KubernetesClientMockDeleteAllOfParams{}

	m.DynamicMock = mKubernetesClientMockDynamic{mock: m}

	m.GetMock = mKubernetesClientMockGet{mock: m}
	m.GetMock.callArgs = []*KubernetesClientMockGetParams{}

	m.GroupVersionKindForMock = mKubernetesClientMockGroupVersionKindFor{mock: m}
	m.GroupVersionKindForMock.callArgs = []*KubernetesClientMockGroupVersionKindForParams{}

	m.IsObjectNamespacedMock = mKubernetesClientMockIsObjectNamespaced{mock: m}
	m.IsObjectNamespacedMock.callArgs = []*KubernetesClientMockIsObjectNamespacedParams{}

	m.ListMock = mKubernetesClientMockList{mock: m}
	m.ListMock.callArgs = []*KubernetesClientMockListParams{}

	m.PatchMock = mKubernetesClientMockPatch{mock: m}
	m.PatchMock.callArgs = []*KubernetesClientMockPatchParams{}

	m.RESTMapperMock = mKubernetesClientMockRESTMapper{mock: m}

	m.SchemeMock = mKubernetesClientMockScheme{mock: m}

	m.StatusMock = mKubernetesClientMockStatus{mock: m}

	m.SubResourceMock = mKubernetesClientMockSubResource{mock: m}
	m.SubResourceMock.callArgs = []*KubernetesClientMockSubResourceParams{}

	m.UpdateMock = mKubernetesClientMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*KubernetesClientMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mKubernetesClientMockApply struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockApplyExpectation
	expectations       []*KubernetesClientMockApplyExpectation

	callArgs []*KubernetesClientMockApplyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockApplyExpectation specifies expectation struct of the KubernetesClient.Apply
type KubernetesClientMockApplyExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockApplyParams
	paramPtrs          *KubernetesClientMockApplyParamPtrs
	expectationOrigins KubernetesClientMockApplyExpectationOrigins
	results            *KubernetesClientMockApplyResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockApplyParams contains parameters of the KubernetesClient.Apply
type KubernetesClientMockApplyParams struct {
	ctx  context.Context
	obj  runtime.ApplyConfiguration
	opts []client.ApplyOption
}

// KubernetesClientMockApplyParamPtrs contains pointers to parameters of the KubernetesClient.Apply
type KubernetesClientMockApplyParamPtrs struct {
	ctx  *context.Context
	obj  *runtime.ApplyConfiguration
	opts *[]client.ApplyOption
}

// KubernetesClientMockApplyResults contains results of the KubernetesClient.Apply
type KubernetesClientMockApplyResults struct {
	err error
}

// KubernetesClientMockApplyOrigins contains origins of expectations of the KubernetesClient.Apply
type KubernetesClientMockApplyExpectationOrigins struct {
	origin     string
	originCtx  string
	originObj  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApply *mKubernetesClientMockApply) Optional() *mKubernetesClientMockApply {
	mmApply.optional = true
	return mmApply
}

// Expect sets up expected params for KubernetesClient.Apply
func (mmApply *mKubernetesClientMockApply) Expect(ctx context.Context, obj runtime.ApplyConfiguration, opts ...client.ApplyOption) *mKubernetesClientMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesClientMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.paramPtrs != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by ExpectParams functions")
	}

	mmApply.defaultExpectation.params = &KubernetesClientMockApplyParams{ctx, obj, opts}
	mmApply.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApply.expectations {
		if minimock.Equal(e.params, mmApply.defaultExpectation.params) {
			mmApply.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApply.defaultExpectation.params)
		}
	}

	return mmApply
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.Apply
func (mmApply *mKubernetesClientMockApply) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesClientMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesClientMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.ctx = &ctx
	mmApply.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmApply
}

// ExpectObjParam2 sets up expected param obj for KubernetesClient.Apply
func (mmApply *mKubernetesClientMockApply) ExpectObjParam2(obj runtime.ApplyConfiguration) *mKubernetesClientMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesClientMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesClientMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.obj = &obj
	mmApply.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmApply
}

// ExpectOptsParam3 sets up expected param opts for KubernetesClient.Apply
func (mmApply *mKubernetesClientMockApply) ExpectOptsParam3(opts ...client.ApplyOption) *mKubernetesClientMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesClientMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesClientMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.opts = &opts
	mmApply.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmApply
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Apply
func (mmApply *mKubernetesClientMockApply) Inspect(f func(ctx context.Context, obj runtime.ApplyConfiguration, opts ...client.ApplyOption)) *mKubernetesClientMockApply {
	if mmApply.mock.inspectFuncApply != nil {
		mmApply.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Apply")
	}

	mmApply.mock.inspectFuncApply = f

	return mmApply
}

// Return sets up results that will be returned by KubernetesClient.Apply
func (mmApply *mKubernetesClientMockApply) Return(err error) *KubernetesClientMock {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesClientMockApplyExpectation{mock: mmApply.mock}
	}
	mmApply.defaultExpectation.results = &KubernetesClientMockApplyResults{err}
	mmApply.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApply.mock
}

// Set uses given function f to mock the KubernetesClient.Apply method
func (mmApply *mKubernetesClientMockApply) Set(f func(ctx context.Context, obj runtime.ApplyConfiguration, opts ...client.ApplyOption) (err error)) *KubernetesClientMock {
	if mmApply.defaultExpectation != nil {
		mmApply.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Apply method")
	}

	if len(mmApply.expectations) > 0 {
		mmApply.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Apply method")
	}

	mmApply.mock.funcApply = f
	mmApply.mock.funcApplyOrigin = minimock.CallerInfo(1)
	return mmApply.mock
}

// When sets expectation for the KubernetesClient.Apply which will trigger the result defined by the following
// Then helper
func (mmApply *mKubernetesClientMockApply) When(ctx context.Context, obj runtime.ApplyConfiguration, opts ...client.ApplyOption) *KubernetesClientMockApplyExpectation {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesClientMock.Apply mock is already set by Set")
	}

	expectation := &KubernetesClientMockApplyExpectation{
		mock:               mmApply.mock,
		params:             &KubernetesClientMockApplyParams{ctx, obj, opts},
		expectationOrigins: KubernetesClientMockApplyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmApply.expectations = append(mmApply.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.Apply return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockApplyExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockApplyResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.Apply should be invoked
func (mmApply *mKubernetesClientMockApply) Times(n uint64) *mKubernetesClientMockApply {
	if n == 0 {
		mmApply.mock.t.Fatalf("Times of KubernetesClientMock.Apply mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApply.expectedInvocations, n)
	mmApply.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApply
}

func (mmApply *mKubernetesClientMockApply) invocationsDone() bool {
	if len(mmApply.expectations) == 0 && mmApply.defaultExpectation == nil && mmApply.mock.funcApply == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApply.mock.afterApplyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApply.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Apply implements mm_pkg.KubernetesClient
func (mmApply *KubernetesClientMock) Apply(ctx context.Context, obj runtime.ApplyConfiguration, opts ...client.ApplyOption) (err error) {
	mm_atomic.AddUint64(&mmApply.beforeApplyCounter, 1)
	defer mm_atomic.AddUint64(&mmApply.afterApplyCounter, 1)

	mmApply.t.Helper()

	if mmApply.inspectFuncApply != nil {
		mmApply.inspectFuncApply(ctx, obj, opts...)
	}

	mm_params := KubernetesClientMockApplyParams{ctx, obj, opts}

	// Record call args
	mmApply.ApplyMock.mutex.Lock()
	mmApply.ApplyMock.callArgs = append(mmApply.ApplyMock.callArgs, &mm_params)
	mmApply.ApplyMock.mutex.Unlock()

	for _, e := range mmApply.ApplyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmApply.ApplyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApply.ApplyMock.defaultExpectation.Counter, 1)
		mm_want := mmApply.ApplyMock.defaultExpectation.params
		mm_want_ptrs := mmApply.ApplyMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockApplyParams{ctx, obj, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmApply.t.Errorf("KubernetesClientMock.Apply got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmApply.t.Errorf("KubernetesClientMock.Apply got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmApply.t.Errorf("KubernetesClientMock.Apply got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApply.t.Errorf("KubernetesClientMock.Apply got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApply.ApplyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApply.ApplyMock.defaultExpectation.results
		if mm_results == nil {
			mmApply.t.Fatal("No results are set for the KubernetesClientMock.Apply")
		}
		return (*mm_results).err
	}
	if mmApply.funcApply != nil {
		return mmApply.funcApply(ctx, obj, opts...)
	}
	mmApply.t.Fatalf("Unexpected call to KubernetesClientMock.Apply. %v %v %v", ctx, obj, opts)
	return
}

// ApplyAfterCounter returns a count of finished KubernetesClientMock.Apply invocations
func (mmApply *KubernetesClientMock) ApplyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApply.afterApplyCounter)
}

// ApplyBeforeCounter returns a count of KubernetesClientMock.Apply invocations
func (mmApply *KubernetesClientMock) ApplyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApply.beforeApplyCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.Apply.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApply *mKubernetesClientMockApply) Calls() []*KubernetesClientMockApplyParams {
	mmApply.mutex.RLock()

	argCopy := make([]*KubernetesClientMockApplyParams, len(mmApply.callArgs))
	copy(argCopy, mmApply.callArgs)

	mmApply.mutex.RUnlock()

	return argCopy
}

// MinimockApplyDone returns true if the count of the Apply invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockApplyDone() bool {
	if m.ApplyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyMock.invocationsDone()
}

// MinimockApplyInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockApplyInspect() {
	for _, e := range m.ApplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.Apply at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyCounter := mm_atomic.LoadUint64(&m.afterApplyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyMock.defaultExpectation != nil && afterApplyCounter < 1 {
		if m.ApplyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.Apply at\n%s", m.ApplyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.Apply at\n%s with params: %#v", m.ApplyMock.defaultExpectation.expectationOrigins.origin, *m.ApplyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApply != nil && afterApplyCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Apply at\n%s", m.funcApplyOrigin)
	}

	if !m.ApplyMock.invocationsDone() && afterApplyCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Apply at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyMock.expectedInvocations), m.ApplyMock.expectedInvocationsOrigin, afterApplyCounter)
	}
}

type mKubernetesClientMockCreate struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockCreateExpectation
	expectations       []*KubernetesClientMockCreateExpectation

	callArgs []*KubernetesClientMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockCreateExpectation specifies expectation struct of the KubernetesClient.Create
type KubernetesClientMockCreateExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockCreateParams
	paramPtrs          *KubernetesClientMockCreateParamPtrs
	expectationOrigins KubernetesClientMockCreateExpectationOrigins
	results            *KubernetesClientMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockCreateParams contains parameters of the KubernetesClient.Create
type KubernetesClientMockCreateParams struct {
	ctx  context.Context
	obj  client.Object
	opts []client.CreateOption
}

// KubernetesClientMockCreateParamPtrs contains pointers to parameters of the KubernetesClient.Create
type KubernetesClientMockCreateParamPtrs struct {
	ctx  *context.Context
	obj  *client.Object
	opts *[]client.CreateOption
}

// KubernetesClientMockCreateResults contains results of the KubernetesClient.Create
type KubernetesClientMockCreateResults struct {
	err error
}

// KubernetesClientMockCreateOrigins contains origins of expectations of the KubernetesClient.Create
type KubernetesClientMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originObj  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mKubernetesClientMockCreate) Optional() *mKubernetesClientMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for KubernetesClient.Create
func (mmCreate *mKubernetesClientMockCreate) Expect(ctx context.Context, obj client.Object, opts ...client.CreateOption) *mKubernetesClientMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesClientMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &KubernetesClientMockCreateParams{ctx, obj, opts}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.Create
func (mmCreate *mKubernetesClientMockCreate) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesClientMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &KubernetesClientMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectObjParam2 sets up expected param obj for KubernetesClient.Create
func (mmCreate *mKubernetesClientMockCreate) ExpectObjParam2(obj client.Object) *mKubernetesClientMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesClientMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &KubernetesClientMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.obj = &obj
	mmCreate.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectOptsParam3 sets up expected param opts for KubernetesClient.Create
func (mmCreate *mKubernetesClientMockCreate) ExpectOptsParam3(opts ...client.CreateOption) *mKubernetesClientMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesClientMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &KubernetesClientMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.opts = &opts
	mmCreate.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Create
func (mmCreate *mKubernetesClientMockCreate) Inspect(f func(ctx context.Context, obj client.Object, opts ...client.CreateOption)) *mKubernetesClientMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by KubernetesClient.Create
func (mmCreate *mKubernetesClientMockCreate) Return(err error) *KubernetesClientMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesClientMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &KubernetesClientMockCreateResults{err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the KubernetesClient.Create method
func (mmCreate *mKubernetesClientMockCreate) Set(f func(ctx context.Context, obj client.Object, opts ...client.CreateOption) (err error)) *KubernetesClientMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the KubernetesClient.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mKubernetesClientMockCreate) When(ctx context.Context, obj client.Object, opts ...client.CreateOption) *KubernetesClientMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesClientMock.Create mock is already set by Set")
	}

	expectation := &KubernetesClientMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &KubernetesClientMockCreateParams{ctx, obj, opts},
		expectationOrigins: KubernetesClientMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.Create return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockCreateExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockCreateResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.Create should be invoked
func (mmCreate *mKubernetesClientMockCreate) Times(n uint64) *mKubernetesClientMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of KubernetesClientMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mKubernetesClientMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_pkg.KubernetesClient
func (mmCreate *KubernetesClientMock) Create(ctx context.Context, obj client.Object, opts ...client.CreateOption) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, obj, opts...)
	}

	mm_params := KubernetesClientMockCreateParams{ctx, obj, opts}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockCreateParams{ctx, obj, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("KubernetesClientMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmCreate.t.Errorf("KubernetesClientMock.Create got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreate.t.Errorf("KubernetesClientMock.Create got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("KubernetesClientMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the KubernetesClientMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, obj, opts...)
	}
	mmCreate.t.Fatalf("Unexpected call to KubernetesClientMock.Create. %v %v %v", ctx, obj, opts)
	return
}

// CreateAfterCounter returns a count of finished KubernetesClientMock.Create invocations
func (mmCreate *KubernetesClientMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of KubernetesClientMock.Create invocations
func (mmCreate *KubernetesClientMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mKubernetesClientMockCreate) Calls() []*KubernetesClientMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*KubernetesClientMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mKubernetesClientMockDelete struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockDeleteExpectation
	expectations       []*KubernetesClientMockDeleteExpectation

	callArgs []*KubernetesClientMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockDeleteExpectation specifies expectation struct of the KubernetesClient.Delete
type KubernetesClientMockDeleteExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockDeleteParams
	paramPtrs          *KubernetesClientMockDeleteParamPtrs
	expectationOrigins KubernetesClientMockDeleteExpectationOrigins
	results            *KubernetesClientMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockDeleteParams contains parameters of the KubernetesClient.Delete
type KubernetesClientMockDeleteParams struct {
	ctx  context.Context
	obj  client.Object
	opts []client.DeleteOption
}

// KubernetesClientMockDeleteParamPtrs contains pointers to parameters of the KubernetesClient.Delete
type KubernetesClientMockDeleteParamPtrs struct {
	ctx  *context.Context
	obj  *client.Object
	opts *[]client.DeleteOption
}

// KubernetesClientMockDeleteResults contains results of the KubernetesClient.Delete
type KubernetesClientMockDeleteResults struct {
	err error
}

// KubernetesClientMockDeleteOrigins contains origins of expectations of the KubernetesClient.Delete
type KubernetesClientMockDeleteExpectationOrigins struct {
	origin     string
	originCtx  string
	originObj  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mKubernetesClientMockDelete) Optional() *mKubernetesClientMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for KubernetesClient.Delete
func (mmDelete *mKubernetesClientMockDelete) Expect(ctx context.Context, obj client.Object, opts ...client.DeleteOption) *mKubernetesClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesClientMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &KubernetesClientMockDeleteParams{ctx, obj, opts}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.Delete
func (mmDelete *mKubernetesClientMockDelete) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesClientMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &KubernetesClientMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectObjParam2 sets up expected param obj for KubernetesClient.Delete
func (mmDelete *mKubernetesClientMockDelete) ExpectObjParam2(obj client.Object) *mKubernetesClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesClientMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &KubernetesClientMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.obj = &obj
	mmDelete.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectOptsParam3 sets up expected param opts for KubernetesClient.Delete
func (mmDelete *mKubernetesClientMockDelete) ExpectOptsParam3(opts ...client.DeleteOption) *mKubernetesClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesClientMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &KubernetesClientMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.opts = &opts
	mmDelete.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Delete
func (mmDelete *mKubernetesClientMockDelete) Inspect(f func(ctx context.Context, obj client.Object, opts ...client.DeleteOption)) *mKubernetesClientMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by KubernetesClient.Delete
func (mmDelete *mKubernetesClientMockDelete) Return(err error) *KubernetesClientMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesClientMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &KubernetesClientMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the KubernetesClient.Delete method
func (mmDelete *mKubernetesClientMockDelete) Set(f func(ctx context.Context, obj client.Object, opts ...client.DeleteOption) (err error)) *KubernetesClientMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the KubernetesClient.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mKubernetesClientMockDelete) When(ctx context.Context, obj client.Object, opts ...client.DeleteOption) *KubernetesClientMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesClientMock.Delete mock is already set by Set")
	}

	expectation := &KubernetesClientMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &KubernetesClientMockDeleteParams{ctx, obj, opts},
		expectationOrigins: KubernetesClientMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.Delete return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockDeleteExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockDeleteResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.Delete should be invoked
func (mmDelete *mKubernetesClientMockDelete) Times(n uint64) *mKubernetesClientMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of KubernetesClientMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mKubernetesClientMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_pkg.KubernetesClient
func (mmDelete *KubernetesClientMock) Delete(ctx context.Context, obj client.Object, opts ...client.DeleteOption) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, obj, opts...)
	}

	mm_params := KubernetesClientMockDeleteParams{ctx, obj, opts}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockDeleteParams{ctx, obj, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("KubernetesClientMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmDelete.t.Errorf("KubernetesClientMock.Delete got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDelete.t.Errorf("KubernetesClientMock.Delete got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("KubernetesClientMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the KubernetesClientMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, obj, opts...)
	}
	mmDelete.t.Fatalf("Unexpected call to KubernetesClientMock.Delete. %v %v %v", ctx, obj, opts)
	return
}

// DeleteAfterCounter returns a count of finished KubernetesClientMock.Delete invocations
func (mmDelete *KubernetesClientMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of KubernetesClientMock.Delete invocations
func (mmDelete *KubernetesClientMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mKubernetesClientMockDelete) Calls() []*KubernetesClientMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*KubernetesClientMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mKubernetesClientMockDeleteAllOf struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockDeleteAllOfExpectation
	expectations       []*KubernetesClientMockDeleteAllOfExpectation

	callArgs []*KubernetesClientMockDeleteAllOfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockDeleteAllOfExpectation specifies expectation struct of the KubernetesClient.DeleteAllOf
type KubernetesClientMockDeleteAllOfExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockDeleteAllOfParams
	paramPtrs          *KubernetesClientMockDeleteAllOfParamPtrs
	expectationOrigins KubernetesClientMockDeleteAllOfExpectationOrigins
	results            *KubernetesClientMockDeleteAllOfResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockDeleteAllOfParams contains parameters of the KubernetesClient.DeleteAllOf
type KubernetesClientMockDeleteAllOfParams struct {
	ctx  context.Context
	obj  client.Object
	opts []client.DeleteAllOfOption
}

// KubernetesClientMockDeleteAllOfParamPtrs contains pointers to parameters of the KubernetesClient.DeleteAllOf
type KubernetesClientMockDeleteAllOfParamPtrs struct {
	ctx  *context.Context
	obj  *client.Object
	opts *[]client.DeleteAllOfOption
}

// KubernetesClientMockDeleteAllOfResults contains results of the KubernetesClient.DeleteAllOf
type KubernetesClientMockDeleteAllOfResults struct {
	err error
}

// KubernetesClientMockDeleteAllOfOrigins contains origins of expectations of the KubernetesClient.DeleteAllOf
type KubernetesClientMockDeleteAllOfExpectationOrigins struct {
	origin     string
	originCtx  string
	originObj  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) Optional() *mKubernetesClientMockDeleteAllOf {
	mmDeleteAllOf.optional = true
	return mmDeleteAllOf
}

// Expect sets up expected params for KubernetesClient.DeleteAllOf
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) Expect(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption) *mKubernetesClientMockDeleteAllOf {
	if mmDeleteAllOf.mock.funcDeleteAllOf != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Set")
	}

	if mmDeleteAllOf.defaultExpectation == nil {
		mmDeleteAllOf.defaultExpectation = &KubernetesClientMockDeleteAllOfExpectation{}
	}

	if mmDeleteAllOf.defaultExpectation.paramPtrs != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by ExpectParams functions")
	}

	mmDeleteAllOf.defaultExpectation.params = &KubernetesClientMockDeleteAllOfParams{ctx, obj, opts}
	mmDeleteAllOf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAllOf.expectations {
		if minimock.Equal(e.params, mmDeleteAllOf.defaultExpectation.params) {
			mmDeleteAllOf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllOf.defaultExpectation.params)
		}
	}

	return mmDeleteAllOf
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.DeleteAllOf
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockDeleteAllOf {
	if mmDeleteAllOf.mock.funcDeleteAllOf != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Set")
	}

	if mmDeleteAllOf.defaultExpectation == nil {
		mmDeleteAllOf.defaultExpectation = &KubernetesClientMockDeleteAllOfExpectation{}
	}

	if mmDeleteAllOf.defaultExpectation.params != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Expect")
	}

	if mmDeleteAllOf.defaultExpectation.paramPtrs == nil {
		mmDeleteAllOf.defaultExpectation.paramPtrs = &KubernetesClientMockDeleteAllOfParamPtrs{}
	}
	mmDeleteAllOf.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAllOf.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAllOf
}

// ExpectObjParam2 sets up expected param obj for KubernetesClient.DeleteAllOf
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) ExpectObjParam2(obj client.Object) *mKubernetesClientMockDeleteAllOf {
	if mmDeleteAllOf.mock.funcDeleteAllOf != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Set")
	}

	if mmDeleteAllOf.defaultExpectation == nil {
		mmDeleteAllOf.defaultExpectation = &KubernetesClientMockDeleteAllOfExpectation{}
	}

	if mmDeleteAllOf.defaultExpectation.params != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Expect")
	}

	if mmDeleteAllOf.defaultExpectation.paramPtrs == nil {
		mmDeleteAllOf.defaultExpectation.paramPtrs = &KubernetesClientMockDeleteAllOfParamPtrs{}
	}
	mmDeleteAllOf.defaultExpectation.paramPtrs.obj = &obj
	mmDeleteAllOf.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmDeleteAllOf
}

// ExpectOptsParam3 sets up expected param opts for KubernetesClient.DeleteAllOf
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) ExpectOptsParam3(opts ...client.DeleteAllOfOption) *mKubernetesClientMockDeleteAllOf {
	if mmDeleteAllOf.mock.funcDeleteAllOf != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Set")
	}

	if mmDeleteAllOf.defaultExpectation == nil {
		mmDeleteAllOf.defaultExpectation = &KubernetesClientMockDeleteAllOfExpectation{}
	}

	if mmDeleteAllOf.defaultExpectation.params != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Expect")
	}

	if mmDeleteAllOf.defaultExpectation.paramPtrs == nil {
		mmDeleteAllOf.defaultExpectation.paramPtrs = &KubernetesClientMockDeleteAllOfParamPtrs{}
	}
	mmDeleteAllOf.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteAllOf.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteAllOf
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.DeleteAllOf
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) Inspect(f func(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption)) *mKubernetesClientMockDeleteAllOf {
	if mmDeleteAllOf.mock.inspectFuncDeleteAllOf != nil {
		mmDeleteAllOf.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.DeleteAllOf")
	}

	mmDeleteAllOf.mock.inspectFuncDeleteAllOf = f

	return mmDeleteAllOf
}

// Return sets up results that will be returned by KubernetesClient.DeleteAllOf
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) Return(err error) *KubernetesClientMock {
	if mmDeleteAllOf.mock.funcDeleteAllOf != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Set")
	}

	if mmDeleteAllOf.defaultExpectation == nil {
		mmDeleteAllOf.defaultExpectation = &KubernetesClientMockDeleteAllOfExpectation{mock: mmDeleteAllOf.mock}
	}
	mmDeleteAllOf.defaultExpectation.results = &KubernetesClientMockDeleteAllOfResults{err}
	mmDeleteAllOf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAllOf.mock
}

// Set uses given function f to mock the KubernetesClient.DeleteAllOf method
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) Set(f func(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption) (err error)) *KubernetesClientMock {
	if mmDeleteAllOf.defaultExpectation != nil {
		mmDeleteAllOf.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.DeleteAllOf method")
	}

	if len(mmDeleteAllOf.expectations) > 0 {
		mmDeleteAllOf.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.DeleteAllOf method")
	}

	mmDeleteAllOf.mock.funcDeleteAllOf = f
	mmDeleteAllOf.mock.funcDeleteAllOfOrigin = minimock.CallerInfo(1)
	return mmDeleteAllOf.mock
}

// When sets expectation for the KubernetesClient.DeleteAllOf which will trigger the result defined by the following
// Then helper
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) When(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption) *KubernetesClientMockDeleteAllOfExpectation {
	if mmDeleteAllOf.mock.funcDeleteAllOf != nil {
		mmDeleteAllOf.mock.t.Fatalf("KubernetesClientMock.DeleteAllOf mock is already set by Set")
	}

	expectation := &KubernetesClientMockDeleteAllOfExpectation{
		mock:               mmDeleteAllOf.mock,
		params:             &KubernetesClientMockDeleteAllOfParams{ctx, obj, opts},
		expectationOrigins: KubernetesClientMockDeleteAllOfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAllOf.expectations = append(mmDeleteAllOf.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.DeleteAllOf return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockDeleteAllOfExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockDeleteAllOfResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.DeleteAllOf should be invoked
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) Times(n uint64) *mKubernetesClientMockDeleteAllOf {
	if n == 0 {
		mmDeleteAllOf.mock.t.Fatalf("Times of KubernetesClientMock.DeleteAllOf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllOf.expectedInvocations, n)
	mmDeleteAllOf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAllOf
}

func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) invocationsDone() bool {
	if len(mmDeleteAllOf.expectations) == 0 && mmDeleteAllOf.defaultExpectation == nil && mmDeleteAllOf.mock.funcDeleteAllOf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllOf.mock.afterDeleteAllOfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllOf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllOf implements mm_pkg.KubernetesClient
func (mmDeleteAllOf *KubernetesClientMock) DeleteAllOf(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllOf.beforeDeleteAllOfCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllOf.afterDeleteAllOfCounter, 1)

	mmDeleteAllOf.t.Helper()

	if mmDeleteAllOf.inspectFuncDeleteAllOf != nil {
		mmDeleteAllOf.inspectFuncDeleteAllOf(ctx, obj, opts...)
	}

	mm_params := KubernetesClientMockDeleteAllOfParams{ctx, obj, opts}

	// Record call args
	mmDeleteAllOf.DeleteAllOfMock.mutex.Lock()
	mmDeleteAllOf.DeleteAllOfMock.callArgs = append(mmDeleteAllOf.DeleteAllOfMock.callArgs, &mm_params)
	mmDeleteAllOf.DeleteAllOfMock.mutex.Unlock()

	for _, e := range mmDeleteAllOf.DeleteAllOfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllOf.DeleteAllOfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockDeleteAllOfParams{ctx, obj, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllOf.t.Errorf("KubernetesClientMock.DeleteAllOf got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmDeleteAllOf.t.Errorf("KubernetesClientMock.DeleteAllOf got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteAllOf.t.Errorf("KubernetesClientMock.DeleteAllOf got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllOf.t.Errorf("KubernetesClientMock.DeleteAllOf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllOf.DeleteAllOfMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllOf.t.Fatal("No results are set for the KubernetesClientMock.DeleteAllOf")
		}
		return (*mm_results).err
	}
	if mmDeleteAllOf.funcDeleteAllOf != nil {
		return mmDeleteAllOf.funcDeleteAllOf(ctx, obj, opts...)
	}
	mmDeleteAllOf.t.Fatalf("Unexpected call to KubernetesClientMock.DeleteAllOf. %v %v %v", ctx, obj, opts)
	return
}

// DeleteAllOfAfterCounter returns a count of finished KubernetesClientMock.DeleteAllOf invocations
func (mmDeleteAllOf *KubernetesClientMock) DeleteAllOfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllOf.afterDeleteAllOfCounter)
}

// DeleteAllOfBeforeCounter returns a count of KubernetesClientMock.DeleteAllOf invocations
func (mmDeleteAllOf *KubernetesClientMock) DeleteAllOfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllOf.beforeDeleteAllOfCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.DeleteAllOf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllOf *mKubernetesClientMockDeleteAllOf) Calls() []*KubernetesClientMockDeleteAllOfParams {
	mmDeleteAllOf.mutex.RLock()

	argCopy := make([]*KubernetesClientMockDeleteAllOfParams, len(mmDeleteAllOf.callArgs))
	copy(argCopy, mmDeleteAllOf.callArgs)

	mmDeleteAllOf.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllOfDone returns true if the count of the DeleteAllOf invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockDeleteAllOfDone() bool {
	if m.DeleteAllOfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAllOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllOfMock.invocationsDone()
}

// MinimockDeleteAllOfInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockDeleteAllOfInspect() {
	for _, e := range m.DeleteAllOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.DeleteAllOf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAllOfCounter := mm_atomic.LoadUint64(&m.afterDeleteAllOfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllOfMock.defaultExpectation != nil && afterDeleteAllOfCounter < 1 {
		if m.DeleteAllOfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.DeleteAllOf at\n%s", m.DeleteAllOfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.DeleteAllOf at\n%s with params: %#v", m.DeleteAllOfMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAllOfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllOf != nil && afterDeleteAllOfCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.DeleteAllOf at\n%s", m.funcDeleteAllOfOrigin)
	}

	if !m.DeleteAllOfMock.invocationsDone() && afterDeleteAllOfCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.DeleteAllOf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllOfMock.expectedInvocations), m.DeleteAllOfMock.expectedInvocationsOrigin, afterDeleteAllOfCounter)
	}
}

type mKubernetesClientMockDynamic struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockDynamicExpectation
	expectations       []*KubernetesClientMockDynamicExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockDynamicExpectation specifies expectation struct of the KubernetesClient.Dynamic
type KubernetesClientMockDynamicExpectation struct {
	mock *KubernetesClientMock

	results      *KubernetesClientMockDynamicResults
	returnOrigin string
	Counter      uint64
}

// KubernetesClientMockDynamicResults contains results of the KubernetesClient.Dynamic
type KubernetesClientMockDynamicResults struct {
	i1 dynamic.Interface
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDynamic *mKubernetesClientMockDynamic) Optional() *mKubernetesClientMockDynamic {
	mmDynamic.optional = true
	return mmDynamic
}

// Expect sets up expected params for KubernetesClient.Dynamic
func (mmDynamic *mKubernetesClientMockDynamic) Expect() *mKubernetesClientMockDynamic {
	if mmDynamic.mock.funcDynamic != nil {
		mmDynamic.mock.t.Fatalf("KubernetesClientMock.Dynamic mock is already set by Set")
	}

	if mmDynamic.defaultExpectation == nil {
		mmDynamic.defaultExpectation = &KubernetesClientMockDynamicExpectation{}
	}

	return mmDynamic
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Dynamic
func (mmDynamic *mKubernetesClientMockDynamic) Inspect(f func()) *mKubernetesClientMockDynamic {
	if mmDynamic.mock.inspectFuncDynamic != nil {
		mmDynamic.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Dynamic")
	}

	mmDynamic.mock.inspectFuncDynamic = f

	return mmDynamic
}

// Return sets up results that will be returned by KubernetesClient.Dynamic
func (mmDynamic *mKubernetesClientMockDynamic) Return(i1 dynamic.Interface) *KubernetesClientMock {
	if mmDynamic.mock.funcDynamic != nil {
		mmDynamic.mock.t.Fatalf("KubernetesClientMock.Dynamic mock is already set by Set")
	}

	if mmDynamic.defaultExpectation == nil {
		mmDynamic.defaultExpectation = &KubernetesClientMockDynamicExpectation{mock: mmDynamic.mock}
	}
	mmDynamic.defaultExpectation.results = &KubernetesClientMockDynamicResults{i1}
	mmDynamic.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDynamic.mock
}

// Set uses given function f to mock the KubernetesClient.Dynamic method
func (mmDynamic *mKubernetesClientMockDynamic) Set(f func() (i1 dynamic.Interface)) *KubernetesClientMock {
	if mmDynamic.defaultExpectation != nil {
		mmDynamic.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Dynamic method")
	}

	if len(mmDynamic.expectations) > 0 {
		mmDynamic.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Dynamic method")
	}

	mmDynamic.mock.funcDynamic = f
	mmDynamic.mock.funcDynamicOrigin = minimock.CallerInfo(1)
	return mmDynamic.mock
}

// Times sets number of times KubernetesClient.Dynamic should be invoked
func (mmDynamic *mKubernetesClientMockDynamic) Times(n uint64) *mKubernetesClientMockDynamic {
	if n == 0 {
		mmDynamic.mock.t.Fatalf("Times of KubernetesClientMock.Dynamic mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDynamic.expectedInvocations, n)
	mmDynamic.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDynamic
}

func (mmDynamic *mKubernetesClientMockDynamic) invocationsDone() bool {
	if len(mmDynamic.expectations) == 0 && mmDynamic.defaultExpectation == nil && mmDynamic.mock.funcDynamic == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDynamic.mock.afterDynamicCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDynamic.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Dynamic implements mm_pkg.KubernetesClient
func (mmDynamic *KubernetesClientMock) Dynamic() (i1 dynamic.Interface) {
	mm_atomic.AddUint64(&mmDynamic.beforeDynamicCounter, 1)
	defer mm_atomic.AddUint64(&mmDynamic.afterDynamicCounter, 1)

	mmDynamic.t.Helper()

	if mmDynamic.inspectFuncDynamic != nil {
		mmDynamic.inspectFuncDynamic()
	}

	if mmDynamic.DynamicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDynamic.DynamicMock.defaultExpectation.Counter, 1)

		mm_results := mmDynamic.DynamicMock.defaultExpectation.results
		if mm_results == nil {
			mmDynamic.t.Fatal("No results are set for the KubernetesClientMock.Dynamic")
		}
		return (*mm_results).i1
	}
	if mmDynamic.funcDynamic != nil {
		return mmDynamic.funcDynamic()
	}
	mmDynamic.t.Fatalf("Unexpected call to KubernetesClientMock.Dynamic.")
	return
}

// DynamicAfterCounter returns a count of finished KubernetesClientMock.Dynamic invocations
func (mmDynamic *KubernetesClientMock) DynamicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDynamic.afterDynamicCounter)
}

// DynamicBeforeCounter returns a count of KubernetesClientMock.Dynamic invocations
func (mmDynamic *KubernetesClientMock) DynamicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDynamic.beforeDynamicCounter)
}

// MinimockDynamicDone returns true if the count of the Dynamic invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockDynamicDone() bool {
	if m.DynamicMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DynamicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DynamicMock.invocationsDone()
}

// MinimockDynamicInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockDynamicInspect() {
	for _, e := range m.DynamicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to KubernetesClientMock.Dynamic")
		}
	}

	afterDynamicCounter := mm_atomic.LoadUint64(&m.afterDynamicCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DynamicMock.defaultExpectation != nil && afterDynamicCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Dynamic at\n%s", m.DynamicMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDynamic != nil && afterDynamicCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Dynamic at\n%s", m.funcDynamicOrigin)
	}

	if !m.DynamicMock.invocationsDone() && afterDynamicCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Dynamic at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DynamicMock.expectedInvocations), m.DynamicMock.expectedInvocationsOrigin, afterDynamicCounter)
	}
}

type mKubernetesClientMockGet struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockGetExpectation
	expectations       []*KubernetesClientMockGetExpectation

	callArgs []*KubernetesClientMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockGetExpectation specifies expectation struct of the KubernetesClient.Get
type KubernetesClientMockGetExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockGetParams
	paramPtrs          *KubernetesClientMockGetParamPtrs
	expectationOrigins KubernetesClientMockGetExpectationOrigins
	results            *KubernetesClientMockGetResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockGetParams contains parameters of the KubernetesClient.Get
type KubernetesClientMockGetParams struct {
	ctx  context.Context
	key  client.ObjectKey
	obj  client.Object
	opts []client.GetOption
}

// KubernetesClientMockGetParamPtrs contains pointers to parameters of the KubernetesClient.Get
type KubernetesClientMockGetParamPtrs struct {
	ctx  *context.Context
	key  *client.ObjectKey
	obj  *client.Object
	opts *[]client.GetOption
}

// KubernetesClientMockGetResults contains results of the KubernetesClient.Get
type KubernetesClientMockGetResults struct {
	err error
}

// KubernetesClientMockGetOrigins contains origins of expectations of the KubernetesClient.Get
type KubernetesClientMockGetExpectationOrigins struct {
	origin     string
	originCtx  string
	originKey  string
	originObj  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mKubernetesClientMockGet) Optional() *mKubernetesClientMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for KubernetesClient.Get
func (mmGet *mKubernetesClientMockGet) Expect(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption) *mKubernetesClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &KubernetesClientMockGetParams{ctx, key, obj, opts}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.Get
func (mmGet *mKubernetesClientMockGet) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for KubernetesClient.Get
func (mmGet *mKubernetesClientMockGet) ExpectKeyParam2(key client.ObjectKey) *mKubernetesClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key
	mmGet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGet
}

// ExpectObjParam3 sets up expected param obj for KubernetesClient.Get
func (mmGet *mKubernetesClientMockGet) ExpectObjParam3(obj client.Object) *mKubernetesClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.obj = &obj
	mmGet.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmGet
}

// ExpectOptsParam4 sets up expected param opts for KubernetesClient.Get
func (mmGet *mKubernetesClientMockGet) ExpectOptsParam4(opts ...client.GetOption) *mKubernetesClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.opts = &opts
	mmGet.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Get
func (mmGet *mKubernetesClientMockGet) Inspect(f func(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption)) *mKubernetesClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by KubernetesClient.Get
func (mmGet *mKubernetesClientMockGet) Return(err error) *KubernetesClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &KubernetesClientMockGetResults{err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the KubernetesClient.Get method
func (mmGet *mKubernetesClientMockGet) Set(f func(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption) (err error)) *KubernetesClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the KubernetesClient.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mKubernetesClientMockGet) When(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption) *KubernetesClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesClientMock.Get mock is already set by Set")
	}

	expectation := &KubernetesClientMockGetExpectation{
		mock:               mmGet.mock,
		params:             &KubernetesClientMockGetParams{ctx, key, obj, opts},
		expectationOrigins: KubernetesClientMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.Get return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockGetExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockGetResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.Get should be invoked
func (mmGet *mKubernetesClientMockGet) Times(n uint64) *mKubernetesClientMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of KubernetesClientMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mKubernetesClientMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_pkg.KubernetesClient
func (mmGet *KubernetesClientMock) Get(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption) (err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key, obj, opts...)
	}

	mm_params := KubernetesClientMockGetParams{ctx, key, obj, opts}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockGetParams{ctx, key, obj, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("KubernetesClientMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("KubernetesClientMock.Get got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmGet.t.Errorf("KubernetesClientMock.Get got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGet.t.Errorf("KubernetesClientMock.Get got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("KubernetesClientMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the KubernetesClientMock.Get")
		}
		return (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key, obj, opts...)
	}
	mmGet.t.Fatalf("Unexpected call to KubernetesClientMock.Get. %v %v %v %v", ctx, key, obj, opts)
	return
}

// GetAfterCounter returns a count of finished KubernetesClientMock.Get invocations
func (mmGet *KubernetesClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of KubernetesClientMock.Get invocations
func (mmGet *KubernetesClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mKubernetesClientMockGet) Calls() []*KubernetesClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*KubernetesClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mKubernetesClientMockGroupVersionKindFor struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockGroupVersionKindForExpectation
	expectations       []*KubernetesClientMockGroupVersionKindForExpectation

	callArgs []*KubernetesClientMockGroupVersionKindForParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockGroupVersionKindForExpectation specifies expectation struct of the KubernetesClient.GroupVersionKindFor
type KubernetesClientMockGroupVersionKindForExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockGroupVersionKindForParams
	paramPtrs          *KubernetesClientMockGroupVersionKindForParamPtrs
	expectationOrigins KubernetesClientMockGroupVersionKindForExpectationOrigins
	results            *KubernetesClientMockGroupVersionKindForResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockGroupVersionKindForParams contains parameters of the KubernetesClient.GroupVersionKindFor
type KubernetesClientMockGroupVersionKindForParams struct {
	obj runtime.Object
}

// KubernetesClientMockGroupVersionKindForParamPtrs contains pointers to parameters of the KubernetesClient.GroupVersionKindFor
type KubernetesClientMockGroupVersionKindForParamPtrs struct {
	obj *runtime.Object
}

// KubernetesClientMockGroupVersionKindForResults contains results of the KubernetesClient.GroupVersionKindFor
type KubernetesClientMockGroupVersionKindForResults struct {
	g1  schema.GroupVersionKind
	err error
}

// KubernetesClientMockGroupVersionKindForOrigins contains origins of expectations of the KubernetesClient.GroupVersionKindFor
type KubernetesClientMockGroupVersionKindForExpectationOrigins struct {
	origin    string
	originObj string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) Optional() *mKubernetesClientMockGroupVersionKindFor {
	mmGroupVersionKindFor.optional = true
	return mmGroupVersionKindFor
}

// Expect sets up expected params for KubernetesClient.GroupVersionKindFor
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) Expect(obj runtime.Object) *mKubernetesClientMockGroupVersionKindFor {
	if mmGroupVersionKindFor.mock.funcGroupVersionKindFor != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("KubernetesClientMock.GroupVersionKindFor mock is already set by Set")
	}

	if mmGroupVersionKindFor.defaultExpectation == nil {
		mmGroupVersionKindFor.defaultExpectation = &KubernetesClientMockGroupVersionKindForExpectation{}
	}

	if mmGroupVersionKindFor.defaultExpectation.paramPtrs != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("KubernetesClientMock.GroupVersionKindFor mock is already set by ExpectParams functions")
	}

	mmGroupVersionKindFor.defaultExpectation.params = &KubernetesClientMockGroupVersionKindForParams{obj}
	mmGroupVersionKindFor.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGroupVersionKindFor.expectations {
		if minimock.Equal(e.params, mmGroupVersionKindFor.defaultExpectation.params) {
			mmGroupVersionKindFor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGroupVersionKindFor.defaultExpectation.params)
		}
	}

	return mmGroupVersionKindFor
}

// ExpectObjParam1 sets up expected param obj for KubernetesClient.GroupVersionKindFor
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) ExpectObjParam1(obj runtime.Object) *mKubernetesClientMockGroupVersionKindFor {
	if mmGroupVersionKindFor.mock.funcGroupVersionKindFor != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("KubernetesClientMock.GroupVersionKindFor mock is already set by Set")
	}

	if mmGroupVersionKindFor.defaultExpectation == nil {
		mmGroupVersionKindFor.defaultExpectation = &KubernetesClientMockGroupVersionKindForExpectation{}
	}

	if mmGroupVersionKindFor.defaultExpectation.params != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("KubernetesClientMock.GroupVersionKindFor mock is already set by Expect")
	}

	if mmGroupVersionKindFor.defaultExpectation.paramPtrs == nil {
		mmGroupVersionKindFor.defaultExpectation.paramPtrs = &KubernetesClientMockGroupVersionKindForParamPtrs{}
	}
	mmGroupVersionKindFor.defaultExpectation.paramPtrs.obj = &obj
	mmGroupVersionKindFor.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmGroupVersionKindFor
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.GroupVersionKindFor
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) Inspect(f func(obj runtime.Object)) *mKubernetesClientMockGroupVersionKindFor {
	if mmGroupVersionKindFor.mock.inspectFuncGroupVersionKindFor != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.GroupVersionKindFor")
	}

	mmGroupVersionKindFor.mock.inspectFuncGroupVersionKindFor = f

	return mmGroupVersionKindFor
}

// Return sets up results that will be returned by KubernetesClient.GroupVersionKindFor
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) Return(g1 schema.GroupVersionKind, err error) *KubernetesClientMock {
	if mmGroupVersionKindFor.mock.funcGroupVersionKindFor != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("KubernetesClientMock.GroupVersionKindFor mock is already set by Set")
	}

	if mmGroupVersionKindFor.defaultExpectation == nil {
		mmGroupVersionKindFor.defaultExpectation = &KubernetesClientMockGroupVersionKindForExpectation{mock: mmGroupVersionKindFor.mock}
	}
	mmGroupVersionKindFor.defaultExpectation.results = &KubernetesClientMockGroupVersionKindForResults{g1, err}
	mmGroupVersionKindFor.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGroupVersionKindFor.mock
}

// Set uses given function f to mock the KubernetesClient.GroupVersionKindFor method
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) Set(f func(obj runtime.Object) (g1 schema.GroupVersionKind, err error)) *KubernetesClientMock {
	if mmGroupVersionKindFor.defaultExpectation != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.GroupVersionKindFor method")
	}

	if len(mmGroupVersionKindFor.expectations) > 0 {
		mmGroupVersionKindFor.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.GroupVersionKindFor method")
	}

	mmGroupVersionKindFor.mock.funcGroupVersionKindFor = f
	mmGroupVersionKindFor.mock.funcGroupVersionKindForOrigin = minimock.CallerInfo(1)
	return mmGroupVersionKindFor.mock
}

// When sets expectation for the KubernetesClient.GroupVersionKindFor which will trigger the result defined by the following
// Then helper
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) When(obj runtime.Object) *KubernetesClientMockGroupVersionKindForExpectation {
	if mmGroupVersionKindFor.mock.funcGroupVersionKindFor != nil {
		mmGroupVersionKindFor.mock.t.Fatalf("KubernetesClientMock.GroupVersionKindFor mock is already set by Set")
	}

	expectation := &KubernetesClientMockGroupVersionKindForExpectation{
		mock:               mmGroupVersionKindFor.mock,
		params:             &KubernetesClientMockGroupVersionKindForParams{obj},
		expectationOrigins: KubernetesClientMockGroupVersionKindForExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGroupVersionKindFor.expectations = append(mmGroupVersionKindFor.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.GroupVersionKindFor return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockGroupVersionKindForExpectation) Then(g1 schema.GroupVersionKind, err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockGroupVersionKindForResults{g1, err}
	return e.mock
}

// Times sets number of times KubernetesClient.GroupVersionKindFor should be invoked
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) Times(n uint64) *mKubernetesClientMockGroupVersionKindFor {
	if n == 0 {
		mmGroupVersionKindFor.mock.t.Fatalf("Times of KubernetesClientMock.GroupVersionKindFor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGroupVersionKindFor.expectedInvocations, n)
	mmGroupVersionKindFor.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGroupVersionKindFor
}

func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) invocationsDone() bool {
	if len(mmGroupVersionKindFor.expectations) == 0 && mmGroupVersionKindFor.defaultExpectation == nil && mmGroupVersionKindFor.mock.funcGroupVersionKindFor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGroupVersionKindFor.mock.afterGroupVersionKindForCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGroupVersionKindFor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GroupVersionKindFor implements mm_pkg.KubernetesClient
func (mmGroupVersionKindFor *KubernetesClientMock) GroupVersionKindFor(obj runtime.Object) (g1 schema.GroupVersionKind, err error) {
	mm_atomic.AddUint64(&mmGroupVersionKindFor.beforeGroupVersionKindForCounter, 1)
	defer mm_atomic.AddUint64(&mmGroupVersionKindFor.afterGroupVersionKindForCounter, 1)

	mmGroupVersionKindFor.t.Helper()

	if mmGroupVersionKindFor.inspectFuncGroupVersionKindFor != nil {
		mmGroupVersionKindFor.inspectFuncGroupVersionKindFor(obj)
	}

	mm_params := KubernetesClientMockGroupVersionKindForParams{obj}

	// Record call args
	mmGroupVersionKindFor.GroupVersionKindForMock.mutex.Lock()
	mmGroupVersionKindFor.GroupVersionKindForMock.callArgs = append(mmGroupVersionKindFor.GroupVersionKindForMock.callArgs, &mm_params)
	mmGroupVersionKindFor.GroupVersionKindForMock.mutex.Unlock()

	for _, e := range mmGroupVersionKindFor.GroupVersionKindForMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1, e.results.err
		}
	}

	if mmGroupVersionKindFor.GroupVersionKindForMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGroupVersionKindFor.GroupVersionKindForMock.defaultExpectation.Counter, 1)
		mm_want := mmGroupVersionKindFor.GroupVersionKindForMock.defaultExpectation.params
		mm_want_ptrs := mmGroupVersionKindFor.GroupVersionKindForMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockGroupVersionKindForParams{obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmGroupVersionKindFor.t.Errorf("KubernetesClientMock.GroupVersionKindFor got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGroupVersionKindFor.GroupVersionKindForMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGroupVersionKindFor.t.Errorf("KubernetesClientMock.GroupVersionKindFor got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGroupVersionKindFor.GroupVersionKindForMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGroupVersionKindFor.GroupVersionKindForMock.defaultExpectation.results
		if mm_results == nil {
			mmGroupVersionKindFor.t.Fatal("No results are set for the KubernetesClientMock.GroupVersionKindFor")
		}
		return (*mm_results).g1, (*mm_results).err
	}
	if mmGroupVersionKindFor.funcGroupVersionKindFor != nil {
		return mmGroupVersionKindFor.funcGroupVersionKindFor(obj)
	}
	mmGroupVersionKindFor.t.Fatalf("Unexpected call to KubernetesClientMock.GroupVersionKindFor. %v", obj)
	return
}

// GroupVersionKindForAfterCounter returns a count of finished KubernetesClientMock.GroupVersionKindFor invocations
func (mmGroupVersionKindFor *KubernetesClientMock) GroupVersionKindForAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGroupVersionKindFor.afterGroupVersionKindForCounter)
}

// GroupVersionKindForBeforeCounter returns a count of KubernetesClientMock.GroupVersionKindFor invocations
func (mmGroupVersionKindFor *KubernetesClientMock) GroupVersionKindForBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGroupVersionKindFor.beforeGroupVersionKindForCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.GroupVersionKindFor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGroupVersionKindFor *mKubernetesClientMockGroupVersionKindFor) Calls() []*KubernetesClientMockGroupVersionKindForParams {
	mmGroupVersionKindFor.mutex.RLock()

	argCopy := make([]*KubernetesClientMockGroupVersionKindForParams, len(mmGroupVersionKindFor.callArgs))
	copy(argCopy, mmGroupVersionKindFor.callArgs)

	mmGroupVersionKindFor.mutex.RUnlock()

	return argCopy
}

// MinimockGroupVersionKindForDone returns true if the count of the GroupVersionKindFor invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockGroupVersionKindForDone() bool {
	if m.GroupVersionKindForMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GroupVersionKindForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GroupVersionKindForMock.invocationsDone()
}

// MinimockGroupVersionKindForInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockGroupVersionKindForInspect() {
	for _, e := range m.GroupVersionKindForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.GroupVersionKindFor at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGroupVersionKindForCounter := mm_atomic.LoadUint64(&m.afterGroupVersionKindForCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GroupVersionKindForMock.defaultExpectation != nil && afterGroupVersionKindForCounter < 1 {
		if m.GroupVersionKindForMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.GroupVersionKindFor at\n%s", m.GroupVersionKindForMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.GroupVersionKindFor at\n%s with params: %#v", m.GroupVersionKindForMock.defaultExpectation.expectationOrigins.origin, *m.GroupVersionKindForMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGroupVersionKindFor != nil && afterGroupVersionKindForCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.GroupVersionKindFor at\n%s", m.funcGroupVersionKindForOrigin)
	}

	if !m.GroupVersionKindForMock.invocationsDone() && afterGroupVersionKindForCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.GroupVersionKindFor at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GroupVersionKindForMock.expectedInvocations), m.GroupVersionKindForMock.expectedInvocationsOrigin, afterGroupVersionKindForCounter)
	}
}

type mKubernetesClientMockIsObjectNamespaced struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockIsObjectNamespacedExpectation
	expectations       []*KubernetesClientMockIsObjectNamespacedExpectation

	callArgs []*KubernetesClientMockIsObjectNamespacedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockIsObjectNamespacedExpectation specifies expectation struct of the KubernetesClient.IsObjectNamespaced
type KubernetesClientMockIsObjectNamespacedExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockIsObjectNamespacedParams
	paramPtrs          *KubernetesClientMockIsObjectNamespacedParamPtrs
	expectationOrigins KubernetesClientMockIsObjectNamespacedExpectationOrigins
	results            *KubernetesClientMockIsObjectNamespacedResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockIsObjectNamespacedParams contains parameters of the KubernetesClient.IsObjectNamespaced
type KubernetesClientMockIsObjectNamespacedParams struct {
	obj runtime.Object
}

// KubernetesClientMockIsObjectNamespacedParamPtrs contains pointers to parameters of the KubernetesClient.IsObjectNamespaced
type KubernetesClientMockIsObjectNamespacedParamPtrs struct {
	obj *runtime.Object
}

// KubernetesClientMockIsObjectNamespacedResults contains results of the KubernetesClient.IsObjectNamespaced
type KubernetesClientMockIsObjectNamespacedResults struct {
	b1  bool
	err error
}

// KubernetesClientMockIsObjectNamespacedOrigins contains origins of expectations of the KubernetesClient.IsObjectNamespaced
type KubernetesClientMockIsObjectNamespacedExpectationOrigins struct {
	origin    string
	originObj string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) Optional() *mKubernetesClientMockIsObjectNamespaced {
	mmIsObjectNamespaced.optional = true
	return mmIsObjectNamespaced
}

// Expect sets up expected params for KubernetesClient.IsObjectNamespaced
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) Expect(obj runtime.Object) *mKubernetesClientMockIsObjectNamespaced {
	if mmIsObjectNamespaced.mock.funcIsObjectNamespaced != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("KubernetesClientMock.IsObjectNamespaced mock is already set by Set")
	}

	if mmIsObjectNamespaced.defaultExpectation == nil {
		mmIsObjectNamespaced.defaultExpectation = &KubernetesClientMockIsObjectNamespacedExpectation{}
	}

	if mmIsObjectNamespaced.defaultExpectation.paramPtrs != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("KubernetesClientMock.IsObjectNamespaced mock is already set by ExpectParams functions")
	}

	mmIsObjectNamespaced.defaultExpectation.params = &KubernetesClientMockIsObjectNamespacedParams{obj}
	mmIsObjectNamespaced.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsObjectNamespaced.expectations {
		if minimock.Equal(e.params, mmIsObjectNamespaced.defaultExpectation.params) {
			mmIsObjectNamespaced.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsObjectNamespaced.defaultExpectation.params)
		}
	}

	return mmIsObjectNamespaced
}

// ExpectObjParam1 sets up expected param obj for KubernetesClient.IsObjectNamespaced
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) ExpectObjParam1(obj runtime.Object) *mKubernetesClientMockIsObjectNamespaced {
	if mmIsObjectNamespaced.mock.funcIsObjectNamespaced != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("KubernetesClientMock.IsObjectNamespaced mock is already set by Set")
	}

	if mmIsObjectNamespaced.defaultExpectation == nil {
		mmIsObjectNamespaced.defaultExpectation = &KubernetesClientMockIsObjectNamespacedExpectation{}
	}

	if mmIsObjectNamespaced.defaultExpectation.params != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("KubernetesClientMock.IsObjectNamespaced mock is already set by Expect")
	}

	if mmIsObjectNamespaced.defaultExpectation.paramPtrs == nil {
		mmIsObjectNamespaced.defaultExpectation.paramPtrs = &KubernetesClientMockIsObjectNamespacedParamPtrs{}
	}
	mmIsObjectNamespaced.defaultExpectation.paramPtrs.obj = &obj
	mmIsObjectNamespaced.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmIsObjectNamespaced
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.IsObjectNamespaced
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) Inspect(f func(obj runtime.Object)) *mKubernetesClientMockIsObjectNamespaced {
	if mmIsObjectNamespaced.mock.inspectFuncIsObjectNamespaced != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.IsObjectNamespaced")
	}

	mmIsObjectNamespaced.mock.inspectFuncIsObjectNamespaced = f

	return mmIsObjectNamespaced
}

// Return sets up results that will be returned by KubernetesClient.IsObjectNamespaced
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) Return(b1 bool, err error) *KubernetesClientMock {
	if mmIsObjectNamespaced.mock.funcIsObjectNamespaced != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("KubernetesClientMock.IsObjectNamespaced mock is already set by Set")
	}

	if mmIsObjectNamespaced.defaultExpectation == nil {
		mmIsObjectNamespaced.defaultExpectation = &KubernetesClientMockIsObjectNamespacedExpectation{mock: mmIsObjectNamespaced.mock}
	}
	mmIsObjectNamespaced.defaultExpectation.results = &KubernetesClientMockIsObjectNamespacedResults{b1, err}
	mmIsObjectNamespaced.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsObjectNamespaced.mock
}

// Set uses given function f to mock the KubernetesClient.IsObjectNamespaced method
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) Set(f func(obj runtime.Object) (b1 bool, err error)) *KubernetesClientMock {
	if mmIsObjectNamespaced.defaultExpectation != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.IsObjectNamespaced method")
	}

	if len(mmIsObjectNamespaced.expectations) > 0 {
		mmIsObjectNamespaced.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.IsObjectNamespaced method")
	}

	mmIsObjectNamespaced.mock.funcIsObjectNamespaced = f
	mmIsObjectNamespaced.mock.funcIsObjectNamespacedOrigin = minimock.CallerInfo(1)
	return mmIsObjectNamespaced.mock
}

// When sets expectation for the KubernetesClient.IsObjectNamespaced which will trigger the result defined by the following
// Then helper
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) When(obj runtime.Object) *KubernetesClientMockIsObjectNamespacedExpectation {
	if mmIsObjectNamespaced.mock.funcIsObjectNamespaced != nil {
		mmIsObjectNamespaced.mock.t.Fatalf("KubernetesClientMock.IsObjectNamespaced mock is already set by Set")
	}

	expectation := &KubernetesClientMockIsObjectNamespacedExpectation{
		mock:               mmIsObjectNamespaced.mock,
		params:             &KubernetesClientMockIsObjectNamespacedParams{obj},
		expectationOrigins: KubernetesClientMockIsObjectNamespacedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsObjectNamespaced.expectations = append(mmIsObjectNamespaced.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.IsObjectNamespaced return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockIsObjectNamespacedExpectation) Then(b1 bool, err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockIsObjectNamespacedResults{b1, err}
	return e.mock
}

// Times sets number of times KubernetesClient.IsObjectNamespaced should be invoked
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) Times(n uint64) *mKubernetesClientMockIsObjectNamespaced {
	if n == 0 {
		mmIsObjectNamespaced.mock.t.Fatalf("Times of KubernetesClientMock.IsObjectNamespaced mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsObjectNamespaced.expectedInvocations, n)
	mmIsObjectNamespaced.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsObjectNamespaced
}

func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) invocationsDone() bool {
	if len(mmIsObjectNamespaced.expectations) == 0 && mmIsObjectNamespaced.defaultExpectation == nil && mmIsObjectNamespaced.mock.funcIsObjectNamespaced == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsObjectNamespaced.mock.afterIsObjectNamespacedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsObjectNamespaced.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsObjectNamespaced implements mm_pkg.KubernetesClient
func (mmIsObjectNamespaced *KubernetesClientMock) IsObjectNamespaced(obj runtime.Object) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsObjectNamespaced.beforeIsObjectNamespacedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsObjectNamespaced.afterIsObjectNamespacedCounter, 1)

	mmIsObjectNamespaced.t.Helper()

	if mmIsObjectNamespaced.inspectFuncIsObjectNamespaced != nil {
		mmIsObjectNamespaced.inspectFuncIsObjectNamespaced(obj)
	}

	mm_params := KubernetesClientMockIsObjectNamespacedParams{obj}

	// Record call args
	mmIsObjectNamespaced.IsObjectNamespacedMock.mutex.Lock()
	mmIsObjectNamespaced.IsObjectNamespacedMock.callArgs = append(mmIsObjectNamespaced.IsObjectNamespacedMock.callArgs, &mm_params)
	mmIsObjectNamespaced.IsObjectNamespacedMock.mutex.Unlock()

	for _, e := range mmIsObjectNamespaced.IsObjectNamespacedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsObjectNamespaced.IsObjectNamespacedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsObjectNamespaced.IsObjectNamespacedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsObjectNamespaced.IsObjectNamespacedMock.defaultExpectation.params
		mm_want_ptrs := mmIsObjectNamespaced.IsObjectNamespacedMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockIsObjectNamespacedParams{obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmIsObjectNamespaced.t.Errorf("KubernetesClientMock.IsObjectNamespaced got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsObjectNamespaced.IsObjectNamespacedMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsObjectNamespaced.t.Errorf("KubernetesClientMock.IsObjectNamespaced got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsObjectNamespaced.IsObjectNamespacedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsObjectNamespaced.IsObjectNamespacedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsObjectNamespaced.t.Fatal("No results are set for the KubernetesClientMock.IsObjectNamespaced")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsObjectNamespaced.funcIsObjectNamespaced != nil {
		return mmIsObjectNamespaced.funcIsObjectNamespaced(obj)
	}
	mmIsObjectNamespaced.t.Fatalf("Unexpected call to KubernetesClientMock.IsObjectNamespaced. %v", obj)
	return
}

// IsObjectNamespacedAfterCounter returns a count of finished KubernetesClientMock.IsObjectNamespaced invocations
func (mmIsObjectNamespaced *KubernetesClientMock) IsObjectNamespacedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsObjectNamespaced.afterIsObjectNamespacedCounter)
}

// IsObjectNamespacedBeforeCounter returns a count of KubernetesClientMock.IsObjectNamespaced invocations
func (mmIsObjectNamespaced *KubernetesClientMock) IsObjectNamespacedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsObjectNamespaced.beforeIsObjectNamespacedCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.IsObjectNamespaced.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsObjectNamespaced *mKubernetesClientMockIsObjectNamespaced) Calls() []*KubernetesClientMockIsObjectNamespacedParams {
	mmIsObjectNamespaced.mutex.RLock()

	argCopy := make([]*KubernetesClientMockIsObjectNamespacedParams, len(mmIsObjectNamespaced.callArgs))
	copy(argCopy, mmIsObjectNamespaced.callArgs)

	mmIsObjectNamespaced.mutex.RUnlock()

	return argCopy
}

// MinimockIsObjectNamespacedDone returns true if the count of the IsObjectNamespaced invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockIsObjectNamespacedDone() bool {
	if m.IsObjectNamespacedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsObjectNamespacedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsObjectNamespacedMock.invocationsDone()
}

// MinimockIsObjectNamespacedInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockIsObjectNamespacedInspect() {
	for _, e := range m.IsObjectNamespacedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.IsObjectNamespaced at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsObjectNamespacedCounter := mm_atomic.LoadUint64(&m.afterIsObjectNamespacedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsObjectNamespacedMock.defaultExpectation != nil && afterIsObjectNamespacedCounter < 1 {
		if m.IsObjectNamespacedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.IsObjectNamespaced at\n%s", m.IsObjectNamespacedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.IsObjectNamespaced at\n%s with params: %#v", m.IsObjectNamespacedMock.defaultExpectation.expectationOrigins.origin, *m.IsObjectNamespacedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsObjectNamespaced != nil && afterIsObjectNamespacedCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.IsObjectNamespaced at\n%s", m.funcIsObjectNamespacedOrigin)
	}

	if !m.IsObjectNamespacedMock.invocationsDone() && afterIsObjectNamespacedCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.IsObjectNamespaced at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsObjectNamespacedMock.expectedInvocations), m.IsObjectNamespacedMock.expectedInvocationsOrigin, afterIsObjectNamespacedCounter)
	}
}

type mKubernetesClientMockList struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockListExpectation
	expectations       []*KubernetesClientMockListExpectation

	callArgs []*KubernetesClientMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockListExpectation specifies expectation struct of the KubernetesClient.List
type KubernetesClientMockListExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockListParams
	paramPtrs          *KubernetesClientMockListParamPtrs
	expectationOrigins KubernetesClientMockListExpectationOrigins
	results            *KubernetesClientMockListResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockListParams contains parameters of the KubernetesClient.List
type KubernetesClientMockListParams struct {
	ctx  context.Context
	list client.ObjectList
	opts []client.ListOption
}

// KubernetesClientMockListParamPtrs contains pointers to parameters of the KubernetesClient.List
type KubernetesClientMockListParamPtrs struct {
	ctx  *context.Context
	list *client.ObjectList
	opts *[]client.ListOption
}

// KubernetesClientMockListResults contains results of the KubernetesClient.List
type KubernetesClientMockListResults struct {
	err error
}

// KubernetesClientMockListOrigins contains origins of expectations of the KubernetesClient.List
type KubernetesClientMockListExpectationOrigins struct {
	origin     string
	originCtx  string
	originList string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mKubernetesClientMockList) Optional() *mKubernetesClientMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for KubernetesClient.List
func (mmList *mKubernetesClientMockList) Expect(ctx context.Context, list client.ObjectList, opts ...client.ListOption) *mKubernetesClientMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesClientMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &KubernetesClientMockListParams{ctx, list, opts}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.List
func (mmList *mKubernetesClientMockList) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesClientMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &KubernetesClientMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectListParam2 sets up expected param list for KubernetesClient.List
func (mmList *mKubernetesClientMockList) ExpectListParam2(list client.ObjectList) *mKubernetesClientMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesClientMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &KubernetesClientMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.list = &list
	mmList.defaultExpectation.expectationOrigins.originList = minimock.CallerInfo(1)

	return mmList
}

// ExpectOptsParam3 sets up expected param opts for KubernetesClient.List
func (mmList *mKubernetesClientMockList) ExpectOptsParam3(opts ...client.ListOption) *mKubernetesClientMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesClientMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &KubernetesClientMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.opts = &opts
	mmList.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.List
func (mmList *mKubernetesClientMockList) Inspect(f func(ctx context.Context, list client.ObjectList, opts ...client.ListOption)) *mKubernetesClientMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by KubernetesClient.List
func (mmList *mKubernetesClientMockList) Return(err error) *KubernetesClientMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesClientMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &KubernetesClientMockListResults{err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the KubernetesClient.List method
func (mmList *mKubernetesClientMockList) Set(f func(ctx context.Context, list client.ObjectList, opts ...client.ListOption) (err error)) *KubernetesClientMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the KubernetesClient.List which will trigger the result defined by the following
// Then helper
func (mmList *mKubernetesClientMockList) When(ctx context.Context, list client.ObjectList, opts ...client.ListOption) *KubernetesClientMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesClientMock.List mock is already set by Set")
	}

	expectation := &KubernetesClientMockListExpectation{
		mock:               mmList.mock,
		params:             &KubernetesClientMockListParams{ctx, list, opts},
		expectationOrigins: KubernetesClientMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.List return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockListExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockListResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.List should be invoked
func (mmList *mKubernetesClientMockList) Times(n uint64) *mKubernetesClientMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of KubernetesClientMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mKubernetesClientMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_pkg.KubernetesClient
func (mmList *KubernetesClientMock) List(ctx context.Context, list client.ObjectList, opts ...client.ListOption) (err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, list, opts...)
	}

	mm_params := KubernetesClientMockListParams{ctx, list, opts}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockListParams{ctx, list, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("KubernetesClientMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.list != nil && !minimock.Equal(*mm_want_ptrs.list, mm_got.list) {
				mmList.t.Errorf("KubernetesClientMock.List got unexpected parameter list, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originList, *mm_want_ptrs.list, mm_got.list, minimock.Diff(*mm_want_ptrs.list, mm_got.list))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmList.t.Errorf("KubernetesClientMock.List got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("KubernetesClientMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the KubernetesClientMock.List")
		}
		return (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, list, opts...)
	}
	mmList.t.Fatalf("Unexpected call to KubernetesClientMock.List. %v %v %v", ctx, list, opts)
	return
}

// ListAfterCounter returns a count of finished KubernetesClientMock.List invocations
func (mmList *KubernetesClientMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of KubernetesClientMock.List invocations
func (mmList *KubernetesClientMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mKubernetesClientMockList) Calls() []*KubernetesClientMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*KubernetesClientMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mKubernetesClientMockPatch struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockPatchExpectation
	expectations       []*KubernetesClientMockPatchExpectation

	callArgs []*KubernetesClientMockPatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockPatchExpectation specifies expectation struct of the KubernetesClient.Patch
type KubernetesClientMockPatchExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockPatchParams
	paramPtrs          *KubernetesClientMockPatchParamPtrs
	expectationOrigins KubernetesClientMockPatchExpectationOrigins
	results            *KubernetesClientMockPatchResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockPatchParams contains parameters of the KubernetesClient.Patch
type KubernetesClientMockPatchParams struct {
	ctx   context.Context
	obj   client.Object
	patch client.Patch
	opts  []client.PatchOption
}

// KubernetesClientMockPatchParamPtrs contains pointers to parameters of the KubernetesClient.Patch
type KubernetesClientMockPatchParamPtrs struct {
	ctx   *context.Context
	obj   *client.Object
	patch *client.Patch
	opts  *[]client.PatchOption
}

// KubernetesClientMockPatchResults contains results of the KubernetesClient.Patch
type KubernetesClientMockPatchResults struct {
	err error
}

// KubernetesClientMockPatchOrigins contains origins of expectations of the KubernetesClient.Patch
type KubernetesClientMockPatchExpectationOrigins struct {
	origin      string
	originCtx   string
	originObj   string
	originPatch string
	originOpts  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatch *mKubernetesClientMockPatch) Optional() *mKubernetesClientMockPatch {
	mmPatch.optional = true
	return mmPatch
}

// Expect sets up expected params for KubernetesClient.Patch
func (mmPatch *mKubernetesClientMockPatch) Expect(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption) *mKubernetesClientMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesClientMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.paramPtrs != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by ExpectParams functions")
	}

	mmPatch.defaultExpectation.params = &KubernetesClientMockPatchParams{ctx, obj, patch, opts}
	mmPatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPatch.expectations {
		if minimock.Equal(e.params, mmPatch.defaultExpectation.params) {
			mmPatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatch.defaultExpectation.params)
		}
	}

	return mmPatch
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.Patch
func (mmPatch *mKubernetesClientMockPatch) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesClientMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesClientMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmPatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectObjParam2 sets up expected param obj for KubernetesClient.Patch
func (mmPatch *mKubernetesClientMockPatch) ExpectObjParam2(obj client.Object) *mKubernetesClientMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesClientMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesClientMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.obj = &obj
	mmPatch.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectPatchParam3 sets up expected param patch for KubernetesClient.Patch
func (mmPatch *mKubernetesClientMockPatch) ExpectPatchParam3(patch client.Patch) *mKubernetesClientMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesClientMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesClientMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.patch = &patch
	mmPatch.defaultExpectation.expectationOrigins.originPatch = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectOptsParam4 sets up expected param opts for KubernetesClient.Patch
func (mmPatch *mKubernetesClientMockPatch) ExpectOptsParam4(opts ...client.PatchOption) *mKubernetesClientMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesClientMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesClientMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.opts = &opts
	mmPatch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmPatch
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Patch
func (mmPatch *mKubernetesClientMockPatch) Inspect(f func(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption)) *mKubernetesClientMockPatch {
	if mmPatch.mock.inspectFuncPatch != nil {
		mmPatch.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Patch")
	}

	mmPatch.mock.inspectFuncPatch = f

	return mmPatch
}

// Return sets up results that will be returned by KubernetesClient.Patch
func (mmPatch *mKubernetesClientMockPatch) Return(err error) *KubernetesClientMock {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesClientMockPatchExpectation{mock: mmPatch.mock}
	}
	mmPatch.defaultExpectation.results = &KubernetesClientMockPatchResults{err}
	mmPatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// Set uses given function f to mock the KubernetesClient.Patch method
func (mmPatch *mKubernetesClientMockPatch) Set(f func(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption) (err error)) *KubernetesClientMock {
	if mmPatch.defaultExpectation != nil {
		mmPatch.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Patch method")
	}

	if len(mmPatch.expectations) > 0 {
		mmPatch.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Patch method")
	}

	mmPatch.mock.funcPatch = f
	mmPatch.mock.funcPatchOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// When sets expectation for the KubernetesClient.Patch which will trigger the result defined by the following
// Then helper
func (mmPatch *mKubernetesClientMockPatch) When(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption) *KubernetesClientMockPatchExpectation {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesClientMock.Patch mock is already set by Set")
	}

	expectation := &KubernetesClientMockPatchExpectation{
		mock:               mmPatch.mock,
		params:             &KubernetesClientMockPatchParams{ctx, obj, patch, opts},
		expectationOrigins: KubernetesClientMockPatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPatch.expectations = append(mmPatch.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.Patch return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockPatchExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockPatchResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.Patch should be invoked
func (mmPatch *mKubernetesClientMockPatch) Times(n uint64) *mKubernetesClientMockPatch {
	if n == 0 {
		mmPatch.mock.t.Fatalf("Times of KubernetesClientMock.Patch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPatch.expectedInvocations, n)
	mmPatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPatch
}

func (mmPatch *mKubernetesClientMockPatch) invocationsDone() bool {
	if len(mmPatch.expectations) == 0 && mmPatch.defaultExpectation == nil && mmPatch.mock.funcPatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPatch.mock.afterPatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Patch implements mm_pkg.KubernetesClient
func (mmPatch *KubernetesClientMock) Patch(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption) (err error) {
	mm_atomic.AddUint64(&mmPatch.beforePatchCounter, 1)
	defer mm_atomic.AddUint64(&mmPatch.afterPatchCounter, 1)

	mmPatch.t.Helper()

	if mmPatch.inspectFuncPatch != nil {
		mmPatch.inspectFuncPatch(ctx, obj, patch, opts...)
	}

	mm_params := KubernetesClientMockPatchParams{ctx, obj, patch, opts}

	// Record call args
	mmPatch.PatchMock.mutex.Lock()
	mmPatch.PatchMock.callArgs = append(mmPatch.PatchMock.callArgs, &mm_params)
	mmPatch.PatchMock.mutex.Unlock()

	for _, e := range mmPatch.PatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPatch.PatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatch.PatchMock.defaultExpectation.Counter, 1)
		mm_want := mmPatch.PatchMock.defaultExpectation.params
		mm_want_ptrs := mmPatch.PatchMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockPatchParams{ctx, obj, patch, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPatch.t.Errorf("KubernetesClientMock.Patch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmPatch.t.Errorf("KubernetesClientMock.Patch got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.patch != nil && !minimock.Equal(*mm_want_ptrs.patch, mm_got.patch) {
				mmPatch.t.Errorf("KubernetesClientMock.Patch got unexpected parameter patch, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originPatch, *mm_want_ptrs.patch, mm_got.patch, minimock.Diff(*mm_want_ptrs.patch, mm_got.patch))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmPatch.t.Errorf("KubernetesClientMock.Patch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatch.t.Errorf("KubernetesClientMock.Patch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPatch.PatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatch.PatchMock.defaultExpectation.results
		if mm_results == nil {
			mmPatch.t.Fatal("No results are set for the KubernetesClientMock.Patch")
		}
		return (*mm_results).err
	}
	if mmPatch.funcPatch != nil {
		return mmPatch.funcPatch(ctx, obj, patch, opts...)
	}
	mmPatch.t.Fatalf("Unexpected call to KubernetesClientMock.Patch. %v %v %v %v", ctx, obj, patch, opts)
	return
}

// PatchAfterCounter returns a count of finished KubernetesClientMock.Patch invocations
func (mmPatch *KubernetesClientMock) PatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.afterPatchCounter)
}

// PatchBeforeCounter returns a count of KubernetesClientMock.Patch invocations
func (mmPatch *KubernetesClientMock) PatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.beforePatchCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.Patch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatch *mKubernetesClientMockPatch) Calls() []*KubernetesClientMockPatchParams {
	mmPatch.mutex.RLock()

	argCopy := make([]*KubernetesClientMockPatchParams, len(mmPatch.callArgs))
	copy(argCopy, mmPatch.callArgs)

	mmPatch.mutex.RUnlock()

	return argCopy
}

// MinimockPatchDone returns true if the count of the Patch invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockPatchDone() bool {
	if m.PatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PatchMock.invocationsDone()
}

// MinimockPatchInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockPatchInspect() {
	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.Patch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPatchCounter := mm_atomic.LoadUint64(&m.afterPatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PatchMock.defaultExpectation != nil && afterPatchCounter < 1 {
		if m.PatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.Patch at\n%s", m.PatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.Patch at\n%s with params: %#v", m.PatchMock.defaultExpectation.expectationOrigins.origin, *m.PatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatch != nil && afterPatchCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Patch at\n%s", m.funcPatchOrigin)
	}

	if !m.PatchMock.invocationsDone() && afterPatchCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Patch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PatchMock.expectedInvocations), m.PatchMock.expectedInvocationsOrigin, afterPatchCounter)
	}
}

type mKubernetesClientMockRESTMapper struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockRESTMapperExpectation
	expectations       []*KubernetesClientMockRESTMapperExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockRESTMapperExpectation specifies expectation struct of the KubernetesClient.RESTMapper
type KubernetesClientMockRESTMapperExpectation struct {
	mock *KubernetesClientMock

	results      *KubernetesClientMockRESTMapperResults
	returnOrigin string
	Counter      uint64
}

// KubernetesClientMockRESTMapperResults contains results of the KubernetesClient.RESTMapper
type KubernetesClientMockRESTMapperResults struct {
	r1 meta.RESTMapper
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRESTMapper *mKubernetesClientMockRESTMapper) Optional() *mKubernetesClientMockRESTMapper {
	mmRESTMapper.optional = true
	return mmRESTMapper
}

// Expect sets up expected params for KubernetesClient.RESTMapper
func (mmRESTMapper *mKubernetesClientMockRESTMapper) Expect() *mKubernetesClientMockRESTMapper {
	if mmRESTMapper.mock.funcRESTMapper != nil {
		mmRESTMapper.mock.t.Fatalf("KubernetesClientMock.RESTMapper mock is already set by Set")
	}

	if mmRESTMapper.defaultExpectation == nil {
		mmRESTMapper.defaultExpectation = &KubernetesClientMockRESTMapperExpectation{}
	}

	return mmRESTMapper
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.RESTMapper
func (mmRESTMapper *mKubernetesClientMockRESTMapper) Inspect(f func()) *mKubernetesClientMockRESTMapper {
	if mmRESTMapper.mock.inspectFuncRESTMapper != nil {
		mmRESTMapper.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.RESTMapper")
	}

	mmRESTMapper.mock.inspectFuncRESTMapper = f

	return mmRESTMapper
}

// Return sets up results that will be returned by KubernetesClient.RESTMapper
func (mmRESTMapper *mKubernetesClientMockRESTMapper) Return(r1 meta.RESTMapper) *KubernetesClientMock {
	if mmRESTMapper.mock.funcRESTMapper != nil {
		mmRESTMapper.mock.t.Fatalf("KubernetesClientMock.RESTMapper mock is already set by Set")
	}

	if mmRESTMapper.defaultExpectation == nil {
		mmRESTMapper.defaultExpectation = &KubernetesClientMockRESTMapperExpectation{mock: mmRESTMapper.mock}
	}
	mmRESTMapper.defaultExpectation.results = &KubernetesClientMockRESTMapperResults{r1}
	mmRESTMapper.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRESTMapper.mock
}

// Set uses given function f to mock the KubernetesClient.RESTMapper method
func (mmRESTMapper *mKubernetesClientMockRESTMapper) Set(f func() (r1 meta.RESTMapper)) *KubernetesClientMock {
	if mmRESTMapper.defaultExpectation != nil {
		mmRESTMapper.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.RESTMapper method")
	}

	if len(mmRESTMapper.expectations) > 0 {
		mmRESTMapper.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.RESTMapper method")
	}

	mmRESTMapper.mock.funcRESTMapper = f
	mmRESTMapper.mock.funcRESTMapperOrigin = minimock.CallerInfo(1)
	return mmRESTMapper.mock
}

// Times sets number of times KubernetesClient.RESTMapper should be invoked
func (mmRESTMapper *mKubernetesClientMockRESTMapper) Times(n uint64) *mKubernetesClientMockRESTMapper {
	if n == 0 {
		mmRESTMapper.mock.t.Fatalf("Times of KubernetesClientMock.RESTMapper mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRESTMapper.expectedInvocations, n)
	mmRESTMapper.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRESTMapper
}

func (mmRESTMapper *mKubernetesClientMockRESTMapper) invocationsDone() bool {
	if len(mmRESTMapper.expectations) == 0 && mmRESTMapper.defaultExpectation == nil && mmRESTMapper.mock.funcRESTMapper == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRESTMapper.mock.afterRESTMapperCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRESTMapper.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RESTMapper implements mm_pkg.KubernetesClient
func (mmRESTMapper *KubernetesClientMock) RESTMapper() (r1 meta.RESTMapper) {
	mm_atomic.AddUint64(&mmRESTMapper.beforeRESTMapperCounter, 1)
	defer mm_atomic.AddUint64(&mmRESTMapper.afterRESTMapperCounter, 1)

	mmRESTMapper.t.Helper()

	if mmRESTMapper.inspectFuncRESTMapper != nil {
		mmRESTMapper.inspectFuncRESTMapper()
	}

	if mmRESTMapper.RESTMapperMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRESTMapper.RESTMapperMock.defaultExpectation.Counter, 1)

		mm_results := mmRESTMapper.RESTMapperMock.defaultExpectation.results
		if mm_results == nil {
			mmRESTMapper.t.Fatal("No results are set for the KubernetesClientMock.RESTMapper")
		}
		return (*mm_results).r1
	}
	if mmRESTMapper.funcRESTMapper != nil {
		return mmRESTMapper.funcRESTMapper()
	}
	mmRESTMapper.t.Fatalf("Unexpected call to KubernetesClientMock.RESTMapper.")
	return
}

// RESTMapperAfterCounter returns a count of finished KubernetesClientMock.RESTMapper invocations
func (mmRESTMapper *KubernetesClientMock) RESTMapperAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRESTMapper.afterRESTMapperCounter)
}

// RESTMapperBeforeCounter returns a count of KubernetesClientMock.RESTMapper invocations
func (mmRESTMapper *KubernetesClientMock) RESTMapperBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRESTMapper.beforeRESTMapperCounter)
}

// MinimockRESTMapperDone returns true if the count of the RESTMapper invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockRESTMapperDone() bool {
	if m.RESTMapperMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RESTMapperMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RESTMapperMock.invocationsDone()
}

// MinimockRESTMapperInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockRESTMapperInspect() {
	for _, e := range m.RESTMapperMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to KubernetesClientMock.RESTMapper")
		}
	}

	afterRESTMapperCounter := mm_atomic.LoadUint64(&m.afterRESTMapperCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RESTMapperMock.defaultExpectation != nil && afterRESTMapperCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.RESTMapper at\n%s", m.RESTMapperMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRESTMapper != nil && afterRESTMapperCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.RESTMapper at\n%s", m.funcRESTMapperOrigin)
	}

	if !m.RESTMapperMock.invocationsDone() && afterRESTMapperCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.RESTMapper at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RESTMapperMock.expectedInvocations), m.RESTMapperMock.expectedInvocationsOrigin, afterRESTMapperCounter)
	}
}

type mKubernetesClientMockScheme struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockSchemeExpectation
	expectations       []*KubernetesClientMockSchemeExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockSchemeExpectation specifies expectation struct of the KubernetesClient.Scheme
type KubernetesClientMockSchemeExpectation struct {
	mock *KubernetesClientMock

	results      *KubernetesClientMockSchemeResults
	returnOrigin string
	Counter      uint64
}

// KubernetesClientMockSchemeResults contains results of the KubernetesClient.Scheme
type KubernetesClientMockSchemeResults struct {
	sp1 *runtime.Scheme
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScheme *mKubernetesClientMockScheme) Optional() *mKubernetesClientMockScheme {
	mmScheme.optional = true
	return mmScheme
}

// Expect sets up expected params for KubernetesClient.Scheme
func (mmScheme *mKubernetesClientMockScheme) Expect() *mKubernetesClientMockScheme {
	if mmScheme.mock.funcScheme != nil {
		mmScheme.mock.t.Fatalf("KubernetesClientMock.Scheme mock is already set by Set")
	}

	if mmScheme.defaultExpectation == nil {
		mmScheme.defaultExpectation = &KubernetesClientMockSchemeExpectation{}
	}

	return mmScheme
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Scheme
func (mmScheme *mKubernetesClientMockScheme) Inspect(f func()) *mKubernetesClientMockScheme {
	if mmScheme.mock.inspectFuncScheme != nil {
		mmScheme.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Scheme")
	}

	mmScheme.mock.inspectFuncScheme = f

	return mmScheme
}

// Return sets up results that will be returned by KubernetesClient.Scheme
func (mmScheme *mKubernetesClientMockScheme) Return(sp1 *runtime.Scheme) *KubernetesClientMock {
	if mmScheme.mock.funcScheme != nil {
		mmScheme.mock.t.Fatalf("KubernetesClientMock.Scheme mock is already set by Set")
	}

	if mmScheme.defaultExpectation == nil {
		mmScheme.defaultExpectation = &KubernetesClientMockSchemeExpectation{mock: mmScheme.mock}
	}
	mmScheme.defaultExpectation.results = &KubernetesClientMockSchemeResults{sp1}
	mmScheme.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScheme.mock
}

// Set uses given function f to mock the KubernetesClient.Scheme method
func (mmScheme *mKubernetesClientMockScheme) Set(f func() (sp1 *runtime.Scheme)) *KubernetesClientMock {
	if mmScheme.defaultExpectation != nil {
		mmScheme.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Scheme method")
	}

	if len(mmScheme.expectations) > 0 {
		mmScheme.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Scheme method")
	}

	mmScheme.mock.funcScheme = f
	mmScheme.mock.funcSchemeOrigin = minimock.CallerInfo(1)
	return mmScheme.mock
}

// Times sets number of times KubernetesClient.Scheme should be invoked
func (mmScheme *mKubernetesClientMockScheme) Times(n uint64) *mKubernetesClientMockScheme {
	if n == 0 {
		mmScheme.mock.t.Fatalf("Times of KubernetesClientMock.Scheme mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScheme.expectedInvocations, n)
	mmScheme.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScheme
}

func (mmScheme *mKubernetesClientMockScheme) invocationsDone() bool {
	if len(mmScheme.expectations) == 0 && mmScheme.defaultExpectation == nil && mmScheme.mock.funcScheme == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScheme.mock.afterSchemeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScheme.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Scheme implements mm_pkg.KubernetesClient
func (mmScheme *KubernetesClientMock) Scheme() (sp1 *runtime.Scheme) {
	mm_atomic.AddUint64(&mmScheme.beforeSchemeCounter, 1)
	defer mm_atomic.AddUint64(&mmScheme.afterSchemeCounter, 1)

	mmScheme.t.Helper()

	if mmScheme.inspectFuncScheme != nil {
		mmScheme.inspectFuncScheme()
	}

	if mmScheme.SchemeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScheme.SchemeMock.defaultExpectation.Counter, 1)

		mm_results := mmScheme.SchemeMock.defaultExpectation.results
		if mm_results == nil {
			mmScheme.t.Fatal("No results are set for the KubernetesClientMock.Scheme")
		}
		return (*mm_results).sp1
	}
	if mmScheme.funcScheme != nil {
		return mmScheme.funcScheme()
	}
	mmScheme.t.Fatalf("Unexpected call to KubernetesClientMock.Scheme.")
	return
}

// SchemeAfterCounter returns a count of finished KubernetesClientMock.Scheme invocations
func (mmScheme *KubernetesClientMock) SchemeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScheme.afterSchemeCounter)
}

// SchemeBeforeCounter returns a count of KubernetesClientMock.Scheme invocations
func (mmScheme *KubernetesClientMock) SchemeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScheme.beforeSchemeCounter)
}

// MinimockSchemeDone returns true if the count of the Scheme invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockSchemeDone() bool {
	if m.SchemeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SchemeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SchemeMock.invocationsDone()
}

// MinimockSchemeInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockSchemeInspect() {
	for _, e := range m.SchemeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to KubernetesClientMock.Scheme")
		}
	}

	afterSchemeCounter := mm_atomic.LoadUint64(&m.afterSchemeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SchemeMock.defaultExpectation != nil && afterSchemeCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Scheme at\n%s", m.SchemeMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScheme != nil && afterSchemeCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Scheme at\n%s", m.funcSchemeOrigin)
	}

	if !m.SchemeMock.invocationsDone() && afterSchemeCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Scheme at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SchemeMock.expectedInvocations), m.SchemeMock.expectedInvocationsOrigin, afterSchemeCounter)
	}
}

type mKubernetesClientMockStatus struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockStatusExpectation
	expectations       []*KubernetesClientMockStatusExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockStatusExpectation specifies expectation struct of the KubernetesClient.Status
type KubernetesClientMockStatusExpectation struct {
	mock *KubernetesClientMock

	results      *KubernetesClientMockStatusResults
	returnOrigin string
	Counter      uint64
}

// KubernetesClientMockStatusResults contains results of the KubernetesClient.Status
type KubernetesClientMockStatusResults struct {
	s1 client.SubResourceWriter
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatus *mKubernetesClientMockStatus) Optional() *mKubernetesClientMockStatus {
	mmStatus.optional = true
	return mmStatus
}

// Expect sets up expected params for KubernetesClient.Status
func (mmStatus *mKubernetesClientMockStatus) Expect() *mKubernetesClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("KubernetesClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &KubernetesClientMockStatusExpectation{}
	}

	return mmStatus
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Status
func (mmStatus *mKubernetesClientMockStatus) Inspect(f func()) *mKubernetesClientMockStatus {
	if mmStatus.mock.inspectFuncStatus != nil {
		mmStatus.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Status")
	}

	mmStatus.mock.inspectFuncStatus = f

	return mmStatus
}

// Return sets up results that will be returned by KubernetesClient.Status
func (mmStatus *mKubernetesClientMockStatus) Return(s1 client.SubResourceWriter) *KubernetesClientMock {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("KubernetesClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &KubernetesClientMockStatusExpectation{mock: mmStatus.mock}
	}
	mmStatus.defaultExpectation.results = &KubernetesClientMockStatusResults{s1}
	mmStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// Set uses given function f to mock the KubernetesClient.Status method
func (mmStatus *mKubernetesClientMockStatus) Set(f func() (s1 client.SubResourceWriter)) *KubernetesClientMock {
	if mmStatus.defaultExpectation != nil {
		mmStatus.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Status method")
	}

	if len(mmStatus.expectations) > 0 {
		mmStatus.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Status method")
	}

	mmStatus.mock.funcStatus = f
	mmStatus.mock.funcStatusOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// Times sets number of times KubernetesClient.Status should be invoked
func (mmStatus *mKubernetesClientMockStatus) Times(n uint64) *mKubernetesClientMockStatus {
	if n == 0 {
		mmStatus.mock.t.Fatalf("Times of KubernetesClientMock.Status mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatus.expectedInvocations, n)
	mmStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatus
}

func (mmStatus *mKubernetesClientMockStatus) invocationsDone() bool {
	if len(mmStatus.expectations) == 0 && mmStatus.defaultExpectation == nil && mmStatus.mock.funcStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatus.mock.afterStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Status implements mm_pkg.KubernetesClient
func (mmStatus *KubernetesClientMock) Status() (s1 client.SubResourceWriter) {
	mm_atomic.AddUint64(&mmStatus.beforeStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmStatus.afterStatusCounter, 1)

	mmStatus.t.Helper()

	if mmStatus.inspectFuncStatus != nil {
		mmStatus.inspectFuncStatus()
	}

	if mmStatus.StatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatus.StatusMock.defaultExpectation.Counter, 1)

		mm_results := mmStatus.StatusMock.defaultExpectation.results
		if mm_results == nil {
			mmStatus.t.Fatal("No results are set for the KubernetesClientMock.Status")
		}
		return (*mm_results).s1
	}
	if mmStatus.funcStatus != nil {
		return mmStatus.funcStatus()
	}
	mmStatus.t.Fatalf("Unexpected call to KubernetesClientMock.Status.")
	return
}

// StatusAfterCounter returns a count of finished KubernetesClientMock.Status invocations
func (mmStatus *KubernetesClientMock) StatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.afterStatusCounter)
}

// StatusBeforeCounter returns a count of KubernetesClientMock.Status invocations
func (mmStatus *KubernetesClientMock) StatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.beforeStatusCounter)
}

// MinimockStatusDone returns true if the count of the Status invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockStatusDone() bool {
	if m.StatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusMock.invocationsDone()
}

// MinimockStatusInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockStatusInspect() {
	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to KubernetesClientMock.Status")
		}
	}

	afterStatusCounter := mm_atomic.LoadUint64(&m.afterStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusMock.defaultExpectation != nil && afterStatusCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Status at\n%s", m.StatusMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatus != nil && afterStatusCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Status at\n%s", m.funcStatusOrigin)
	}

	if !m.StatusMock.invocationsDone() && afterStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Status at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusMock.expectedInvocations), m.StatusMock.expectedInvocationsOrigin, afterStatusCounter)
	}
}

type mKubernetesClientMockSubResource struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockSubResourceExpectation
	expectations       []*KubernetesClientMockSubResourceExpectation

	callArgs []*KubernetesClientMockSubResourceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockSubResourceExpectation specifies expectation struct of the KubernetesClient.SubResource
type KubernetesClientMockSubResourceExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockSubResourceParams
	paramPtrs          *KubernetesClientMockSubResourceParamPtrs
	expectationOrigins KubernetesClientMockSubResourceExpectationOrigins
	results            *KubernetesClientMockSubResourceResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockSubResourceParams contains parameters of the KubernetesClient.SubResource
type KubernetesClientMockSubResourceParams struct {
	subResource string
}

// KubernetesClientMockSubResourceParamPtrs contains pointers to parameters of the KubernetesClient.SubResource
type KubernetesClientMockSubResourceParamPtrs struct {
	subResource *string
}

// KubernetesClientMockSubResourceResults contains results of the KubernetesClient.SubResource
type KubernetesClientMockSubResourceResults struct {
	s1 client.SubResourceClient
}

// KubernetesClientMockSubResourceOrigins contains origins of expectations of the KubernetesClient.SubResource
type KubernetesClientMockSubResourceExpectationOrigins struct {
	origin            string
	originSubResource string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSubResource *mKubernetesClientMockSubResource) Optional() *mKubernetesClientMockSubResource {
	mmSubResource.optional = true
	return mmSubResource
}

// Expect sets up expected params for KubernetesClient.SubResource
func (mmSubResource *mKubernetesClientMockSubResource) Expect(subResource string) *mKubernetesClientMockSubResource {
	if mmSubResource.mock.funcSubResource != nil {
		mmSubResource.mock.t.Fatalf("KubernetesClientMock.SubResource mock is already set by Set")
	}

	if mmSubResource.defaultExpectation == nil {
		mmSubResource.defaultExpectation = &KubernetesClientMockSubResourceExpectation{}
	}

	if mmSubResource.defaultExpectation.paramPtrs != nil {
		mmSubResource.mock.t.Fatalf("KubernetesClientMock.SubResource mock is already set by ExpectParams functions")
	}

	mmSubResource.defaultExpectation.params = &KubernetesClientMockSubResourceParams{subResource}
	mmSubResource.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSubResource.expectations {
		if minimock.Equal(e.params, mmSubResource.defaultExpectation.params) {
			mmSubResource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubResource.defaultExpectation.params)
		}
	}

	return mmSubResource
}

// ExpectSubResourceParam1 sets up expected param subResource for KubernetesClient.SubResource
func (mmSubResource *mKubernetesClientMockSubResource) ExpectSubResourceParam1(subResource string) *mKubernetesClientMockSubResource {
	if mmSubResource.mock.funcSubResource != nil {
		mmSubResource.mock.t.Fatalf("KubernetesClientMock.SubResource mock is already set by Set")
	}

	if mmSubResource.defaultExpectation == nil {
		mmSubResource.defaultExpectation = &KubernetesClientMockSubResourceExpectation{}
	}

	if mmSubResource.defaultExpectation.params != nil {
		mmSubResource.mock.t.Fatalf("KubernetesClientMock.SubResource mock is already set by Expect")
	}

	if mmSubResource.defaultExpectation.paramPtrs == nil {
		mmSubResource.defaultExpectation.paramPtrs = &KubernetesClientMockSubResourceParamPtrs{}
	}
	mmSubResource.defaultExpectation.paramPtrs.subResource = &subResource
	mmSubResource.defaultExpectation.expectationOrigins.originSubResource = minimock.CallerInfo(1)

	return mmSubResource
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.SubResource
func (mmSubResource *mKubernetesClientMockSubResource) Inspect(f func(subResource string)) *mKubernetesClientMockSubResource {
	if mmSubResource.mock.inspectFuncSubResource != nil {
		mmSubResource.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.SubResource")
	}

	mmSubResource.mock.inspectFuncSubResource = f

	return mmSubResource
}

// Return sets up results that will be returned by KubernetesClient.SubResource
func (mmSubResource *mKubernetesClientMockSubResource) Return(s1 client.SubResourceClient) *KubernetesClientMock {
	if mmSubResource.mock.funcSubResource != nil {
		mmSubResource.mock.t.Fatalf("KubernetesClientMock.SubResource mock is already set by Set")
	}

	if mmSubResource.defaultExpectation == nil {
		mmSubResource.defaultExpectation = &KubernetesClientMockSubResourceExpectation{mock: mmSubResource.mock}
	}
	mmSubResource.defaultExpectation.results = &KubernetesClientMockSubResourceResults{s1}
	mmSubResource.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSubResource.mock
}

// Set uses given function f to mock the KubernetesClient.SubResource method
func (mmSubResource *mKubernetesClientMockSubResource) Set(f func(subResource string) (s1 client.SubResourceClient)) *KubernetesClientMock {
	if mmSubResource.defaultExpectation != nil {
		mmSubResource.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.SubResource method")
	}

	if len(mmSubResource.expectations) > 0 {
		mmSubResource.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.SubResource method")
	}

	mmSubResource.mock.funcSubResource = f
	mmSubResource.mock.funcSubResourceOrigin = minimock.CallerInfo(1)
	return mmSubResource.mock
}

// When sets expectation for the KubernetesClient.SubResource which will trigger the result defined by the following
// Then helper
func (mmSubResource *mKubernetesClientMockSubResource) When(subResource string) *KubernetesClientMockSubResourceExpectation {
	if mmSubResource.mock.funcSubResource != nil {
		mmSubResource.mock.t.Fatalf("KubernetesClientMock.SubResource mock is already set by Set")
	}

	expectation := &KubernetesClientMockSubResourceExpectation{
		mock:               mmSubResource.mock,
		params:             &KubernetesClientMockSubResourceParams{subResource},
		expectationOrigins: KubernetesClientMockSubResourceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSubResource.expectations = append(mmSubResource.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.SubResource return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockSubResourceExpectation) Then(s1 client.SubResourceClient) *KubernetesClientMock {
	e.results = &KubernetesClientMockSubResourceResults{s1}
	return e.mock
}

// Times sets number of times KubernetesClient.SubResource should be invoked
func (mmSubResource *mKubernetesClientMockSubResource) Times(n uint64) *mKubernetesClientMockSubResource {
	if n == 0 {
		mmSubResource.mock.t.Fatalf("Times of KubernetesClientMock.SubResource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSubResource.expectedInvocations, n)
	mmSubResource.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSubResource
}

func (mmSubResource *mKubernetesClientMockSubResource) invocationsDone() bool {
	if len(mmSubResource.expectations) == 0 && mmSubResource.defaultExpectation == nil && mmSubResource.mock.funcSubResource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSubResource.mock.afterSubResourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSubResource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SubResource implements mm_pkg.KubernetesClient
func (mmSubResource *KubernetesClientMock) SubResource(subResource string) (s1 client.SubResourceClient) {
	mm_atomic.AddUint64(&mmSubResource.beforeSubResourceCounter, 1)
	defer mm_atomic.AddUint64(&mmSubResource.afterSubResourceCounter, 1)

	mmSubResource.t.Helper()

	if mmSubResource.inspectFuncSubResource != nil {
		mmSubResource.inspectFuncSubResource(subResource)
	}

	mm_params := KubernetesClientMockSubResourceParams{subResource}

	// Record call args
	mmSubResource.SubResourceMock.mutex.Lock()
	mmSubResource.SubResourceMock.callArgs = append(mmSubResource.SubResourceMock.callArgs, &mm_params)
	mmSubResource.SubResourceMock.mutex.Unlock()

	for _, e := range mmSubResource.SubResourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSubResource.SubResourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubResource.SubResourceMock.defaultExpectation.Counter, 1)
		mm_want := mmSubResource.SubResourceMock.defaultExpectation.params
		mm_want_ptrs := mmSubResource.SubResourceMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockSubResourceParams{subResource}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.subResource != nil && !minimock.Equal(*mm_want_ptrs.subResource, mm_got.subResource) {
				mmSubResource.t.Errorf("KubernetesClientMock.SubResource got unexpected parameter subResource, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubResource.SubResourceMock.defaultExpectation.expectationOrigins.originSubResource, *mm_want_ptrs.subResource, mm_got.subResource, minimock.Diff(*mm_want_ptrs.subResource, mm_got.subResource))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubResource.t.Errorf("KubernetesClientMock.SubResource got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSubResource.SubResourceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubResource.SubResourceMock.defaultExpectation.results
		if mm_results == nil {
			mmSubResource.t.Fatal("No results are set for the KubernetesClientMock.SubResource")
		}
		return (*mm_results).s1
	}
	if mmSubResource.funcSubResource != nil {
		return mmSubResource.funcSubResource(subResource)
	}
	mmSubResource.t.Fatalf("Unexpected call to KubernetesClientMock.SubResource. %v", subResource)
	return
}

// SubResourceAfterCounter returns a count of finished KubernetesClientMock.SubResource invocations
func (mmSubResource *KubernetesClientMock) SubResourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubResource.afterSubResourceCounter)
}

// SubResourceBeforeCounter returns a count of KubernetesClientMock.SubResource invocations
func (mmSubResource *KubernetesClientMock) SubResourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubResource.beforeSubResourceCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.SubResource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubResource *mKubernetesClientMockSubResource) Calls() []*KubernetesClientMockSubResourceParams {
	mmSubResource.mutex.RLock()

	argCopy := make([]*KubernetesClientMockSubResourceParams, len(mmSubResource.callArgs))
	copy(argCopy, mmSubResource.callArgs)

	mmSubResource.mutex.RUnlock()

	return argCopy
}

// MinimockSubResourceDone returns true if the count of the SubResource invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockSubResourceDone() bool {
	if m.SubResourceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SubResourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SubResourceMock.invocationsDone()
}

// MinimockSubResourceInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockSubResourceInspect() {
	for _, e := range m.SubResourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.SubResource at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSubResourceCounter := mm_atomic.LoadUint64(&m.afterSubResourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SubResourceMock.defaultExpectation != nil && afterSubResourceCounter < 1 {
		if m.SubResourceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.SubResource at\n%s", m.SubResourceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.SubResource at\n%s with params: %#v", m.SubResourceMock.defaultExpectation.expectationOrigins.origin, *m.SubResourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubResource != nil && afterSubResourceCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.SubResource at\n%s", m.funcSubResourceOrigin)
	}

	if !m.SubResourceMock.invocationsDone() && afterSubResourceCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.SubResource at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SubResourceMock.expectedInvocations), m.SubResourceMock.expectedInvocationsOrigin, afterSubResourceCounter)
	}
}

type mKubernetesClientMockUpdate struct {
	optional           bool
	mock               *KubernetesClientMock
	defaultExpectation *KubernetesClientMockUpdateExpectation
	expectations       []*KubernetesClientMockUpdateExpectation

	callArgs []*KubernetesClientMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesClientMockUpdateExpectation specifies expectation struct of the KubernetesClient.Update
type KubernetesClientMockUpdateExpectation struct {
	mock               *KubernetesClientMock
	params             *KubernetesClientMockUpdateParams
	paramPtrs          *KubernetesClientMockUpdateParamPtrs
	expectationOrigins KubernetesClientMockUpdateExpectationOrigins
	results            *KubernetesClientMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesClientMockUpdateParams contains parameters of the KubernetesClient.Update
type KubernetesClientMockUpdateParams struct {
	ctx  context.Context
	obj  client.Object
	opts []client.UpdateOption
}

// KubernetesClientMockUpdateParamPtrs contains pointers to parameters of the KubernetesClient.Update
type KubernetesClientMockUpdateParamPtrs struct {
	ctx  *context.Context
	obj  *client.Object
	opts *[]client.UpdateOption
}

// KubernetesClientMockUpdateResults contains results of the KubernetesClient.Update
type KubernetesClientMockUpdateResults struct {
	err error
}

// KubernetesClientMockUpdateOrigins contains origins of expectations of the KubernetesClient.Update
type KubernetesClientMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originObj  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mKubernetesClientMockUpdate) Optional() *mKubernetesClientMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for KubernetesClient.Update
func (mmUpdate *mKubernetesClientMockUpdate) Expect(ctx context.Context, obj client.Object, opts ...client.UpdateOption) *mKubernetesClientMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesClientMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &KubernetesClientMockUpdateParams{ctx, obj, opts}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for KubernetesClient.Update
func (mmUpdate *mKubernetesClientMockUpdate) ExpectCtxParam1(ctx context.Context) *mKubernetesClientMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesClientMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &KubernetesClientMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectObjParam2 sets up expected param obj for KubernetesClient.Update
func (mmUpdate *mKubernetesClientMockUpdate) ExpectObjParam2(obj client.Object) *mKubernetesClientMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesClientMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &KubernetesClientMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.obj = &obj
	mmUpdate.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectOptsParam3 sets up expected param opts for KubernetesClient.Update
func (mmUpdate *mKubernetesClientMockUpdate) ExpectOptsParam3(opts ...client.UpdateOption) *mKubernetesClientMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesClientMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &KubernetesClientMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.opts = &opts
	mmUpdate.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the KubernetesClient.Update
func (mmUpdate *mKubernetesClientMockUpdate) Inspect(f func(ctx context.Context, obj client.Object, opts ...client.UpdateOption)) *mKubernetesClientMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for KubernetesClientMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by KubernetesClient.Update
func (mmUpdate *mKubernetesClientMockUpdate) Return(err error) *KubernetesClientMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesClientMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &KubernetesClientMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the KubernetesClient.Update method
func (mmUpdate *mKubernetesClientMockUpdate) Set(f func(ctx context.Context, obj client.Object, opts ...client.UpdateOption) (err error)) *KubernetesClientMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the KubernetesClient.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the KubernetesClient.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the KubernetesClient.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mKubernetesClientMockUpdate) When(ctx context.Context, obj client.Object, opts ...client.UpdateOption) *KubernetesClientMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesClientMock.Update mock is already set by Set")
	}

	expectation := &KubernetesClientMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &KubernetesClientMockUpdateParams{ctx, obj, opts},
		expectationOrigins: KubernetesClientMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up KubernetesClient.Update return parameters for the expectation previously defined by the When method
func (e *KubernetesClientMockUpdateExpectation) Then(err error) *KubernetesClientMock {
	e.results = &KubernetesClientMockUpdateResults{err}
	return e.mock
}

// Times sets number of times KubernetesClient.Update should be invoked
func (mmUpdate *mKubernetesClientMockUpdate) Times(n uint64) *mKubernetesClientMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of KubernetesClientMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mKubernetesClientMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_pkg.KubernetesClient
func (mmUpdate *KubernetesClientMock) Update(ctx context.Context, obj client.Object, opts ...client.UpdateOption) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, obj, opts...)
	}

	mm_params := KubernetesClientMockUpdateParams{ctx, obj, opts}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := KubernetesClientMockUpdateParams{ctx, obj, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("KubernetesClientMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmUpdate.t.Errorf("KubernetesClientMock.Update got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdate.t.Errorf("KubernetesClientMock.Update got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("KubernetesClientMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the KubernetesClientMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, obj, opts...)
	}
	mmUpdate.t.Fatalf("Unexpected call to KubernetesClientMock.Update. %v %v %v", ctx, obj, opts)
	return
}

// UpdateAfterCounter returns a count of finished KubernetesClientMock.Update invocations
func (mmUpdate *KubernetesClientMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of KubernetesClientMock.Update invocations
func (mmUpdate *KubernetesClientMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to KubernetesClientMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mKubernetesClientMockUpdate) Calls() []*KubernetesClientMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*KubernetesClientMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *KubernetesClientMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *KubernetesClientMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesClientMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesClientMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesClientMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to KubernetesClientMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesClientMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *KubernetesClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockApplyInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockDeleteAllOfInspect()

			m.MinimockDynamicInspect()

			m.MinimockGetInspect()

			m.MinimockGroupVersionKindForInspect()

			m.MinimockIsObjectNamespacedInspect()

			m.MinimockListInspect()

			m.MinimockPatchInspect()

			m.MinimockRESTMapperInspect()

			m.MinimockSchemeInspect()

			m.MinimockStatusInspect()

			m.MinimockSubResourceInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *KubernetesClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *KubernetesClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApplyDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteAllOfDone() &&
		m.MinimockDynamicDone() &&
		m.MinimockGetDone() &&
		m.MinimockGroupVersionKindForDone() &&
		m.MinimockIsObjectNamespacedDone() &&
		m.MinimockListDone() &&
		m.MinimockPatchDone() &&
		m.MinimockRESTMapperDone() &&
		m.MinimockSchemeDone() &&
		m.MinimockStatusDone() &&
		m.MinimockSubResourceDone() &&
		m.MinimockUpdateDone()
}
