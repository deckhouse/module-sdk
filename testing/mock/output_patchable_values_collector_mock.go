// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.OutputPatchableValuesCollector -o output_patchable_values_collector_mock.go -n OutputPatchableValuesCollectorMock -p mock

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/deckhouse/module-sdk/pkg/utils"
	"github.com/gojuno/minimock/v3"
	"github.com/tidwall/gjson"
)

// OutputPatchableValuesCollectorMock implements mm_pkg.OutputPatchableValuesCollector
type OutputPatchableValuesCollectorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcArrayCount          func(path string) (i1 int, err error)
	funcArrayCountOrigin    string
	inspectFuncArrayCount   func(path string)
	afterArrayCountCounter  uint64
	beforeArrayCountCounter uint64
	ArrayCountMock          mOutputPatchableValuesCollectorMockArrayCount

	funcExists          func(path string) (b1 bool)
	funcExistsOrigin    string
	inspectFuncExists   func(path string)
	afterExistsCounter  uint64
	beforeExistsCounter uint64
	ExistsMock          mOutputPatchableValuesCollectorMockExists

	funcGet          func(path string) (r1 gjson.Result)
	funcGetOrigin    string
	inspectFuncGet   func(path string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mOutputPatchableValuesCollectorMockGet

	funcGetOk          func(path string) (r1 gjson.Result, b1 bool)
	funcGetOkOrigin    string
	inspectFuncGetOk   func(path string)
	afterGetOkCounter  uint64
	beforeGetOkCounter uint64
	GetOkMock          mOutputPatchableValuesCollectorMockGetOk

	funcGetPatches          func() (vpa1 []*utils.ValuesPatchOperation)
	funcGetPatchesOrigin    string
	inspectFuncGetPatches   func()
	afterGetPatchesCounter  uint64
	beforeGetPatchesCounter uint64
	GetPatchesMock          mOutputPatchableValuesCollectorMockGetPatches

	funcGetRaw          func(path string) (a1 any)
	funcGetRawOrigin    string
	inspectFuncGetRaw   func(path string)
	afterGetRawCounter  uint64
	beforeGetRawCounter uint64
	GetRawMock          mOutputPatchableValuesCollectorMockGetRaw

	funcRemove          func(path string)
	funcRemoveOrigin    string
	inspectFuncRemove   func(path string)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mOutputPatchableValuesCollectorMockRemove

	funcSet          func(path string, value any)
	funcSetOrigin    string
	inspectFuncSet   func(path string, value any)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mOutputPatchableValuesCollectorMockSet

	funcWriteOutput          func(writer io.Writer) (err error)
	funcWriteOutputOrigin    string
	inspectFuncWriteOutput   func(writer io.Writer)
	afterWriteOutputCounter  uint64
	beforeWriteOutputCounter uint64
	WriteOutputMock          mOutputPatchableValuesCollectorMockWriteOutput
}

// NewPatchableValuesCollectorMock returns a mock for mm_pkg.OutputPatchableValuesCollector
func NewPatchableValuesCollectorMock(t minimock.Tester) *OutputPatchableValuesCollectorMock {
	m := &OutputPatchableValuesCollectorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArrayCountMock = mOutputPatchableValuesCollectorMockArrayCount{mock: m}
	m.ArrayCountMock.callArgs = []*OutputPatchableValuesCollectorMockArrayCountParams{}

	m.ExistsMock = mOutputPatchableValuesCollectorMockExists{mock: m}
	m.ExistsMock.callArgs = []*OutputPatchableValuesCollectorMockExistsParams{}

	m.GetMock = mOutputPatchableValuesCollectorMockGet{mock: m}
	m.GetMock.callArgs = []*OutputPatchableValuesCollectorMockGetParams{}

	m.GetOkMock = mOutputPatchableValuesCollectorMockGetOk{mock: m}
	m.GetOkMock.callArgs = []*OutputPatchableValuesCollectorMockGetOkParams{}

	m.GetPatchesMock = mOutputPatchableValuesCollectorMockGetPatches{mock: m}

	m.GetRawMock = mOutputPatchableValuesCollectorMockGetRaw{mock: m}
	m.GetRawMock.callArgs = []*OutputPatchableValuesCollectorMockGetRawParams{}

	m.RemoveMock = mOutputPatchableValuesCollectorMockRemove{mock: m}
	m.RemoveMock.callArgs = []*OutputPatchableValuesCollectorMockRemoveParams{}

	m.SetMock = mOutputPatchableValuesCollectorMockSet{mock: m}
	m.SetMock.callArgs = []*OutputPatchableValuesCollectorMockSetParams{}

	m.WriteOutputMock = mOutputPatchableValuesCollectorMockWriteOutput{mock: m}
	m.WriteOutputMock.callArgs = []*OutputPatchableValuesCollectorMockWriteOutputParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOutputPatchableValuesCollectorMockArrayCount struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockArrayCountExpectation
	expectations       []*OutputPatchableValuesCollectorMockArrayCountExpectation

	callArgs []*OutputPatchableValuesCollectorMockArrayCountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockArrayCountExpectation specifies expectation struct of the OutputPatchableValuesCollector.ArrayCount
type OutputPatchableValuesCollectorMockArrayCountExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockArrayCountParams
	paramPtrs          *OutputPatchableValuesCollectorMockArrayCountParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockArrayCountExpectationOrigins
	results            *OutputPatchableValuesCollectorMockArrayCountResults
	returnOrigin       string
	Counter            uint64
}

// OutputPatchableValuesCollectorMockArrayCountParams contains parameters of the OutputPatchableValuesCollector.ArrayCount
type OutputPatchableValuesCollectorMockArrayCountParams struct {
	path string
}

// OutputPatchableValuesCollectorMockArrayCountParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.ArrayCount
type OutputPatchableValuesCollectorMockArrayCountParamPtrs struct {
	path *string
}

// OutputPatchableValuesCollectorMockArrayCountResults contains results of the OutputPatchableValuesCollector.ArrayCount
type OutputPatchableValuesCollectorMockArrayCountResults struct {
	i1  int
	err error
}

// OutputPatchableValuesCollectorMockArrayCountOrigins contains origins of expectations of the OutputPatchableValuesCollector.ArrayCount
type OutputPatchableValuesCollectorMockArrayCountExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) Optional() *mOutputPatchableValuesCollectorMockArrayCount {
	mmArrayCount.optional = true
	return mmArrayCount
}

// Expect sets up expected params for OutputPatchableValuesCollector.ArrayCount
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) Expect(path string) *mOutputPatchableValuesCollectorMockArrayCount {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("OutputPatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	if mmArrayCount.defaultExpectation == nil {
		mmArrayCount.defaultExpectation = &OutputPatchableValuesCollectorMockArrayCountExpectation{}
	}

	if mmArrayCount.defaultExpectation.paramPtrs != nil {
		mmArrayCount.mock.t.Fatalf("OutputPatchableValuesCollectorMock.ArrayCount mock is already set by ExpectParams functions")
	}

	mmArrayCount.defaultExpectation.params = &OutputPatchableValuesCollectorMockArrayCountParams{path}
	mmArrayCount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmArrayCount.expectations {
		if minimock.Equal(e.params, mmArrayCount.defaultExpectation.params) {
			mmArrayCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmArrayCount.defaultExpectation.params)
		}
	}

	return mmArrayCount
}

// ExpectPathParam1 sets up expected param path for OutputPatchableValuesCollector.ArrayCount
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) ExpectPathParam1(path string) *mOutputPatchableValuesCollectorMockArrayCount {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("OutputPatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	if mmArrayCount.defaultExpectation == nil {
		mmArrayCount.defaultExpectation = &OutputPatchableValuesCollectorMockArrayCountExpectation{}
	}

	if mmArrayCount.defaultExpectation.params != nil {
		mmArrayCount.mock.t.Fatalf("OutputPatchableValuesCollectorMock.ArrayCount mock is already set by Expect")
	}

	if mmArrayCount.defaultExpectation.paramPtrs == nil {
		mmArrayCount.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockArrayCountParamPtrs{}
	}
	mmArrayCount.defaultExpectation.paramPtrs.path = &path
	mmArrayCount.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmArrayCount
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.ArrayCount
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) Inspect(f func(path string)) *mOutputPatchableValuesCollectorMockArrayCount {
	if mmArrayCount.mock.inspectFuncArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.ArrayCount")
	}

	mmArrayCount.mock.inspectFuncArrayCount = f

	return mmArrayCount
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.ArrayCount
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) Return(i1 int, err error) *OutputPatchableValuesCollectorMock {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("OutputPatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	if mmArrayCount.defaultExpectation == nil {
		mmArrayCount.defaultExpectation = &OutputPatchableValuesCollectorMockArrayCountExpectation{mock: mmArrayCount.mock}
	}
	mmArrayCount.defaultExpectation.results = &OutputPatchableValuesCollectorMockArrayCountResults{i1, err}
	mmArrayCount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmArrayCount.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.ArrayCount method
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) Set(f func(path string) (i1 int, err error)) *OutputPatchableValuesCollectorMock {
	if mmArrayCount.defaultExpectation != nil {
		mmArrayCount.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.ArrayCount method")
	}

	if len(mmArrayCount.expectations) > 0 {
		mmArrayCount.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.ArrayCount method")
	}

	mmArrayCount.mock.funcArrayCount = f
	mmArrayCount.mock.funcArrayCountOrigin = minimock.CallerInfo(1)
	return mmArrayCount.mock
}

// When sets expectation for the OutputPatchableValuesCollector.ArrayCount which will trigger the result defined by the following
// Then helper
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) When(path string) *OutputPatchableValuesCollectorMockArrayCountExpectation {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("OutputPatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockArrayCountExpectation{
		mock:               mmArrayCount.mock,
		params:             &OutputPatchableValuesCollectorMockArrayCountParams{path},
		expectationOrigins: OutputPatchableValuesCollectorMockArrayCountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmArrayCount.expectations = append(mmArrayCount.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.ArrayCount return parameters for the expectation previously defined by the When method
func (e *OutputPatchableValuesCollectorMockArrayCountExpectation) Then(i1 int, err error) *OutputPatchableValuesCollectorMock {
	e.results = &OutputPatchableValuesCollectorMockArrayCountResults{i1, err}
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.ArrayCount should be invoked
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) Times(n uint64) *mOutputPatchableValuesCollectorMockArrayCount {
	if n == 0 {
		mmArrayCount.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.ArrayCount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmArrayCount.expectedInvocations, n)
	mmArrayCount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmArrayCount
}

func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) invocationsDone() bool {
	if len(mmArrayCount.expectations) == 0 && mmArrayCount.defaultExpectation == nil && mmArrayCount.mock.funcArrayCount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmArrayCount.mock.afterArrayCountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmArrayCount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ArrayCount implements mm_pkg.OutputPatchableValuesCollector
func (mmArrayCount *OutputPatchableValuesCollectorMock) ArrayCount(path string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmArrayCount.beforeArrayCountCounter, 1)
	defer mm_atomic.AddUint64(&mmArrayCount.afterArrayCountCounter, 1)

	mmArrayCount.t.Helper()

	if mmArrayCount.inspectFuncArrayCount != nil {
		mmArrayCount.inspectFuncArrayCount(path)
	}

	mm_params := OutputPatchableValuesCollectorMockArrayCountParams{path}

	// Record call args
	mmArrayCount.ArrayCountMock.mutex.Lock()
	mmArrayCount.ArrayCountMock.callArgs = append(mmArrayCount.ArrayCountMock.callArgs, &mm_params)
	mmArrayCount.ArrayCountMock.mutex.Unlock()

	for _, e := range mmArrayCount.ArrayCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmArrayCount.ArrayCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArrayCount.ArrayCountMock.defaultExpectation.Counter, 1)
		mm_want := mmArrayCount.ArrayCountMock.defaultExpectation.params
		mm_want_ptrs := mmArrayCount.ArrayCountMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockArrayCountParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmArrayCount.t.Errorf("OutputPatchableValuesCollectorMock.ArrayCount got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmArrayCount.ArrayCountMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmArrayCount.t.Errorf("OutputPatchableValuesCollectorMock.ArrayCount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmArrayCount.ArrayCountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmArrayCount.ArrayCountMock.defaultExpectation.results
		if mm_results == nil {
			mmArrayCount.t.Fatal("No results are set for the OutputPatchableValuesCollectorMock.ArrayCount")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmArrayCount.funcArrayCount != nil {
		return mmArrayCount.funcArrayCount(path)
	}
	mmArrayCount.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.ArrayCount. %v", path)
	return
}

// ArrayCountAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.ArrayCount invocations
func (mmArrayCount *OutputPatchableValuesCollectorMock) ArrayCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArrayCount.afterArrayCountCounter)
}

// ArrayCountBeforeCounter returns a count of OutputPatchableValuesCollectorMock.ArrayCount invocations
func (mmArrayCount *OutputPatchableValuesCollectorMock) ArrayCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArrayCount.beforeArrayCountCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.ArrayCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmArrayCount *mOutputPatchableValuesCollectorMockArrayCount) Calls() []*OutputPatchableValuesCollectorMockArrayCountParams {
	mmArrayCount.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockArrayCountParams, len(mmArrayCount.callArgs))
	copy(argCopy, mmArrayCount.callArgs)

	mmArrayCount.mutex.RUnlock()

	return argCopy
}

// MinimockArrayCountDone returns true if the count of the ArrayCount invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockArrayCountDone() bool {
	if m.ArrayCountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ArrayCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ArrayCountMock.invocationsDone()
}

// MinimockArrayCountInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockArrayCountInspect() {
	for _, e := range m.ArrayCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.ArrayCount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterArrayCountCounter := mm_atomic.LoadUint64(&m.afterArrayCountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ArrayCountMock.defaultExpectation != nil && afterArrayCountCounter < 1 {
		if m.ArrayCountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.ArrayCount at\n%s", m.ArrayCountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.ArrayCount at\n%s with params: %#v", m.ArrayCountMock.defaultExpectation.expectationOrigins.origin, *m.ArrayCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArrayCount != nil && afterArrayCountCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.ArrayCount at\n%s", m.funcArrayCountOrigin)
	}

	if !m.ArrayCountMock.invocationsDone() && afterArrayCountCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.ArrayCount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ArrayCountMock.expectedInvocations), m.ArrayCountMock.expectedInvocationsOrigin, afterArrayCountCounter)
	}
}

type mOutputPatchableValuesCollectorMockExists struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockExistsExpectation
	expectations       []*OutputPatchableValuesCollectorMockExistsExpectation

	callArgs []*OutputPatchableValuesCollectorMockExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockExistsExpectation specifies expectation struct of the OutputPatchableValuesCollector.Exists
type OutputPatchableValuesCollectorMockExistsExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockExistsParams
	paramPtrs          *OutputPatchableValuesCollectorMockExistsParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockExistsExpectationOrigins
	results            *OutputPatchableValuesCollectorMockExistsResults
	returnOrigin       string
	Counter            uint64
}

// OutputPatchableValuesCollectorMockExistsParams contains parameters of the OutputPatchableValuesCollector.Exists
type OutputPatchableValuesCollectorMockExistsParams struct {
	path string
}

// OutputPatchableValuesCollectorMockExistsParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.Exists
type OutputPatchableValuesCollectorMockExistsParamPtrs struct {
	path *string
}

// OutputPatchableValuesCollectorMockExistsResults contains results of the OutputPatchableValuesCollector.Exists
type OutputPatchableValuesCollectorMockExistsResults struct {
	b1 bool
}

// OutputPatchableValuesCollectorMockExistsOrigins contains origins of expectations of the OutputPatchableValuesCollector.Exists
type OutputPatchableValuesCollectorMockExistsExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExists *mOutputPatchableValuesCollectorMockExists) Optional() *mOutputPatchableValuesCollectorMockExists {
	mmExists.optional = true
	return mmExists
}

// Expect sets up expected params for OutputPatchableValuesCollector.Exists
func (mmExists *mOutputPatchableValuesCollectorMockExists) Expect(path string) *mOutputPatchableValuesCollectorMockExists {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &OutputPatchableValuesCollectorMockExistsExpectation{}
	}

	if mmExists.defaultExpectation.paramPtrs != nil {
		mmExists.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Exists mock is already set by ExpectParams functions")
	}

	mmExists.defaultExpectation.params = &OutputPatchableValuesCollectorMockExistsParams{path}
	mmExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExists.expectations {
		if minimock.Equal(e.params, mmExists.defaultExpectation.params) {
			mmExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExists.defaultExpectation.params)
		}
	}

	return mmExists
}

// ExpectPathParam1 sets up expected param path for OutputPatchableValuesCollector.Exists
func (mmExists *mOutputPatchableValuesCollectorMockExists) ExpectPathParam1(path string) *mOutputPatchableValuesCollectorMockExists {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &OutputPatchableValuesCollectorMockExistsExpectation{}
	}

	if mmExists.defaultExpectation.params != nil {
		mmExists.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Exists mock is already set by Expect")
	}

	if mmExists.defaultExpectation.paramPtrs == nil {
		mmExists.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockExistsParamPtrs{}
	}
	mmExists.defaultExpectation.paramPtrs.path = &path
	mmExists.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmExists
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.Exists
func (mmExists *mOutputPatchableValuesCollectorMockExists) Inspect(f func(path string)) *mOutputPatchableValuesCollectorMockExists {
	if mmExists.mock.inspectFuncExists != nil {
		mmExists.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.Exists")
	}

	mmExists.mock.inspectFuncExists = f

	return mmExists
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.Exists
func (mmExists *mOutputPatchableValuesCollectorMockExists) Return(b1 bool) *OutputPatchableValuesCollectorMock {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &OutputPatchableValuesCollectorMockExistsExpectation{mock: mmExists.mock}
	}
	mmExists.defaultExpectation.results = &OutputPatchableValuesCollectorMockExistsResults{b1}
	mmExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExists.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.Exists method
func (mmExists *mOutputPatchableValuesCollectorMockExists) Set(f func(path string) (b1 bool)) *OutputPatchableValuesCollectorMock {
	if mmExists.defaultExpectation != nil {
		mmExists.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.Exists method")
	}

	if len(mmExists.expectations) > 0 {
		mmExists.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.Exists method")
	}

	mmExists.mock.funcExists = f
	mmExists.mock.funcExistsOrigin = minimock.CallerInfo(1)
	return mmExists.mock
}

// When sets expectation for the OutputPatchableValuesCollector.Exists which will trigger the result defined by the following
// Then helper
func (mmExists *mOutputPatchableValuesCollectorMockExists) When(path string) *OutputPatchableValuesCollectorMockExistsExpectation {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockExistsExpectation{
		mock:               mmExists.mock,
		params:             &OutputPatchableValuesCollectorMockExistsParams{path},
		expectationOrigins: OutputPatchableValuesCollectorMockExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExists.expectations = append(mmExists.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.Exists return parameters for the expectation previously defined by the When method
func (e *OutputPatchableValuesCollectorMockExistsExpectation) Then(b1 bool) *OutputPatchableValuesCollectorMock {
	e.results = &OutputPatchableValuesCollectorMockExistsResults{b1}
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.Exists should be invoked
func (mmExists *mOutputPatchableValuesCollectorMockExists) Times(n uint64) *mOutputPatchableValuesCollectorMockExists {
	if n == 0 {
		mmExists.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.Exists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExists.expectedInvocations, n)
	mmExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExists
}

func (mmExists *mOutputPatchableValuesCollectorMockExists) invocationsDone() bool {
	if len(mmExists.expectations) == 0 && mmExists.defaultExpectation == nil && mmExists.mock.funcExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExists.mock.afterExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exists implements mm_pkg.OutputPatchableValuesCollector
func (mmExists *OutputPatchableValuesCollectorMock) Exists(path string) (b1 bool) {
	mm_atomic.AddUint64(&mmExists.beforeExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmExists.afterExistsCounter, 1)

	mmExists.t.Helper()

	if mmExists.inspectFuncExists != nil {
		mmExists.inspectFuncExists(path)
	}

	mm_params := OutputPatchableValuesCollectorMockExistsParams{path}

	// Record call args
	mmExists.ExistsMock.mutex.Lock()
	mmExists.ExistsMock.callArgs = append(mmExists.ExistsMock.callArgs, &mm_params)
	mmExists.ExistsMock.mutex.Unlock()

	for _, e := range mmExists.ExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmExists.ExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExists.ExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmExists.ExistsMock.defaultExpectation.params
		mm_want_ptrs := mmExists.ExistsMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockExistsParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmExists.t.Errorf("OutputPatchableValuesCollectorMock.Exists got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExists.ExistsMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExists.t.Errorf("OutputPatchableValuesCollectorMock.Exists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExists.ExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExists.ExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmExists.t.Fatal("No results are set for the OutputPatchableValuesCollectorMock.Exists")
		}
		return (*mm_results).b1
	}
	if mmExists.funcExists != nil {
		return mmExists.funcExists(path)
	}
	mmExists.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.Exists. %v", path)
	return
}

// ExistsAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.Exists invocations
func (mmExists *OutputPatchableValuesCollectorMock) ExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExists.afterExistsCounter)
}

// ExistsBeforeCounter returns a count of OutputPatchableValuesCollectorMock.Exists invocations
func (mmExists *OutputPatchableValuesCollectorMock) ExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExists.beforeExistsCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.Exists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExists *mOutputPatchableValuesCollectorMockExists) Calls() []*OutputPatchableValuesCollectorMockExistsParams {
	mmExists.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockExistsParams, len(mmExists.callArgs))
	copy(argCopy, mmExists.callArgs)

	mmExists.mutex.RUnlock()

	return argCopy
}

// MinimockExistsDone returns true if the count of the Exists invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockExistsDone() bool {
	if m.ExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExistsMock.invocationsDone()
}

// MinimockExistsInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockExistsInspect() {
	for _, e := range m.ExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Exists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExistsCounter := mm_atomic.LoadUint64(&m.afterExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExistsMock.defaultExpectation != nil && afterExistsCounter < 1 {
		if m.ExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Exists at\n%s", m.ExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Exists at\n%s with params: %#v", m.ExistsMock.defaultExpectation.expectationOrigins.origin, *m.ExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExists != nil && afterExistsCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Exists at\n%s", m.funcExistsOrigin)
	}

	if !m.ExistsMock.invocationsDone() && afterExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.Exists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExistsMock.expectedInvocations), m.ExistsMock.expectedInvocationsOrigin, afterExistsCounter)
	}
}

type mOutputPatchableValuesCollectorMockGet struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockGetExpectation
	expectations       []*OutputPatchableValuesCollectorMockGetExpectation

	callArgs []*OutputPatchableValuesCollectorMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockGetExpectation specifies expectation struct of the OutputPatchableValuesCollector.Get
type OutputPatchableValuesCollectorMockGetExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockGetParams
	paramPtrs          *OutputPatchableValuesCollectorMockGetParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockGetExpectationOrigins
	results            *OutputPatchableValuesCollectorMockGetResults
	returnOrigin       string
	Counter            uint64
}

// OutputPatchableValuesCollectorMockGetParams contains parameters of the OutputPatchableValuesCollector.Get
type OutputPatchableValuesCollectorMockGetParams struct {
	path string
}

// OutputPatchableValuesCollectorMockGetParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.Get
type OutputPatchableValuesCollectorMockGetParamPtrs struct {
	path *string
}

// OutputPatchableValuesCollectorMockGetResults contains results of the OutputPatchableValuesCollector.Get
type OutputPatchableValuesCollectorMockGetResults struct {
	r1 gjson.Result
}

// OutputPatchableValuesCollectorMockGetOrigins contains origins of expectations of the OutputPatchableValuesCollector.Get
type OutputPatchableValuesCollectorMockGetExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mOutputPatchableValuesCollectorMockGet) Optional() *mOutputPatchableValuesCollectorMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for OutputPatchableValuesCollector.Get
func (mmGet *mOutputPatchableValuesCollectorMockGet) Expect(path string) *mOutputPatchableValuesCollectorMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OutputPatchableValuesCollectorMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &OutputPatchableValuesCollectorMockGetParams{path}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectPathParam1 sets up expected param path for OutputPatchableValuesCollector.Get
func (mmGet *mOutputPatchableValuesCollectorMockGet) ExpectPathParam1(path string) *mOutputPatchableValuesCollectorMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OutputPatchableValuesCollectorMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.path = &path
	mmGet.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.Get
func (mmGet *mOutputPatchableValuesCollectorMockGet) Inspect(f func(path string)) *mOutputPatchableValuesCollectorMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.Get
func (mmGet *mOutputPatchableValuesCollectorMockGet) Return(r1 gjson.Result) *OutputPatchableValuesCollectorMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OutputPatchableValuesCollectorMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &OutputPatchableValuesCollectorMockGetResults{r1}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.Get method
func (mmGet *mOutputPatchableValuesCollectorMockGet) Set(f func(path string) (r1 gjson.Result)) *OutputPatchableValuesCollectorMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the OutputPatchableValuesCollector.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mOutputPatchableValuesCollectorMockGet) When(path string) *OutputPatchableValuesCollectorMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Get mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockGetExpectation{
		mock:               mmGet.mock,
		params:             &OutputPatchableValuesCollectorMockGetParams{path},
		expectationOrigins: OutputPatchableValuesCollectorMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.Get return parameters for the expectation previously defined by the When method
func (e *OutputPatchableValuesCollectorMockGetExpectation) Then(r1 gjson.Result) *OutputPatchableValuesCollectorMock {
	e.results = &OutputPatchableValuesCollectorMockGetResults{r1}
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.Get should be invoked
func (mmGet *mOutputPatchableValuesCollectorMockGet) Times(n uint64) *mOutputPatchableValuesCollectorMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mOutputPatchableValuesCollectorMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_pkg.OutputPatchableValuesCollector
func (mmGet *OutputPatchableValuesCollectorMock) Get(path string) (r1 gjson.Result) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(path)
	}

	mm_params := OutputPatchableValuesCollectorMockGetParams{path}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockGetParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmGet.t.Errorf("OutputPatchableValuesCollectorMock.Get got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("OutputPatchableValuesCollectorMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the OutputPatchableValuesCollectorMock.Get")
		}
		return (*mm_results).r1
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(path)
	}
	mmGet.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.Get. %v", path)
	return
}

// GetAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.Get invocations
func (mmGet *OutputPatchableValuesCollectorMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of OutputPatchableValuesCollectorMock.Get invocations
func (mmGet *OutputPatchableValuesCollectorMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mOutputPatchableValuesCollectorMockGet) Calls() []*OutputPatchableValuesCollectorMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mOutputPatchableValuesCollectorMockGetOk struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockGetOkExpectation
	expectations       []*OutputPatchableValuesCollectorMockGetOkExpectation

	callArgs []*OutputPatchableValuesCollectorMockGetOkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockGetOkExpectation specifies expectation struct of the OutputPatchableValuesCollector.GetOk
type OutputPatchableValuesCollectorMockGetOkExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockGetOkParams
	paramPtrs          *OutputPatchableValuesCollectorMockGetOkParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockGetOkExpectationOrigins
	results            *OutputPatchableValuesCollectorMockGetOkResults
	returnOrigin       string
	Counter            uint64
}

// OutputPatchableValuesCollectorMockGetOkParams contains parameters of the OutputPatchableValuesCollector.GetOk
type OutputPatchableValuesCollectorMockGetOkParams struct {
	path string
}

// OutputPatchableValuesCollectorMockGetOkParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.GetOk
type OutputPatchableValuesCollectorMockGetOkParamPtrs struct {
	path *string
}

// OutputPatchableValuesCollectorMockGetOkResults contains results of the OutputPatchableValuesCollector.GetOk
type OutputPatchableValuesCollectorMockGetOkResults struct {
	r1 gjson.Result
	b1 bool
}

// OutputPatchableValuesCollectorMockGetOkOrigins contains origins of expectations of the OutputPatchableValuesCollector.GetOk
type OutputPatchableValuesCollectorMockGetOkExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) Optional() *mOutputPatchableValuesCollectorMockGetOk {
	mmGetOk.optional = true
	return mmGetOk
}

// Expect sets up expected params for OutputPatchableValuesCollector.GetOk
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) Expect(path string) *mOutputPatchableValuesCollectorMockGetOk {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	if mmGetOk.defaultExpectation == nil {
		mmGetOk.defaultExpectation = &OutputPatchableValuesCollectorMockGetOkExpectation{}
	}

	if mmGetOk.defaultExpectation.paramPtrs != nil {
		mmGetOk.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetOk mock is already set by ExpectParams functions")
	}

	mmGetOk.defaultExpectation.params = &OutputPatchableValuesCollectorMockGetOkParams{path}
	mmGetOk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOk.expectations {
		if minimock.Equal(e.params, mmGetOk.defaultExpectation.params) {
			mmGetOk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOk.defaultExpectation.params)
		}
	}

	return mmGetOk
}

// ExpectPathParam1 sets up expected param path for OutputPatchableValuesCollector.GetOk
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) ExpectPathParam1(path string) *mOutputPatchableValuesCollectorMockGetOk {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	if mmGetOk.defaultExpectation == nil {
		mmGetOk.defaultExpectation = &OutputPatchableValuesCollectorMockGetOkExpectation{}
	}

	if mmGetOk.defaultExpectation.params != nil {
		mmGetOk.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetOk mock is already set by Expect")
	}

	if mmGetOk.defaultExpectation.paramPtrs == nil {
		mmGetOk.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockGetOkParamPtrs{}
	}
	mmGetOk.defaultExpectation.paramPtrs.path = &path
	mmGetOk.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmGetOk
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.GetOk
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) Inspect(f func(path string)) *mOutputPatchableValuesCollectorMockGetOk {
	if mmGetOk.mock.inspectFuncGetOk != nil {
		mmGetOk.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.GetOk")
	}

	mmGetOk.mock.inspectFuncGetOk = f

	return mmGetOk
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.GetOk
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) Return(r1 gjson.Result, b1 bool) *OutputPatchableValuesCollectorMock {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	if mmGetOk.defaultExpectation == nil {
		mmGetOk.defaultExpectation = &OutputPatchableValuesCollectorMockGetOkExpectation{mock: mmGetOk.mock}
	}
	mmGetOk.defaultExpectation.results = &OutputPatchableValuesCollectorMockGetOkResults{r1, b1}
	mmGetOk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOk.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.GetOk method
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) Set(f func(path string) (r1 gjson.Result, b1 bool)) *OutputPatchableValuesCollectorMock {
	if mmGetOk.defaultExpectation != nil {
		mmGetOk.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.GetOk method")
	}

	if len(mmGetOk.expectations) > 0 {
		mmGetOk.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.GetOk method")
	}

	mmGetOk.mock.funcGetOk = f
	mmGetOk.mock.funcGetOkOrigin = minimock.CallerInfo(1)
	return mmGetOk.mock
}

// When sets expectation for the OutputPatchableValuesCollector.GetOk which will trigger the result defined by the following
// Then helper
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) When(path string) *OutputPatchableValuesCollectorMockGetOkExpectation {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockGetOkExpectation{
		mock:               mmGetOk.mock,
		params:             &OutputPatchableValuesCollectorMockGetOkParams{path},
		expectationOrigins: OutputPatchableValuesCollectorMockGetOkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOk.expectations = append(mmGetOk.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.GetOk return parameters for the expectation previously defined by the When method
func (e *OutputPatchableValuesCollectorMockGetOkExpectation) Then(r1 gjson.Result, b1 bool) *OutputPatchableValuesCollectorMock {
	e.results = &OutputPatchableValuesCollectorMockGetOkResults{r1, b1}
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.GetOk should be invoked
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) Times(n uint64) *mOutputPatchableValuesCollectorMockGetOk {
	if n == 0 {
		mmGetOk.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.GetOk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOk.expectedInvocations, n)
	mmGetOk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOk
}

func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) invocationsDone() bool {
	if len(mmGetOk.expectations) == 0 && mmGetOk.defaultExpectation == nil && mmGetOk.mock.funcGetOk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOk.mock.afterGetOkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOk implements mm_pkg.OutputPatchableValuesCollector
func (mmGetOk *OutputPatchableValuesCollectorMock) GetOk(path string) (r1 gjson.Result, b1 bool) {
	mm_atomic.AddUint64(&mmGetOk.beforeGetOkCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOk.afterGetOkCounter, 1)

	mmGetOk.t.Helper()

	if mmGetOk.inspectFuncGetOk != nil {
		mmGetOk.inspectFuncGetOk(path)
	}

	mm_params := OutputPatchableValuesCollectorMockGetOkParams{path}

	// Record call args
	mmGetOk.GetOkMock.mutex.Lock()
	mmGetOk.GetOkMock.callArgs = append(mmGetOk.GetOkMock.callArgs, &mm_params)
	mmGetOk.GetOkMock.mutex.Unlock()

	for _, e := range mmGetOk.GetOkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.b1
		}
	}

	if mmGetOk.GetOkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOk.GetOkMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOk.GetOkMock.defaultExpectation.params
		mm_want_ptrs := mmGetOk.GetOkMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockGetOkParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmGetOk.t.Errorf("OutputPatchableValuesCollectorMock.GetOk got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOk.GetOkMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOk.t.Errorf("OutputPatchableValuesCollectorMock.GetOk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOk.GetOkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOk.GetOkMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOk.t.Fatal("No results are set for the OutputPatchableValuesCollectorMock.GetOk")
		}
		return (*mm_results).r1, (*mm_results).b1
	}
	if mmGetOk.funcGetOk != nil {
		return mmGetOk.funcGetOk(path)
	}
	mmGetOk.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.GetOk. %v", path)
	return
}

// GetOkAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.GetOk invocations
func (mmGetOk *OutputPatchableValuesCollectorMock) GetOkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOk.afterGetOkCounter)
}

// GetOkBeforeCounter returns a count of OutputPatchableValuesCollectorMock.GetOk invocations
func (mmGetOk *OutputPatchableValuesCollectorMock) GetOkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOk.beforeGetOkCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.GetOk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOk *mOutputPatchableValuesCollectorMockGetOk) Calls() []*OutputPatchableValuesCollectorMockGetOkParams {
	mmGetOk.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockGetOkParams, len(mmGetOk.callArgs))
	copy(argCopy, mmGetOk.callArgs)

	mmGetOk.mutex.RUnlock()

	return argCopy
}

// MinimockGetOkDone returns true if the count of the GetOk invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockGetOkDone() bool {
	if m.GetOkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOkMock.invocationsDone()
}

// MinimockGetOkInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockGetOkInspect() {
	for _, e := range m.GetOkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetOk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOkCounter := mm_atomic.LoadUint64(&m.afterGetOkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOkMock.defaultExpectation != nil && afterGetOkCounter < 1 {
		if m.GetOkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetOk at\n%s", m.GetOkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetOk at\n%s with params: %#v", m.GetOkMock.defaultExpectation.expectationOrigins.origin, *m.GetOkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOk != nil && afterGetOkCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetOk at\n%s", m.funcGetOkOrigin)
	}

	if !m.GetOkMock.invocationsDone() && afterGetOkCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.GetOk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOkMock.expectedInvocations), m.GetOkMock.expectedInvocationsOrigin, afterGetOkCounter)
	}
}

type mOutputPatchableValuesCollectorMockGetPatches struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockGetPatchesExpectation
	expectations       []*OutputPatchableValuesCollectorMockGetPatchesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockGetPatchesExpectation specifies expectation struct of the OutputPatchableValuesCollector.GetPatches
type OutputPatchableValuesCollectorMockGetPatchesExpectation struct {
	mock *OutputPatchableValuesCollectorMock

	results      *OutputPatchableValuesCollectorMockGetPatchesResults
	returnOrigin string
	Counter      uint64
}

// OutputPatchableValuesCollectorMockGetPatchesResults contains results of the OutputPatchableValuesCollector.GetPatches
type OutputPatchableValuesCollectorMockGetPatchesResults struct {
	vpa1 []*utils.ValuesPatchOperation
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPatches *mOutputPatchableValuesCollectorMockGetPatches) Optional() *mOutputPatchableValuesCollectorMockGetPatches {
	mmGetPatches.optional = true
	return mmGetPatches
}

// Expect sets up expected params for OutputPatchableValuesCollector.GetPatches
func (mmGetPatches *mOutputPatchableValuesCollectorMockGetPatches) Expect() *mOutputPatchableValuesCollectorMockGetPatches {
	if mmGetPatches.mock.funcGetPatches != nil {
		mmGetPatches.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetPatches mock is already set by Set")
	}

	if mmGetPatches.defaultExpectation == nil {
		mmGetPatches.defaultExpectation = &OutputPatchableValuesCollectorMockGetPatchesExpectation{}
	}

	return mmGetPatches
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.GetPatches
func (mmGetPatches *mOutputPatchableValuesCollectorMockGetPatches) Inspect(f func()) *mOutputPatchableValuesCollectorMockGetPatches {
	if mmGetPatches.mock.inspectFuncGetPatches != nil {
		mmGetPatches.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.GetPatches")
	}

	mmGetPatches.mock.inspectFuncGetPatches = f

	return mmGetPatches
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.GetPatches
func (mmGetPatches *mOutputPatchableValuesCollectorMockGetPatches) Return(vpa1 []*utils.ValuesPatchOperation) *OutputPatchableValuesCollectorMock {
	if mmGetPatches.mock.funcGetPatches != nil {
		mmGetPatches.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetPatches mock is already set by Set")
	}

	if mmGetPatches.defaultExpectation == nil {
		mmGetPatches.defaultExpectation = &OutputPatchableValuesCollectorMockGetPatchesExpectation{mock: mmGetPatches.mock}
	}
	mmGetPatches.defaultExpectation.results = &OutputPatchableValuesCollectorMockGetPatchesResults{vpa1}
	mmGetPatches.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPatches.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.GetPatches method
func (mmGetPatches *mOutputPatchableValuesCollectorMockGetPatches) Set(f func() (vpa1 []*utils.ValuesPatchOperation)) *OutputPatchableValuesCollectorMock {
	if mmGetPatches.defaultExpectation != nil {
		mmGetPatches.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.GetPatches method")
	}

	if len(mmGetPatches.expectations) > 0 {
		mmGetPatches.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.GetPatches method")
	}

	mmGetPatches.mock.funcGetPatches = f
	mmGetPatches.mock.funcGetPatchesOrigin = minimock.CallerInfo(1)
	return mmGetPatches.mock
}

// Times sets number of times OutputPatchableValuesCollector.GetPatches should be invoked
func (mmGetPatches *mOutputPatchableValuesCollectorMockGetPatches) Times(n uint64) *mOutputPatchableValuesCollectorMockGetPatches {
	if n == 0 {
		mmGetPatches.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.GetPatches mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPatches.expectedInvocations, n)
	mmGetPatches.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPatches
}

func (mmGetPatches *mOutputPatchableValuesCollectorMockGetPatches) invocationsDone() bool {
	if len(mmGetPatches.expectations) == 0 && mmGetPatches.defaultExpectation == nil && mmGetPatches.mock.funcGetPatches == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPatches.mock.afterGetPatchesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPatches.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPatches implements mm_pkg.OutputPatchableValuesCollector
func (mmGetPatches *OutputPatchableValuesCollectorMock) GetPatches() (vpa1 []*utils.ValuesPatchOperation) {
	mm_atomic.AddUint64(&mmGetPatches.beforeGetPatchesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPatches.afterGetPatchesCounter, 1)

	mmGetPatches.t.Helper()

	if mmGetPatches.inspectFuncGetPatches != nil {
		mmGetPatches.inspectFuncGetPatches()
	}

	if mmGetPatches.GetPatchesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPatches.GetPatchesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPatches.GetPatchesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPatches.t.Fatal("No results are set for the OutputPatchableValuesCollectorMock.GetPatches")
		}
		return (*mm_results).vpa1
	}
	if mmGetPatches.funcGetPatches != nil {
		return mmGetPatches.funcGetPatches()
	}
	mmGetPatches.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.GetPatches.")
	return
}

// GetPatchesAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.GetPatches invocations
func (mmGetPatches *OutputPatchableValuesCollectorMock) GetPatchesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPatches.afterGetPatchesCounter)
}

// GetPatchesBeforeCounter returns a count of OutputPatchableValuesCollectorMock.GetPatches invocations
func (mmGetPatches *OutputPatchableValuesCollectorMock) GetPatchesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPatches.beforeGetPatchesCounter)
}

// MinimockGetPatchesDone returns true if the count of the GetPatches invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockGetPatchesDone() bool {
	if m.GetPatchesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPatchesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPatchesMock.invocationsDone()
}

// MinimockGetPatchesInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockGetPatchesInspect() {
	for _, e := range m.GetPatchesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to OutputPatchableValuesCollectorMock.GetPatches")
		}
	}

	afterGetPatchesCounter := mm_atomic.LoadUint64(&m.afterGetPatchesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPatchesMock.defaultExpectation != nil && afterGetPatchesCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetPatches at\n%s", m.GetPatchesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPatches != nil && afterGetPatchesCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetPatches at\n%s", m.funcGetPatchesOrigin)
	}

	if !m.GetPatchesMock.invocationsDone() && afterGetPatchesCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.GetPatches at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPatchesMock.expectedInvocations), m.GetPatchesMock.expectedInvocationsOrigin, afterGetPatchesCounter)
	}
}

type mOutputPatchableValuesCollectorMockGetRaw struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockGetRawExpectation
	expectations       []*OutputPatchableValuesCollectorMockGetRawExpectation

	callArgs []*OutputPatchableValuesCollectorMockGetRawParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockGetRawExpectation specifies expectation struct of the OutputPatchableValuesCollector.GetRaw
type OutputPatchableValuesCollectorMockGetRawExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockGetRawParams
	paramPtrs          *OutputPatchableValuesCollectorMockGetRawParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockGetRawExpectationOrigins
	results            *OutputPatchableValuesCollectorMockGetRawResults
	returnOrigin       string
	Counter            uint64
}

// OutputPatchableValuesCollectorMockGetRawParams contains parameters of the OutputPatchableValuesCollector.GetRaw
type OutputPatchableValuesCollectorMockGetRawParams struct {
	path string
}

// OutputPatchableValuesCollectorMockGetRawParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.GetRaw
type OutputPatchableValuesCollectorMockGetRawParamPtrs struct {
	path *string
}

// OutputPatchableValuesCollectorMockGetRawResults contains results of the OutputPatchableValuesCollector.GetRaw
type OutputPatchableValuesCollectorMockGetRawResults struct {
	a1 any
}

// OutputPatchableValuesCollectorMockGetRawOrigins contains origins of expectations of the OutputPatchableValuesCollector.GetRaw
type OutputPatchableValuesCollectorMockGetRawExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) Optional() *mOutputPatchableValuesCollectorMockGetRaw {
	mmGetRaw.optional = true
	return mmGetRaw
}

// Expect sets up expected params for OutputPatchableValuesCollector.GetRaw
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) Expect(path string) *mOutputPatchableValuesCollectorMockGetRaw {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	if mmGetRaw.defaultExpectation == nil {
		mmGetRaw.defaultExpectation = &OutputPatchableValuesCollectorMockGetRawExpectation{}
	}

	if mmGetRaw.defaultExpectation.paramPtrs != nil {
		mmGetRaw.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetRaw mock is already set by ExpectParams functions")
	}

	mmGetRaw.defaultExpectation.params = &OutputPatchableValuesCollectorMockGetRawParams{path}
	mmGetRaw.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRaw.expectations {
		if minimock.Equal(e.params, mmGetRaw.defaultExpectation.params) {
			mmGetRaw.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRaw.defaultExpectation.params)
		}
	}

	return mmGetRaw
}

// ExpectPathParam1 sets up expected param path for OutputPatchableValuesCollector.GetRaw
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) ExpectPathParam1(path string) *mOutputPatchableValuesCollectorMockGetRaw {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	if mmGetRaw.defaultExpectation == nil {
		mmGetRaw.defaultExpectation = &OutputPatchableValuesCollectorMockGetRawExpectation{}
	}

	if mmGetRaw.defaultExpectation.params != nil {
		mmGetRaw.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetRaw mock is already set by Expect")
	}

	if mmGetRaw.defaultExpectation.paramPtrs == nil {
		mmGetRaw.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockGetRawParamPtrs{}
	}
	mmGetRaw.defaultExpectation.paramPtrs.path = &path
	mmGetRaw.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmGetRaw
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.GetRaw
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) Inspect(f func(path string)) *mOutputPatchableValuesCollectorMockGetRaw {
	if mmGetRaw.mock.inspectFuncGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.GetRaw")
	}

	mmGetRaw.mock.inspectFuncGetRaw = f

	return mmGetRaw
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.GetRaw
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) Return(a1 any) *OutputPatchableValuesCollectorMock {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	if mmGetRaw.defaultExpectation == nil {
		mmGetRaw.defaultExpectation = &OutputPatchableValuesCollectorMockGetRawExpectation{mock: mmGetRaw.mock}
	}
	mmGetRaw.defaultExpectation.results = &OutputPatchableValuesCollectorMockGetRawResults{a1}
	mmGetRaw.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRaw.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.GetRaw method
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) Set(f func(path string) (a1 any)) *OutputPatchableValuesCollectorMock {
	if mmGetRaw.defaultExpectation != nil {
		mmGetRaw.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.GetRaw method")
	}

	if len(mmGetRaw.expectations) > 0 {
		mmGetRaw.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.GetRaw method")
	}

	mmGetRaw.mock.funcGetRaw = f
	mmGetRaw.mock.funcGetRawOrigin = minimock.CallerInfo(1)
	return mmGetRaw.mock
}

// When sets expectation for the OutputPatchableValuesCollector.GetRaw which will trigger the result defined by the following
// Then helper
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) When(path string) *OutputPatchableValuesCollectorMockGetRawExpectation {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("OutputPatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockGetRawExpectation{
		mock:               mmGetRaw.mock,
		params:             &OutputPatchableValuesCollectorMockGetRawParams{path},
		expectationOrigins: OutputPatchableValuesCollectorMockGetRawExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRaw.expectations = append(mmGetRaw.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.GetRaw return parameters for the expectation previously defined by the When method
func (e *OutputPatchableValuesCollectorMockGetRawExpectation) Then(a1 any) *OutputPatchableValuesCollectorMock {
	e.results = &OutputPatchableValuesCollectorMockGetRawResults{a1}
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.GetRaw should be invoked
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) Times(n uint64) *mOutputPatchableValuesCollectorMockGetRaw {
	if n == 0 {
		mmGetRaw.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.GetRaw mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRaw.expectedInvocations, n)
	mmGetRaw.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRaw
}

func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) invocationsDone() bool {
	if len(mmGetRaw.expectations) == 0 && mmGetRaw.defaultExpectation == nil && mmGetRaw.mock.funcGetRaw == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRaw.mock.afterGetRawCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRaw.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRaw implements mm_pkg.OutputPatchableValuesCollector
func (mmGetRaw *OutputPatchableValuesCollectorMock) GetRaw(path string) (a1 any) {
	mm_atomic.AddUint64(&mmGetRaw.beforeGetRawCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRaw.afterGetRawCounter, 1)

	mmGetRaw.t.Helper()

	if mmGetRaw.inspectFuncGetRaw != nil {
		mmGetRaw.inspectFuncGetRaw(path)
	}

	mm_params := OutputPatchableValuesCollectorMockGetRawParams{path}

	// Record call args
	mmGetRaw.GetRawMock.mutex.Lock()
	mmGetRaw.GetRawMock.callArgs = append(mmGetRaw.GetRawMock.callArgs, &mm_params)
	mmGetRaw.GetRawMock.mutex.Unlock()

	for _, e := range mmGetRaw.GetRawMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1
		}
	}

	if mmGetRaw.GetRawMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRaw.GetRawMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRaw.GetRawMock.defaultExpectation.params
		mm_want_ptrs := mmGetRaw.GetRawMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockGetRawParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmGetRaw.t.Errorf("OutputPatchableValuesCollectorMock.GetRaw got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRaw.GetRawMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRaw.t.Errorf("OutputPatchableValuesCollectorMock.GetRaw got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRaw.GetRawMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRaw.GetRawMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRaw.t.Fatal("No results are set for the OutputPatchableValuesCollectorMock.GetRaw")
		}
		return (*mm_results).a1
	}
	if mmGetRaw.funcGetRaw != nil {
		return mmGetRaw.funcGetRaw(path)
	}
	mmGetRaw.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.GetRaw. %v", path)
	return
}

// GetRawAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.GetRaw invocations
func (mmGetRaw *OutputPatchableValuesCollectorMock) GetRawAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRaw.afterGetRawCounter)
}

// GetRawBeforeCounter returns a count of OutputPatchableValuesCollectorMock.GetRaw invocations
func (mmGetRaw *OutputPatchableValuesCollectorMock) GetRawBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRaw.beforeGetRawCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.GetRaw.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRaw *mOutputPatchableValuesCollectorMockGetRaw) Calls() []*OutputPatchableValuesCollectorMockGetRawParams {
	mmGetRaw.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockGetRawParams, len(mmGetRaw.callArgs))
	copy(argCopy, mmGetRaw.callArgs)

	mmGetRaw.mutex.RUnlock()

	return argCopy
}

// MinimockGetRawDone returns true if the count of the GetRaw invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockGetRawDone() bool {
	if m.GetRawMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRawMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRawMock.invocationsDone()
}

// MinimockGetRawInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockGetRawInspect() {
	for _, e := range m.GetRawMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetRaw at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRawCounter := mm_atomic.LoadUint64(&m.afterGetRawCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRawMock.defaultExpectation != nil && afterGetRawCounter < 1 {
		if m.GetRawMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetRaw at\n%s", m.GetRawMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetRaw at\n%s with params: %#v", m.GetRawMock.defaultExpectation.expectationOrigins.origin, *m.GetRawMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRaw != nil && afterGetRawCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.GetRaw at\n%s", m.funcGetRawOrigin)
	}

	if !m.GetRawMock.invocationsDone() && afterGetRawCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.GetRaw at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRawMock.expectedInvocations), m.GetRawMock.expectedInvocationsOrigin, afterGetRawCounter)
	}
}

type mOutputPatchableValuesCollectorMockRemove struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockRemoveExpectation
	expectations       []*OutputPatchableValuesCollectorMockRemoveExpectation

	callArgs []*OutputPatchableValuesCollectorMockRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockRemoveExpectation specifies expectation struct of the OutputPatchableValuesCollector.Remove
type OutputPatchableValuesCollectorMockRemoveExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockRemoveParams
	paramPtrs          *OutputPatchableValuesCollectorMockRemoveParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockRemoveExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// OutputPatchableValuesCollectorMockRemoveParams contains parameters of the OutputPatchableValuesCollector.Remove
type OutputPatchableValuesCollectorMockRemoveParams struct {
	path string
}

// OutputPatchableValuesCollectorMockRemoveParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.Remove
type OutputPatchableValuesCollectorMockRemoveParamPtrs struct {
	path *string
}

// OutputPatchableValuesCollectorMockRemoveOrigins contains origins of expectations of the OutputPatchableValuesCollector.Remove
type OutputPatchableValuesCollectorMockRemoveExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) Optional() *mOutputPatchableValuesCollectorMockRemove {
	mmRemove.optional = true
	return mmRemove
}

// Expect sets up expected params for OutputPatchableValuesCollector.Remove
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) Expect(path string) *mOutputPatchableValuesCollectorMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &OutputPatchableValuesCollectorMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.paramPtrs != nil {
		mmRemove.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Remove mock is already set by ExpectParams functions")
	}

	mmRemove.defaultExpectation.params = &OutputPatchableValuesCollectorMockRemoveParams{path}
	mmRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// ExpectPathParam1 sets up expected param path for OutputPatchableValuesCollector.Remove
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) ExpectPathParam1(path string) *mOutputPatchableValuesCollectorMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &OutputPatchableValuesCollectorMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.path = &path
	mmRemove.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.Remove
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) Inspect(f func(path string)) *mOutputPatchableValuesCollectorMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.Remove
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) Return() *OutputPatchableValuesCollectorMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &OutputPatchableValuesCollectorMockRemoveExpectation{mock: mmRemove.mock}
	}

	mmRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.Remove method
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) Set(f func(path string)) *OutputPatchableValuesCollectorMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.Remove method")
	}

	mmRemove.mock.funcRemove = f
	mmRemove.mock.funcRemoveOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// When sets expectation for the OutputPatchableValuesCollector.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) When(path string) *OutputPatchableValuesCollectorMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockRemoveExpectation{
		mock:               mmRemove.mock,
		params:             &OutputPatchableValuesCollectorMockRemoveParams{path},
		expectationOrigins: OutputPatchableValuesCollectorMockRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.Remove return parameters for the expectation previously defined by the When method

func (e *OutputPatchableValuesCollectorMockRemoveExpectation) Then() *OutputPatchableValuesCollectorMock {
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.Remove should be invoked
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) Times(n uint64) *mOutputPatchableValuesCollectorMockRemove {
	if n == 0 {
		mmRemove.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.Remove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemove.expectedInvocations, n)
	mmRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemove
}

func (mmRemove *mOutputPatchableValuesCollectorMockRemove) invocationsDone() bool {
	if len(mmRemove.expectations) == 0 && mmRemove.defaultExpectation == nil && mmRemove.mock.funcRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemove.mock.afterRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Remove implements mm_pkg.OutputPatchableValuesCollector
func (mmRemove *OutputPatchableValuesCollectorMock) Remove(path string) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	mmRemove.t.Helper()

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(path)
	}

	mm_params := OutputPatchableValuesCollectorMockRemoveParams{path}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, &mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_want_ptrs := mmRemove.RemoveMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockRemoveParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmRemove.t.Errorf("OutputPatchableValuesCollectorMock.Remove got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("OutputPatchableValuesCollectorMock.Remove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemove.RemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRemove.funcRemove != nil {
		mmRemove.funcRemove(path)
		return
	}
	mmRemove.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.Remove. %v", path)

}

// RemoveAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.Remove invocations
func (mmRemove *OutputPatchableValuesCollectorMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of OutputPatchableValuesCollectorMock.Remove invocations
func (mmRemove *OutputPatchableValuesCollectorMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mOutputPatchableValuesCollectorMockRemove) Calls() []*OutputPatchableValuesCollectorMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockRemoveDone() bool {
	if m.RemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveMock.invocationsDone()
}

// MinimockRemoveInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Remove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCounter := mm_atomic.LoadUint64(&m.afterRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && afterRemoveCounter < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Remove at\n%s", m.RemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Remove at\n%s with params: %#v", m.RemoveMock.defaultExpectation.expectationOrigins.origin, *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && afterRemoveCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Remove at\n%s", m.funcRemoveOrigin)
	}

	if !m.RemoveMock.invocationsDone() && afterRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.Remove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveMock.expectedInvocations), m.RemoveMock.expectedInvocationsOrigin, afterRemoveCounter)
	}
}

type mOutputPatchableValuesCollectorMockSet struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockSetExpectation
	expectations       []*OutputPatchableValuesCollectorMockSetExpectation

	callArgs []*OutputPatchableValuesCollectorMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockSetExpectation specifies expectation struct of the OutputPatchableValuesCollector.Set
type OutputPatchableValuesCollectorMockSetExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockSetParams
	paramPtrs          *OutputPatchableValuesCollectorMockSetParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// OutputPatchableValuesCollectorMockSetParams contains parameters of the OutputPatchableValuesCollector.Set
type OutputPatchableValuesCollectorMockSetParams struct {
	path  string
	value any
}

// OutputPatchableValuesCollectorMockSetParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.Set
type OutputPatchableValuesCollectorMockSetParamPtrs struct {
	path  *string
	value *any
}

// OutputPatchableValuesCollectorMockSetOrigins contains origins of expectations of the OutputPatchableValuesCollector.Set
type OutputPatchableValuesCollectorMockSetExpectationOrigins struct {
	origin      string
	originPath  string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mOutputPatchableValuesCollectorMockSet) Optional() *mOutputPatchableValuesCollectorMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for OutputPatchableValuesCollector.Set
func (mmSet *mOutputPatchableValuesCollectorMockSet) Expect(path string, value any) *mOutputPatchableValuesCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &OutputPatchableValuesCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &OutputPatchableValuesCollectorMockSetParams{path, value}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectPathParam1 sets up expected param path for OutputPatchableValuesCollector.Set
func (mmSet *mOutputPatchableValuesCollectorMockSet) ExpectPathParam1(path string) *mOutputPatchableValuesCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &OutputPatchableValuesCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.path = &path
	mmSet.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmSet
}

// ExpectValueParam2 sets up expected param value for OutputPatchableValuesCollector.Set
func (mmSet *mOutputPatchableValuesCollectorMockSet) ExpectValueParam2(value any) *mOutputPatchableValuesCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &OutputPatchableValuesCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value
	mmSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.Set
func (mmSet *mOutputPatchableValuesCollectorMockSet) Inspect(f func(path string, value any)) *mOutputPatchableValuesCollectorMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.Set
func (mmSet *mOutputPatchableValuesCollectorMockSet) Return() *OutputPatchableValuesCollectorMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &OutputPatchableValuesCollectorMockSetExpectation{mock: mmSet.mock}
	}

	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.Set method
func (mmSet *mOutputPatchableValuesCollectorMockSet) Set(f func(path string, value any)) *OutputPatchableValuesCollectorMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the OutputPatchableValuesCollector.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mOutputPatchableValuesCollectorMockSet) When(path string, value any) *OutputPatchableValuesCollectorMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("OutputPatchableValuesCollectorMock.Set mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockSetExpectation{
		mock:               mmSet.mock,
		params:             &OutputPatchableValuesCollectorMockSetParams{path, value},
		expectationOrigins: OutputPatchableValuesCollectorMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.Set return parameters for the expectation previously defined by the When method

func (e *OutputPatchableValuesCollectorMockSetExpectation) Then() *OutputPatchableValuesCollectorMock {
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.Set should be invoked
func (mmSet *mOutputPatchableValuesCollectorMockSet) Times(n uint64) *mOutputPatchableValuesCollectorMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mOutputPatchableValuesCollectorMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_pkg.OutputPatchableValuesCollector
func (mmSet *OutputPatchableValuesCollectorMock) Set(path string, value any) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(path, value)
	}

	mm_params := OutputPatchableValuesCollectorMockSetParams{path, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockSetParams{path, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmSet.t.Errorf("OutputPatchableValuesCollectorMock.Set got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("OutputPatchableValuesCollectorMock.Set got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("OutputPatchableValuesCollectorMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSet.funcSet != nil {
		mmSet.funcSet(path, value)
		return
	}
	mmSet.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.Set. %v %v", path, value)

}

// SetAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.Set invocations
func (mmSet *OutputPatchableValuesCollectorMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of OutputPatchableValuesCollectorMock.Set invocations
func (mmSet *OutputPatchableValuesCollectorMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mOutputPatchableValuesCollectorMockSet) Calls() []*OutputPatchableValuesCollectorMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

type mOutputPatchableValuesCollectorMockWriteOutput struct {
	optional           bool
	mock               *OutputPatchableValuesCollectorMock
	defaultExpectation *OutputPatchableValuesCollectorMockWriteOutputExpectation
	expectations       []*OutputPatchableValuesCollectorMockWriteOutputExpectation

	callArgs []*OutputPatchableValuesCollectorMockWriteOutputParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputPatchableValuesCollectorMockWriteOutputExpectation specifies expectation struct of the OutputPatchableValuesCollector.WriteOutput
type OutputPatchableValuesCollectorMockWriteOutputExpectation struct {
	mock               *OutputPatchableValuesCollectorMock
	params             *OutputPatchableValuesCollectorMockWriteOutputParams
	paramPtrs          *OutputPatchableValuesCollectorMockWriteOutputParamPtrs
	expectationOrigins OutputPatchableValuesCollectorMockWriteOutputExpectationOrigins
	results            *OutputPatchableValuesCollectorMockWriteOutputResults
	returnOrigin       string
	Counter            uint64
}

// OutputPatchableValuesCollectorMockWriteOutputParams contains parameters of the OutputPatchableValuesCollector.WriteOutput
type OutputPatchableValuesCollectorMockWriteOutputParams struct {
	writer io.Writer
}

// OutputPatchableValuesCollectorMockWriteOutputParamPtrs contains pointers to parameters of the OutputPatchableValuesCollector.WriteOutput
type OutputPatchableValuesCollectorMockWriteOutputParamPtrs struct {
	writer *io.Writer
}

// OutputPatchableValuesCollectorMockWriteOutputResults contains results of the OutputPatchableValuesCollector.WriteOutput
type OutputPatchableValuesCollectorMockWriteOutputResults struct {
	err error
}

// OutputPatchableValuesCollectorMockWriteOutputOrigins contains origins of expectations of the OutputPatchableValuesCollector.WriteOutput
type OutputPatchableValuesCollectorMockWriteOutputExpectationOrigins struct {
	origin       string
	originWriter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) Optional() *mOutputPatchableValuesCollectorMockWriteOutput {
	mmWriteOutput.optional = true
	return mmWriteOutput
}

// Expect sets up expected params for OutputPatchableValuesCollector.WriteOutput
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) Expect(writer io.Writer) *mOutputPatchableValuesCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("OutputPatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &OutputPatchableValuesCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.paramPtrs != nil {
		mmWriteOutput.mock.t.Fatalf("OutputPatchableValuesCollectorMock.WriteOutput mock is already set by ExpectParams functions")
	}

	mmWriteOutput.defaultExpectation.params = &OutputPatchableValuesCollectorMockWriteOutputParams{writer}
	mmWriteOutput.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWriteOutput.expectations {
		if minimock.Equal(e.params, mmWriteOutput.defaultExpectation.params) {
			mmWriteOutput.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteOutput.defaultExpectation.params)
		}
	}

	return mmWriteOutput
}

// ExpectWriterParam1 sets up expected param writer for OutputPatchableValuesCollector.WriteOutput
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) ExpectWriterParam1(writer io.Writer) *mOutputPatchableValuesCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("OutputPatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &OutputPatchableValuesCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.params != nil {
		mmWriteOutput.mock.t.Fatalf("OutputPatchableValuesCollectorMock.WriteOutput mock is already set by Expect")
	}

	if mmWriteOutput.defaultExpectation.paramPtrs == nil {
		mmWriteOutput.defaultExpectation.paramPtrs = &OutputPatchableValuesCollectorMockWriteOutputParamPtrs{}
	}
	mmWriteOutput.defaultExpectation.paramPtrs.writer = &writer
	mmWriteOutput.defaultExpectation.expectationOrigins.originWriter = minimock.CallerInfo(1)

	return mmWriteOutput
}

// Inspect accepts an inspector function that has same arguments as the OutputPatchableValuesCollector.WriteOutput
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) Inspect(f func(writer io.Writer)) *mOutputPatchableValuesCollectorMockWriteOutput {
	if mmWriteOutput.mock.inspectFuncWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("Inspect function is already set for OutputPatchableValuesCollectorMock.WriteOutput")
	}

	mmWriteOutput.mock.inspectFuncWriteOutput = f

	return mmWriteOutput
}

// Return sets up results that will be returned by OutputPatchableValuesCollector.WriteOutput
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) Return(err error) *OutputPatchableValuesCollectorMock {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("OutputPatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &OutputPatchableValuesCollectorMockWriteOutputExpectation{mock: mmWriteOutput.mock}
	}
	mmWriteOutput.defaultExpectation.results = &OutputPatchableValuesCollectorMockWriteOutputResults{err}
	mmWriteOutput.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// Set uses given function f to mock the OutputPatchableValuesCollector.WriteOutput method
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) Set(f func(writer io.Writer) (err error)) *OutputPatchableValuesCollectorMock {
	if mmWriteOutput.defaultExpectation != nil {
		mmWriteOutput.mock.t.Fatalf("Default expectation is already set for the OutputPatchableValuesCollector.WriteOutput method")
	}

	if len(mmWriteOutput.expectations) > 0 {
		mmWriteOutput.mock.t.Fatalf("Some expectations are already set for the OutputPatchableValuesCollector.WriteOutput method")
	}

	mmWriteOutput.mock.funcWriteOutput = f
	mmWriteOutput.mock.funcWriteOutputOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// When sets expectation for the OutputPatchableValuesCollector.WriteOutput which will trigger the result defined by the following
// Then helper
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) When(writer io.Writer) *OutputPatchableValuesCollectorMockWriteOutputExpectation {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("OutputPatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	expectation := &OutputPatchableValuesCollectorMockWriteOutputExpectation{
		mock:               mmWriteOutput.mock,
		params:             &OutputPatchableValuesCollectorMockWriteOutputParams{writer},
		expectationOrigins: OutputPatchableValuesCollectorMockWriteOutputExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWriteOutput.expectations = append(mmWriteOutput.expectations, expectation)
	return expectation
}

// Then sets up OutputPatchableValuesCollector.WriteOutput return parameters for the expectation previously defined by the When method
func (e *OutputPatchableValuesCollectorMockWriteOutputExpectation) Then(err error) *OutputPatchableValuesCollectorMock {
	e.results = &OutputPatchableValuesCollectorMockWriteOutputResults{err}
	return e.mock
}

// Times sets number of times OutputPatchableValuesCollector.WriteOutput should be invoked
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) Times(n uint64) *mOutputPatchableValuesCollectorMockWriteOutput {
	if n == 0 {
		mmWriteOutput.mock.t.Fatalf("Times of OutputPatchableValuesCollectorMock.WriteOutput mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteOutput.expectedInvocations, n)
	mmWriteOutput.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWriteOutput
}

func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) invocationsDone() bool {
	if len(mmWriteOutput.expectations) == 0 && mmWriteOutput.defaultExpectation == nil && mmWriteOutput.mock.funcWriteOutput == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteOutput.mock.afterWriteOutputCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteOutput.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteOutput implements mm_pkg.OutputPatchableValuesCollector
func (mmWriteOutput *OutputPatchableValuesCollectorMock) WriteOutput(writer io.Writer) (err error) {
	mm_atomic.AddUint64(&mmWriteOutput.beforeWriteOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteOutput.afterWriteOutputCounter, 1)

	mmWriteOutput.t.Helper()

	if mmWriteOutput.inspectFuncWriteOutput != nil {
		mmWriteOutput.inspectFuncWriteOutput(writer)
	}

	mm_params := OutputPatchableValuesCollectorMockWriteOutputParams{writer}

	// Record call args
	mmWriteOutput.WriteOutputMock.mutex.Lock()
	mmWriteOutput.WriteOutputMock.callArgs = append(mmWriteOutput.WriteOutputMock.callArgs, &mm_params)
	mmWriteOutput.WriteOutputMock.mutex.Unlock()

	for _, e := range mmWriteOutput.WriteOutputMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWriteOutput.WriteOutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteOutput.WriteOutputMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteOutput.WriteOutputMock.defaultExpectation.params
		mm_want_ptrs := mmWriteOutput.WriteOutputMock.defaultExpectation.paramPtrs

		mm_got := OutputPatchableValuesCollectorMockWriteOutputParams{writer}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.writer != nil && !minimock.Equal(*mm_want_ptrs.writer, mm_got.writer) {
				mmWriteOutput.t.Errorf("OutputPatchableValuesCollectorMock.WriteOutput got unexpected parameter writer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.originWriter, *mm_want_ptrs.writer, mm_got.writer, minimock.Diff(*mm_want_ptrs.writer, mm_got.writer))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteOutput.t.Errorf("OutputPatchableValuesCollectorMock.WriteOutput got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteOutput.WriteOutputMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteOutput.t.Fatal("No results are set for the OutputPatchableValuesCollectorMock.WriteOutput")
		}
		return (*mm_results).err
	}
	if mmWriteOutput.funcWriteOutput != nil {
		return mmWriteOutput.funcWriteOutput(writer)
	}
	mmWriteOutput.t.Fatalf("Unexpected call to OutputPatchableValuesCollectorMock.WriteOutput. %v", writer)
	return
}

// WriteOutputAfterCounter returns a count of finished OutputPatchableValuesCollectorMock.WriteOutput invocations
func (mmWriteOutput *OutputPatchableValuesCollectorMock) WriteOutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.afterWriteOutputCounter)
}

// WriteOutputBeforeCounter returns a count of OutputPatchableValuesCollectorMock.WriteOutput invocations
func (mmWriteOutput *OutputPatchableValuesCollectorMock) WriteOutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.beforeWriteOutputCounter)
}

// Calls returns a list of arguments used in each call to OutputPatchableValuesCollectorMock.WriteOutput.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteOutput *mOutputPatchableValuesCollectorMockWriteOutput) Calls() []*OutputPatchableValuesCollectorMockWriteOutputParams {
	mmWriteOutput.mutex.RLock()

	argCopy := make([]*OutputPatchableValuesCollectorMockWriteOutputParams, len(mmWriteOutput.callArgs))
	copy(argCopy, mmWriteOutput.callArgs)

	mmWriteOutput.mutex.RUnlock()

	return argCopy
}

// MinimockWriteOutputDone returns true if the count of the WriteOutput invocations corresponds
// the number of defined expectations
func (m *OutputPatchableValuesCollectorMock) MinimockWriteOutputDone() bool {
	if m.WriteOutputMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteOutputMock.invocationsDone()
}

// MinimockWriteOutputInspect logs each unmet expectation
func (m *OutputPatchableValuesCollectorMock) MinimockWriteOutputInspect() {
	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.WriteOutput at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWriteOutputCounter := mm_atomic.LoadUint64(&m.afterWriteOutputCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteOutputMock.defaultExpectation != nil && afterWriteOutputCounter < 1 {
		if m.WriteOutputMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.WriteOutput at\n%s", m.WriteOutputMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.WriteOutput at\n%s with params: %#v", m.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *m.WriteOutputMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteOutput != nil && afterWriteOutputCounter < 1 {
		m.t.Errorf("Expected call to OutputPatchableValuesCollectorMock.WriteOutput at\n%s", m.funcWriteOutputOrigin)
	}

	if !m.WriteOutputMock.invocationsDone() && afterWriteOutputCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputPatchableValuesCollectorMock.WriteOutput at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteOutputMock.expectedInvocations), m.WriteOutputMock.expectedInvocationsOrigin, afterWriteOutputCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OutputPatchableValuesCollectorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockArrayCountInspect()

			m.MinimockExistsInspect()

			m.MinimockGetInspect()

			m.MinimockGetOkInspect()

			m.MinimockGetPatchesInspect()

			m.MinimockGetRawInspect()

			m.MinimockRemoveInspect()

			m.MinimockSetInspect()

			m.MinimockWriteOutputInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OutputPatchableValuesCollectorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OutputPatchableValuesCollectorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArrayCountDone() &&
		m.MinimockExistsDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetOkDone() &&
		m.MinimockGetPatchesDone() &&
		m.MinimockGetRawDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockSetDone() &&
		m.MinimockWriteOutputDone()
}
