// Code generated by http://github.com/gojuno/minimock ((devel)). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.DependencyContainer -o dependency_container_mock.go -n DependencyContainerMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/module-sdk/pkg"
	"github.com/gojuno/minimock/v3"
	"github.com/jonboulle/clockwork"
	"k8s.io/client-go/rest"
)

// DependencyContainerMock implements mm_pkg.DependencyContainer
type DependencyContainerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetClientConfig          func() (cp1 *rest.Config, err error)
	funcGetClientConfigOrigin    string
	inspectFuncGetClientConfig   func()
	afterGetClientConfigCounter  uint64
	beforeGetClientConfigCounter uint64
	GetClientConfigMock          mDependencyContainerMockGetClientConfig

	funcGetClock          func() (c1 clockwork.Clock)
	funcGetClockOrigin    string
	inspectFuncGetClock   func()
	afterGetClockCounter  uint64
	beforeGetClockCounter uint64
	GetClockMock          mDependencyContainerMockGetClock

	funcGetHTTPClient          func(options ...mm_pkg.HTTPOption) (h1 mm_pkg.HTTPClient)
	funcGetHTTPClientOrigin    string
	inspectFuncGetHTTPClient   func(options ...mm_pkg.HTTPOption)
	afterGetHTTPClientCounter  uint64
	beforeGetHTTPClientCounter uint64
	GetHTTPClientMock          mDependencyContainerMockGetHTTPClient

	funcGetK8sClient          func(options ...mm_pkg.KubernetesOption) (k1 mm_pkg.KubernetesClient, err error)
	funcGetK8sClientOrigin    string
	inspectFuncGetK8sClient   func(options ...mm_pkg.KubernetesOption)
	afterGetK8sClientCounter  uint64
	beforeGetK8sClientCounter uint64
	GetK8sClientMock          mDependencyContainerMockGetK8sClient

	funcGetRegistryClient          func(repo string, options ...mm_pkg.RegistryOption) (r1 mm_pkg.RegistryClient, err error)
	funcGetRegistryClientOrigin    string
	inspectFuncGetRegistryClient   func(repo string, options ...mm_pkg.RegistryOption)
	afterGetRegistryClientCounter  uint64
	beforeGetRegistryClientCounter uint64
	GetRegistryClientMock          mDependencyContainerMockGetRegistryClient

	funcMustGetK8sClient          func(options ...mm_pkg.KubernetesOption) (k1 mm_pkg.KubernetesClient)
	funcMustGetK8sClientOrigin    string
	inspectFuncMustGetK8sClient   func(options ...mm_pkg.KubernetesOption)
	afterMustGetK8sClientCounter  uint64
	beforeMustGetK8sClientCounter uint64
	MustGetK8sClientMock          mDependencyContainerMockMustGetK8sClient

	funcMustGetRegistryClient          func(repo string, options ...mm_pkg.RegistryOption) (r1 mm_pkg.RegistryClient)
	funcMustGetRegistryClientOrigin    string
	inspectFuncMustGetRegistryClient   func(repo string, options ...mm_pkg.RegistryOption)
	afterMustGetRegistryClientCounter  uint64
	beforeMustGetRegistryClientCounter uint64
	MustGetRegistryClientMock          mDependencyContainerMockMustGetRegistryClient
}

// NewDependencyContainerMock returns a mock for mm_pkg.DependencyContainer
func NewDependencyContainerMock(t minimock.Tester) *DependencyContainerMock {
	m := &DependencyContainerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetClientConfigMock = mDependencyContainerMockGetClientConfig{mock: m}

	m.GetClockMock = mDependencyContainerMockGetClock{mock: m}

	m.GetHTTPClientMock = mDependencyContainerMockGetHTTPClient{mock: m}
	m.GetHTTPClientMock.callArgs = []*DependencyContainerMockGetHTTPClientParams{}

	m.GetK8sClientMock = mDependencyContainerMockGetK8sClient{mock: m}
	m.GetK8sClientMock.callArgs = []*DependencyContainerMockGetK8sClientParams{}

	m.GetRegistryClientMock = mDependencyContainerMockGetRegistryClient{mock: m}
	m.GetRegistryClientMock.callArgs = []*DependencyContainerMockGetRegistryClientParams{}

	m.MustGetK8sClientMock = mDependencyContainerMockMustGetK8sClient{mock: m}
	m.MustGetK8sClientMock.callArgs = []*DependencyContainerMockMustGetK8sClientParams{}

	m.MustGetRegistryClientMock = mDependencyContainerMockMustGetRegistryClient{mock: m}
	m.MustGetRegistryClientMock.callArgs = []*DependencyContainerMockMustGetRegistryClientParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDependencyContainerMockGetClientConfig struct {
	optional           bool
	mock               *DependencyContainerMock
	defaultExpectation *DependencyContainerMockGetClientConfigExpectation
	expectations       []*DependencyContainerMockGetClientConfigExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DependencyContainerMockGetClientConfigExpectation specifies expectation struct of the DependencyContainer.GetClientConfig
type DependencyContainerMockGetClientConfigExpectation struct {
	mock *DependencyContainerMock

	results      *DependencyContainerMockGetClientConfigResults
	returnOrigin string
	Counter      uint64
}

// DependencyContainerMockGetClientConfigResults contains results of the DependencyContainer.GetClientConfig
type DependencyContainerMockGetClientConfigResults struct {
	cp1 *rest.Config
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClientConfig *mDependencyContainerMockGetClientConfig) Optional() *mDependencyContainerMockGetClientConfig {
	mmGetClientConfig.optional = true
	return mmGetClientConfig
}

// Expect sets up expected params for DependencyContainer.GetClientConfig
func (mmGetClientConfig *mDependencyContainerMockGetClientConfig) Expect() *mDependencyContainerMockGetClientConfig {
	if mmGetClientConfig.mock.funcGetClientConfig != nil {
		mmGetClientConfig.mock.t.Fatalf("DependencyContainerMock.GetClientConfig mock is already set by Set")
	}

	if mmGetClientConfig.defaultExpectation == nil {
		mmGetClientConfig.defaultExpectation = &DependencyContainerMockGetClientConfigExpectation{}
	}

	return mmGetClientConfig
}

// Inspect accepts an inspector function that has same arguments as the DependencyContainer.GetClientConfig
func (mmGetClientConfig *mDependencyContainerMockGetClientConfig) Inspect(f func()) *mDependencyContainerMockGetClientConfig {
	if mmGetClientConfig.mock.inspectFuncGetClientConfig != nil {
		mmGetClientConfig.mock.t.Fatalf("Inspect function is already set for DependencyContainerMock.GetClientConfig")
	}

	mmGetClientConfig.mock.inspectFuncGetClientConfig = f

	return mmGetClientConfig
}

// Return sets up results that will be returned by DependencyContainer.GetClientConfig
func (mmGetClientConfig *mDependencyContainerMockGetClientConfig) Return(cp1 *rest.Config, err error) *DependencyContainerMock {
	if mmGetClientConfig.mock.funcGetClientConfig != nil {
		mmGetClientConfig.mock.t.Fatalf("DependencyContainerMock.GetClientConfig mock is already set by Set")
	}

	if mmGetClientConfig.defaultExpectation == nil {
		mmGetClientConfig.defaultExpectation = &DependencyContainerMockGetClientConfigExpectation{mock: mmGetClientConfig.mock}
	}
	mmGetClientConfig.defaultExpectation.results = &DependencyContainerMockGetClientConfigResults{cp1, err}
	mmGetClientConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClientConfig.mock
}

// Set uses given function f to mock the DependencyContainer.GetClientConfig method
func (mmGetClientConfig *mDependencyContainerMockGetClientConfig) Set(f func() (cp1 *rest.Config, err error)) *DependencyContainerMock {
	if mmGetClientConfig.defaultExpectation != nil {
		mmGetClientConfig.mock.t.Fatalf("Default expectation is already set for the DependencyContainer.GetClientConfig method")
	}

	if len(mmGetClientConfig.expectations) > 0 {
		mmGetClientConfig.mock.t.Fatalf("Some expectations are already set for the DependencyContainer.GetClientConfig method")
	}

	mmGetClientConfig.mock.funcGetClientConfig = f
	mmGetClientConfig.mock.funcGetClientConfigOrigin = minimock.CallerInfo(1)
	return mmGetClientConfig.mock
}

// Times sets number of times DependencyContainer.GetClientConfig should be invoked
func (mmGetClientConfig *mDependencyContainerMockGetClientConfig) Times(n uint64) *mDependencyContainerMockGetClientConfig {
	if n == 0 {
		mmGetClientConfig.mock.t.Fatalf("Times of DependencyContainerMock.GetClientConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClientConfig.expectedInvocations, n)
	mmGetClientConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClientConfig
}

func (mmGetClientConfig *mDependencyContainerMockGetClientConfig) invocationsDone() bool {
	if len(mmGetClientConfig.expectations) == 0 && mmGetClientConfig.defaultExpectation == nil && mmGetClientConfig.mock.funcGetClientConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClientConfig.mock.afterGetClientConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClientConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClientConfig implements mm_pkg.DependencyContainer
func (mmGetClientConfig *DependencyContainerMock) GetClientConfig() (cp1 *rest.Config, err error) {
	mm_atomic.AddUint64(&mmGetClientConfig.beforeGetClientConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClientConfig.afterGetClientConfigCounter, 1)

	mmGetClientConfig.t.Helper()

	if mmGetClientConfig.inspectFuncGetClientConfig != nil {
		mmGetClientConfig.inspectFuncGetClientConfig()
	}

	if mmGetClientConfig.GetClientConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClientConfig.GetClientConfigMock.defaultExpectation.Counter, 1)

		mm_results := mmGetClientConfig.GetClientConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClientConfig.t.Fatal("No results are set for the DependencyContainerMock.GetClientConfig")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetClientConfig.funcGetClientConfig != nil {
		return mmGetClientConfig.funcGetClientConfig()
	}
	mmGetClientConfig.t.Fatalf("Unexpected call to DependencyContainerMock.GetClientConfig.")
	return
}

// GetClientConfigAfterCounter returns a count of finished DependencyContainerMock.GetClientConfig invocations
func (mmGetClientConfig *DependencyContainerMock) GetClientConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientConfig.afterGetClientConfigCounter)
}

// GetClientConfigBeforeCounter returns a count of DependencyContainerMock.GetClientConfig invocations
func (mmGetClientConfig *DependencyContainerMock) GetClientConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientConfig.beforeGetClientConfigCounter)
}

// MinimockGetClientConfigDone returns true if the count of the GetClientConfig invocations corresponds
// the number of defined expectations
func (m *DependencyContainerMock) MinimockGetClientConfigDone() bool {
	if m.GetClientConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClientConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClientConfigMock.invocationsDone()
}

// MinimockGetClientConfigInspect logs each unmet expectation
func (m *DependencyContainerMock) MinimockGetClientConfigInspect() {
	for _, e := range m.GetClientConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DependencyContainerMock.GetClientConfig")
		}
	}

	afterGetClientConfigCounter := mm_atomic.LoadUint64(&m.afterGetClientConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientConfigMock.defaultExpectation != nil && afterGetClientConfigCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.GetClientConfig at\n%s", m.GetClientConfigMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClientConfig != nil && afterGetClientConfigCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.GetClientConfig at\n%s", m.funcGetClientConfigOrigin)
	}

	if !m.GetClientConfigMock.invocationsDone() && afterGetClientConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to DependencyContainerMock.GetClientConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClientConfigMock.expectedInvocations), m.GetClientConfigMock.expectedInvocationsOrigin, afterGetClientConfigCounter)
	}
}

type mDependencyContainerMockGetClock struct {
	optional           bool
	mock               *DependencyContainerMock
	defaultExpectation *DependencyContainerMockGetClockExpectation
	expectations       []*DependencyContainerMockGetClockExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DependencyContainerMockGetClockExpectation specifies expectation struct of the DependencyContainer.GetClock
type DependencyContainerMockGetClockExpectation struct {
	mock *DependencyContainerMock

	results      *DependencyContainerMockGetClockResults
	returnOrigin string
	Counter      uint64
}

// DependencyContainerMockGetClockResults contains results of the DependencyContainer.GetClock
type DependencyContainerMockGetClockResults struct {
	c1 clockwork.Clock
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClock *mDependencyContainerMockGetClock) Optional() *mDependencyContainerMockGetClock {
	mmGetClock.optional = true
	return mmGetClock
}

// Expect sets up expected params for DependencyContainer.GetClock
func (mmGetClock *mDependencyContainerMockGetClock) Expect() *mDependencyContainerMockGetClock {
	if mmGetClock.mock.funcGetClock != nil {
		mmGetClock.mock.t.Fatalf("DependencyContainerMock.GetClock mock is already set by Set")
	}

	if mmGetClock.defaultExpectation == nil {
		mmGetClock.defaultExpectation = &DependencyContainerMockGetClockExpectation{}
	}

	return mmGetClock
}

// Inspect accepts an inspector function that has same arguments as the DependencyContainer.GetClock
func (mmGetClock *mDependencyContainerMockGetClock) Inspect(f func()) *mDependencyContainerMockGetClock {
	if mmGetClock.mock.inspectFuncGetClock != nil {
		mmGetClock.mock.t.Fatalf("Inspect function is already set for DependencyContainerMock.GetClock")
	}

	mmGetClock.mock.inspectFuncGetClock = f

	return mmGetClock
}

// Return sets up results that will be returned by DependencyContainer.GetClock
func (mmGetClock *mDependencyContainerMockGetClock) Return(c1 clockwork.Clock) *DependencyContainerMock {
	if mmGetClock.mock.funcGetClock != nil {
		mmGetClock.mock.t.Fatalf("DependencyContainerMock.GetClock mock is already set by Set")
	}

	if mmGetClock.defaultExpectation == nil {
		mmGetClock.defaultExpectation = &DependencyContainerMockGetClockExpectation{mock: mmGetClock.mock}
	}
	mmGetClock.defaultExpectation.results = &DependencyContainerMockGetClockResults{c1}
	mmGetClock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClock.mock
}

// Set uses given function f to mock the DependencyContainer.GetClock method
func (mmGetClock *mDependencyContainerMockGetClock) Set(f func() (c1 clockwork.Clock)) *DependencyContainerMock {
	if mmGetClock.defaultExpectation != nil {
		mmGetClock.mock.t.Fatalf("Default expectation is already set for the DependencyContainer.GetClock method")
	}

	if len(mmGetClock.expectations) > 0 {
		mmGetClock.mock.t.Fatalf("Some expectations are already set for the DependencyContainer.GetClock method")
	}

	mmGetClock.mock.funcGetClock = f
	mmGetClock.mock.funcGetClockOrigin = minimock.CallerInfo(1)
	return mmGetClock.mock
}

// Times sets number of times DependencyContainer.GetClock should be invoked
func (mmGetClock *mDependencyContainerMockGetClock) Times(n uint64) *mDependencyContainerMockGetClock {
	if n == 0 {
		mmGetClock.mock.t.Fatalf("Times of DependencyContainerMock.GetClock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClock.expectedInvocations, n)
	mmGetClock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClock
}

func (mmGetClock *mDependencyContainerMockGetClock) invocationsDone() bool {
	if len(mmGetClock.expectations) == 0 && mmGetClock.defaultExpectation == nil && mmGetClock.mock.funcGetClock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClock.mock.afterGetClockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClock implements mm_pkg.DependencyContainer
func (mmGetClock *DependencyContainerMock) GetClock() (c1 clockwork.Clock) {
	mm_atomic.AddUint64(&mmGetClock.beforeGetClockCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClock.afterGetClockCounter, 1)

	mmGetClock.t.Helper()

	if mmGetClock.inspectFuncGetClock != nil {
		mmGetClock.inspectFuncGetClock()
	}

	if mmGetClock.GetClockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClock.GetClockMock.defaultExpectation.Counter, 1)

		mm_results := mmGetClock.GetClockMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClock.t.Fatal("No results are set for the DependencyContainerMock.GetClock")
		}
		return (*mm_results).c1
	}
	if mmGetClock.funcGetClock != nil {
		return mmGetClock.funcGetClock()
	}
	mmGetClock.t.Fatalf("Unexpected call to DependencyContainerMock.GetClock.")
	return
}

// GetClockAfterCounter returns a count of finished DependencyContainerMock.GetClock invocations
func (mmGetClock *DependencyContainerMock) GetClockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClock.afterGetClockCounter)
}

// GetClockBeforeCounter returns a count of DependencyContainerMock.GetClock invocations
func (mmGetClock *DependencyContainerMock) GetClockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClock.beforeGetClockCounter)
}

// MinimockGetClockDone returns true if the count of the GetClock invocations corresponds
// the number of defined expectations
func (m *DependencyContainerMock) MinimockGetClockDone() bool {
	if m.GetClockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClockMock.invocationsDone()
}

// MinimockGetClockInspect logs each unmet expectation
func (m *DependencyContainerMock) MinimockGetClockInspect() {
	for _, e := range m.GetClockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DependencyContainerMock.GetClock")
		}
	}

	afterGetClockCounter := mm_atomic.LoadUint64(&m.afterGetClockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClockMock.defaultExpectation != nil && afterGetClockCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.GetClock at\n%s", m.GetClockMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClock != nil && afterGetClockCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.GetClock at\n%s", m.funcGetClockOrigin)
	}

	if !m.GetClockMock.invocationsDone() && afterGetClockCounter > 0 {
		m.t.Errorf("Expected %d calls to DependencyContainerMock.GetClock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClockMock.expectedInvocations), m.GetClockMock.expectedInvocationsOrigin, afterGetClockCounter)
	}
}

type mDependencyContainerMockGetHTTPClient struct {
	optional           bool
	mock               *DependencyContainerMock
	defaultExpectation *DependencyContainerMockGetHTTPClientExpectation
	expectations       []*DependencyContainerMockGetHTTPClientExpectation

	callArgs []*DependencyContainerMockGetHTTPClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DependencyContainerMockGetHTTPClientExpectation specifies expectation struct of the DependencyContainer.GetHTTPClient
type DependencyContainerMockGetHTTPClientExpectation struct {
	mock               *DependencyContainerMock
	params             *DependencyContainerMockGetHTTPClientParams
	paramPtrs          *DependencyContainerMockGetHTTPClientParamPtrs
	expectationOrigins DependencyContainerMockGetHTTPClientExpectationOrigins
	results            *DependencyContainerMockGetHTTPClientResults
	returnOrigin       string
	Counter            uint64
}

// DependencyContainerMockGetHTTPClientParams contains parameters of the DependencyContainer.GetHTTPClient
type DependencyContainerMockGetHTTPClientParams struct {
	options []mm_pkg.HTTPOption
}

// DependencyContainerMockGetHTTPClientParamPtrs contains pointers to parameters of the DependencyContainer.GetHTTPClient
type DependencyContainerMockGetHTTPClientParamPtrs struct {
	options *[]mm_pkg.HTTPOption
}

// DependencyContainerMockGetHTTPClientResults contains results of the DependencyContainer.GetHTTPClient
type DependencyContainerMockGetHTTPClientResults struct {
	h1 mm_pkg.HTTPClient
}

// DependencyContainerMockGetHTTPClientOrigins contains origins of expectations of the DependencyContainer.GetHTTPClient
type DependencyContainerMockGetHTTPClientExpectationOrigins struct {
	origin        string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) Optional() *mDependencyContainerMockGetHTTPClient {
	mmGetHTTPClient.optional = true
	return mmGetHTTPClient
}

// Expect sets up expected params for DependencyContainer.GetHTTPClient
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) Expect(options ...mm_pkg.HTTPOption) *mDependencyContainerMockGetHTTPClient {
	if mmGetHTTPClient.mock.funcGetHTTPClient != nil {
		mmGetHTTPClient.mock.t.Fatalf("DependencyContainerMock.GetHTTPClient mock is already set by Set")
	}

	if mmGetHTTPClient.defaultExpectation == nil {
		mmGetHTTPClient.defaultExpectation = &DependencyContainerMockGetHTTPClientExpectation{}
	}

	if mmGetHTTPClient.defaultExpectation.paramPtrs != nil {
		mmGetHTTPClient.mock.t.Fatalf("DependencyContainerMock.GetHTTPClient mock is already set by ExpectParams functions")
	}

	mmGetHTTPClient.defaultExpectation.params = &DependencyContainerMockGetHTTPClientParams{options}
	mmGetHTTPClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHTTPClient.expectations {
		if minimock.Equal(e.params, mmGetHTTPClient.defaultExpectation.params) {
			mmGetHTTPClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHTTPClient.defaultExpectation.params)
		}
	}

	return mmGetHTTPClient
}

// ExpectOptionsParam1 sets up expected param options for DependencyContainer.GetHTTPClient
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) ExpectOptionsParam1(options ...mm_pkg.HTTPOption) *mDependencyContainerMockGetHTTPClient {
	if mmGetHTTPClient.mock.funcGetHTTPClient != nil {
		mmGetHTTPClient.mock.t.Fatalf("DependencyContainerMock.GetHTTPClient mock is already set by Set")
	}

	if mmGetHTTPClient.defaultExpectation == nil {
		mmGetHTTPClient.defaultExpectation = &DependencyContainerMockGetHTTPClientExpectation{}
	}

	if mmGetHTTPClient.defaultExpectation.params != nil {
		mmGetHTTPClient.mock.t.Fatalf("DependencyContainerMock.GetHTTPClient mock is already set by Expect")
	}

	if mmGetHTTPClient.defaultExpectation.paramPtrs == nil {
		mmGetHTTPClient.defaultExpectation.paramPtrs = &DependencyContainerMockGetHTTPClientParamPtrs{}
	}
	mmGetHTTPClient.defaultExpectation.paramPtrs.options = &options
	mmGetHTTPClient.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetHTTPClient
}

// Inspect accepts an inspector function that has same arguments as the DependencyContainer.GetHTTPClient
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) Inspect(f func(options ...mm_pkg.HTTPOption)) *mDependencyContainerMockGetHTTPClient {
	if mmGetHTTPClient.mock.inspectFuncGetHTTPClient != nil {
		mmGetHTTPClient.mock.t.Fatalf("Inspect function is already set for DependencyContainerMock.GetHTTPClient")
	}

	mmGetHTTPClient.mock.inspectFuncGetHTTPClient = f

	return mmGetHTTPClient
}

// Return sets up results that will be returned by DependencyContainer.GetHTTPClient
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) Return(h1 mm_pkg.HTTPClient) *DependencyContainerMock {
	if mmGetHTTPClient.mock.funcGetHTTPClient != nil {
		mmGetHTTPClient.mock.t.Fatalf("DependencyContainerMock.GetHTTPClient mock is already set by Set")
	}

	if mmGetHTTPClient.defaultExpectation == nil {
		mmGetHTTPClient.defaultExpectation = &DependencyContainerMockGetHTTPClientExpectation{mock: mmGetHTTPClient.mock}
	}
	mmGetHTTPClient.defaultExpectation.results = &DependencyContainerMockGetHTTPClientResults{h1}
	mmGetHTTPClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHTTPClient.mock
}

// Set uses given function f to mock the DependencyContainer.GetHTTPClient method
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) Set(f func(options ...mm_pkg.HTTPOption) (h1 mm_pkg.HTTPClient)) *DependencyContainerMock {
	if mmGetHTTPClient.defaultExpectation != nil {
		mmGetHTTPClient.mock.t.Fatalf("Default expectation is already set for the DependencyContainer.GetHTTPClient method")
	}

	if len(mmGetHTTPClient.expectations) > 0 {
		mmGetHTTPClient.mock.t.Fatalf("Some expectations are already set for the DependencyContainer.GetHTTPClient method")
	}

	mmGetHTTPClient.mock.funcGetHTTPClient = f
	mmGetHTTPClient.mock.funcGetHTTPClientOrigin = minimock.CallerInfo(1)
	return mmGetHTTPClient.mock
}

// When sets expectation for the DependencyContainer.GetHTTPClient which will trigger the result defined by the following
// Then helper
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) When(options ...mm_pkg.HTTPOption) *DependencyContainerMockGetHTTPClientExpectation {
	if mmGetHTTPClient.mock.funcGetHTTPClient != nil {
		mmGetHTTPClient.mock.t.Fatalf("DependencyContainerMock.GetHTTPClient mock is already set by Set")
	}

	expectation := &DependencyContainerMockGetHTTPClientExpectation{
		mock:               mmGetHTTPClient.mock,
		params:             &DependencyContainerMockGetHTTPClientParams{options},
		expectationOrigins: DependencyContainerMockGetHTTPClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHTTPClient.expectations = append(mmGetHTTPClient.expectations, expectation)
	return expectation
}

// Then sets up DependencyContainer.GetHTTPClient return parameters for the expectation previously defined by the When method
func (e *DependencyContainerMockGetHTTPClientExpectation) Then(h1 mm_pkg.HTTPClient) *DependencyContainerMock {
	e.results = &DependencyContainerMockGetHTTPClientResults{h1}
	return e.mock
}

// Times sets number of times DependencyContainer.GetHTTPClient should be invoked
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) Times(n uint64) *mDependencyContainerMockGetHTTPClient {
	if n == 0 {
		mmGetHTTPClient.mock.t.Fatalf("Times of DependencyContainerMock.GetHTTPClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHTTPClient.expectedInvocations, n)
	mmGetHTTPClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHTTPClient
}

func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) invocationsDone() bool {
	if len(mmGetHTTPClient.expectations) == 0 && mmGetHTTPClient.defaultExpectation == nil && mmGetHTTPClient.mock.funcGetHTTPClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHTTPClient.mock.afterGetHTTPClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHTTPClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHTTPClient implements mm_pkg.DependencyContainer
func (mmGetHTTPClient *DependencyContainerMock) GetHTTPClient(options ...mm_pkg.HTTPOption) (h1 mm_pkg.HTTPClient) {
	mm_atomic.AddUint64(&mmGetHTTPClient.beforeGetHTTPClientCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHTTPClient.afterGetHTTPClientCounter, 1)

	mmGetHTTPClient.t.Helper()

	if mmGetHTTPClient.inspectFuncGetHTTPClient != nil {
		mmGetHTTPClient.inspectFuncGetHTTPClient(options...)
	}

	mm_params := DependencyContainerMockGetHTTPClientParams{options}

	// Record call args
	mmGetHTTPClient.GetHTTPClientMock.mutex.Lock()
	mmGetHTTPClient.GetHTTPClientMock.callArgs = append(mmGetHTTPClient.GetHTTPClientMock.callArgs, &mm_params)
	mmGetHTTPClient.GetHTTPClientMock.mutex.Unlock()

	for _, e := range mmGetHTTPClient.GetHTTPClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.h1
		}
	}

	if mmGetHTTPClient.GetHTTPClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHTTPClient.GetHTTPClientMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHTTPClient.GetHTTPClientMock.defaultExpectation.params
		mm_want_ptrs := mmGetHTTPClient.GetHTTPClientMock.defaultExpectation.paramPtrs

		mm_got := DependencyContainerMockGetHTTPClientParams{options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetHTTPClient.t.Errorf("DependencyContainerMock.GetHTTPClient got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHTTPClient.GetHTTPClientMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHTTPClient.t.Errorf("DependencyContainerMock.GetHTTPClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHTTPClient.GetHTTPClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHTTPClient.GetHTTPClientMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHTTPClient.t.Fatal("No results are set for the DependencyContainerMock.GetHTTPClient")
		}
		return (*mm_results).h1
	}
	if mmGetHTTPClient.funcGetHTTPClient != nil {
		return mmGetHTTPClient.funcGetHTTPClient(options...)
	}
	mmGetHTTPClient.t.Fatalf("Unexpected call to DependencyContainerMock.GetHTTPClient. %v", options)
	return
}

// GetHTTPClientAfterCounter returns a count of finished DependencyContainerMock.GetHTTPClient invocations
func (mmGetHTTPClient *DependencyContainerMock) GetHTTPClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHTTPClient.afterGetHTTPClientCounter)
}

// GetHTTPClientBeforeCounter returns a count of DependencyContainerMock.GetHTTPClient invocations
func (mmGetHTTPClient *DependencyContainerMock) GetHTTPClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHTTPClient.beforeGetHTTPClientCounter)
}

// Calls returns a list of arguments used in each call to DependencyContainerMock.GetHTTPClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHTTPClient *mDependencyContainerMockGetHTTPClient) Calls() []*DependencyContainerMockGetHTTPClientParams {
	mmGetHTTPClient.mutex.RLock()

	argCopy := make([]*DependencyContainerMockGetHTTPClientParams, len(mmGetHTTPClient.callArgs))
	copy(argCopy, mmGetHTTPClient.callArgs)

	mmGetHTTPClient.mutex.RUnlock()

	return argCopy
}

// MinimockGetHTTPClientDone returns true if the count of the GetHTTPClient invocations corresponds
// the number of defined expectations
func (m *DependencyContainerMock) MinimockGetHTTPClientDone() bool {
	if m.GetHTTPClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHTTPClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHTTPClientMock.invocationsDone()
}

// MinimockGetHTTPClientInspect logs each unmet expectation
func (m *DependencyContainerMock) MinimockGetHTTPClientInspect() {
	for _, e := range m.GetHTTPClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DependencyContainerMock.GetHTTPClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHTTPClientCounter := mm_atomic.LoadUint64(&m.afterGetHTTPClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHTTPClientMock.defaultExpectation != nil && afterGetHTTPClientCounter < 1 {
		if m.GetHTTPClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DependencyContainerMock.GetHTTPClient at\n%s", m.GetHTTPClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DependencyContainerMock.GetHTTPClient at\n%s with params: %#v", m.GetHTTPClientMock.defaultExpectation.expectationOrigins.origin, *m.GetHTTPClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHTTPClient != nil && afterGetHTTPClientCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.GetHTTPClient at\n%s", m.funcGetHTTPClientOrigin)
	}

	if !m.GetHTTPClientMock.invocationsDone() && afterGetHTTPClientCounter > 0 {
		m.t.Errorf("Expected %d calls to DependencyContainerMock.GetHTTPClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHTTPClientMock.expectedInvocations), m.GetHTTPClientMock.expectedInvocationsOrigin, afterGetHTTPClientCounter)
	}
}

type mDependencyContainerMockGetK8sClient struct {
	optional           bool
	mock               *DependencyContainerMock
	defaultExpectation *DependencyContainerMockGetK8sClientExpectation
	expectations       []*DependencyContainerMockGetK8sClientExpectation

	callArgs []*DependencyContainerMockGetK8sClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DependencyContainerMockGetK8sClientExpectation specifies expectation struct of the DependencyContainer.GetK8sClient
type DependencyContainerMockGetK8sClientExpectation struct {
	mock               *DependencyContainerMock
	params             *DependencyContainerMockGetK8sClientParams
	paramPtrs          *DependencyContainerMockGetK8sClientParamPtrs
	expectationOrigins DependencyContainerMockGetK8sClientExpectationOrigins
	results            *DependencyContainerMockGetK8sClientResults
	returnOrigin       string
	Counter            uint64
}

// DependencyContainerMockGetK8sClientParams contains parameters of the DependencyContainer.GetK8sClient
type DependencyContainerMockGetK8sClientParams struct {
	options []mm_pkg.KubernetesOption
}

// DependencyContainerMockGetK8sClientParamPtrs contains pointers to parameters of the DependencyContainer.GetK8sClient
type DependencyContainerMockGetK8sClientParamPtrs struct {
	options *[]mm_pkg.KubernetesOption
}

// DependencyContainerMockGetK8sClientResults contains results of the DependencyContainer.GetK8sClient
type DependencyContainerMockGetK8sClientResults struct {
	k1  mm_pkg.KubernetesClient
	err error
}

// DependencyContainerMockGetK8sClientOrigins contains origins of expectations of the DependencyContainer.GetK8sClient
type DependencyContainerMockGetK8sClientExpectationOrigins struct {
	origin        string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) Optional() *mDependencyContainerMockGetK8sClient {
	mmGetK8sClient.optional = true
	return mmGetK8sClient
}

// Expect sets up expected params for DependencyContainer.GetK8sClient
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) Expect(options ...mm_pkg.KubernetesOption) *mDependencyContainerMockGetK8sClient {
	if mmGetK8sClient.mock.funcGetK8sClient != nil {
		mmGetK8sClient.mock.t.Fatalf("DependencyContainerMock.GetK8sClient mock is already set by Set")
	}

	if mmGetK8sClient.defaultExpectation == nil {
		mmGetK8sClient.defaultExpectation = &DependencyContainerMockGetK8sClientExpectation{}
	}

	if mmGetK8sClient.defaultExpectation.paramPtrs != nil {
		mmGetK8sClient.mock.t.Fatalf("DependencyContainerMock.GetK8sClient mock is already set by ExpectParams functions")
	}

	mmGetK8sClient.defaultExpectation.params = &DependencyContainerMockGetK8sClientParams{options}
	mmGetK8sClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetK8sClient.expectations {
		if minimock.Equal(e.params, mmGetK8sClient.defaultExpectation.params) {
			mmGetK8sClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetK8sClient.defaultExpectation.params)
		}
	}

	return mmGetK8sClient
}

// ExpectOptionsParam1 sets up expected param options for DependencyContainer.GetK8sClient
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) ExpectOptionsParam1(options ...mm_pkg.KubernetesOption) *mDependencyContainerMockGetK8sClient {
	if mmGetK8sClient.mock.funcGetK8sClient != nil {
		mmGetK8sClient.mock.t.Fatalf("DependencyContainerMock.GetK8sClient mock is already set by Set")
	}

	if mmGetK8sClient.defaultExpectation == nil {
		mmGetK8sClient.defaultExpectation = &DependencyContainerMockGetK8sClientExpectation{}
	}

	if mmGetK8sClient.defaultExpectation.params != nil {
		mmGetK8sClient.mock.t.Fatalf("DependencyContainerMock.GetK8sClient mock is already set by Expect")
	}

	if mmGetK8sClient.defaultExpectation.paramPtrs == nil {
		mmGetK8sClient.defaultExpectation.paramPtrs = &DependencyContainerMockGetK8sClientParamPtrs{}
	}
	mmGetK8sClient.defaultExpectation.paramPtrs.options = &options
	mmGetK8sClient.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetK8sClient
}

// Inspect accepts an inspector function that has same arguments as the DependencyContainer.GetK8sClient
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) Inspect(f func(options ...mm_pkg.KubernetesOption)) *mDependencyContainerMockGetK8sClient {
	if mmGetK8sClient.mock.inspectFuncGetK8sClient != nil {
		mmGetK8sClient.mock.t.Fatalf("Inspect function is already set for DependencyContainerMock.GetK8sClient")
	}

	mmGetK8sClient.mock.inspectFuncGetK8sClient = f

	return mmGetK8sClient
}

// Return sets up results that will be returned by DependencyContainer.GetK8sClient
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) Return(k1 mm_pkg.KubernetesClient, err error) *DependencyContainerMock {
	if mmGetK8sClient.mock.funcGetK8sClient != nil {
		mmGetK8sClient.mock.t.Fatalf("DependencyContainerMock.GetK8sClient mock is already set by Set")
	}

	if mmGetK8sClient.defaultExpectation == nil {
		mmGetK8sClient.defaultExpectation = &DependencyContainerMockGetK8sClientExpectation{mock: mmGetK8sClient.mock}
	}
	mmGetK8sClient.defaultExpectation.results = &DependencyContainerMockGetK8sClientResults{k1, err}
	mmGetK8sClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetK8sClient.mock
}

// Set uses given function f to mock the DependencyContainer.GetK8sClient method
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) Set(f func(options ...mm_pkg.KubernetesOption) (k1 mm_pkg.KubernetesClient, err error)) *DependencyContainerMock {
	if mmGetK8sClient.defaultExpectation != nil {
		mmGetK8sClient.mock.t.Fatalf("Default expectation is already set for the DependencyContainer.GetK8sClient method")
	}

	if len(mmGetK8sClient.expectations) > 0 {
		mmGetK8sClient.mock.t.Fatalf("Some expectations are already set for the DependencyContainer.GetK8sClient method")
	}

	mmGetK8sClient.mock.funcGetK8sClient = f
	mmGetK8sClient.mock.funcGetK8sClientOrigin = minimock.CallerInfo(1)
	return mmGetK8sClient.mock
}

// When sets expectation for the DependencyContainer.GetK8sClient which will trigger the result defined by the following
// Then helper
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) When(options ...mm_pkg.KubernetesOption) *DependencyContainerMockGetK8sClientExpectation {
	if mmGetK8sClient.mock.funcGetK8sClient != nil {
		mmGetK8sClient.mock.t.Fatalf("DependencyContainerMock.GetK8sClient mock is already set by Set")
	}

	expectation := &DependencyContainerMockGetK8sClientExpectation{
		mock:               mmGetK8sClient.mock,
		params:             &DependencyContainerMockGetK8sClientParams{options},
		expectationOrigins: DependencyContainerMockGetK8sClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetK8sClient.expectations = append(mmGetK8sClient.expectations, expectation)
	return expectation
}

// Then sets up DependencyContainer.GetK8sClient return parameters for the expectation previously defined by the When method
func (e *DependencyContainerMockGetK8sClientExpectation) Then(k1 mm_pkg.KubernetesClient, err error) *DependencyContainerMock {
	e.results = &DependencyContainerMockGetK8sClientResults{k1, err}
	return e.mock
}

// Times sets number of times DependencyContainer.GetK8sClient should be invoked
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) Times(n uint64) *mDependencyContainerMockGetK8sClient {
	if n == 0 {
		mmGetK8sClient.mock.t.Fatalf("Times of DependencyContainerMock.GetK8sClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetK8sClient.expectedInvocations, n)
	mmGetK8sClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetK8sClient
}

func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) invocationsDone() bool {
	if len(mmGetK8sClient.expectations) == 0 && mmGetK8sClient.defaultExpectation == nil && mmGetK8sClient.mock.funcGetK8sClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetK8sClient.mock.afterGetK8sClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetK8sClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetK8sClient implements mm_pkg.DependencyContainer
func (mmGetK8sClient *DependencyContainerMock) GetK8sClient(options ...mm_pkg.KubernetesOption) (k1 mm_pkg.KubernetesClient, err error) {
	mm_atomic.AddUint64(&mmGetK8sClient.beforeGetK8sClientCounter, 1)
	defer mm_atomic.AddUint64(&mmGetK8sClient.afterGetK8sClientCounter, 1)

	mmGetK8sClient.t.Helper()

	if mmGetK8sClient.inspectFuncGetK8sClient != nil {
		mmGetK8sClient.inspectFuncGetK8sClient(options...)
	}

	mm_params := DependencyContainerMockGetK8sClientParams{options}

	// Record call args
	mmGetK8sClient.GetK8sClientMock.mutex.Lock()
	mmGetK8sClient.GetK8sClientMock.callArgs = append(mmGetK8sClient.GetK8sClientMock.callArgs, &mm_params)
	mmGetK8sClient.GetK8sClientMock.mutex.Unlock()

	for _, e := range mmGetK8sClient.GetK8sClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.k1, e.results.err
		}
	}

	if mmGetK8sClient.GetK8sClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetK8sClient.GetK8sClientMock.defaultExpectation.Counter, 1)
		mm_want := mmGetK8sClient.GetK8sClientMock.defaultExpectation.params
		mm_want_ptrs := mmGetK8sClient.GetK8sClientMock.defaultExpectation.paramPtrs

		mm_got := DependencyContainerMockGetK8sClientParams{options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetK8sClient.t.Errorf("DependencyContainerMock.GetK8sClient got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetK8sClient.GetK8sClientMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetK8sClient.t.Errorf("DependencyContainerMock.GetK8sClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetK8sClient.GetK8sClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetK8sClient.GetK8sClientMock.defaultExpectation.results
		if mm_results == nil {
			mmGetK8sClient.t.Fatal("No results are set for the DependencyContainerMock.GetK8sClient")
		}
		return (*mm_results).k1, (*mm_results).err
	}
	if mmGetK8sClient.funcGetK8sClient != nil {
		return mmGetK8sClient.funcGetK8sClient(options...)
	}
	mmGetK8sClient.t.Fatalf("Unexpected call to DependencyContainerMock.GetK8sClient. %v", options)
	return
}

// GetK8sClientAfterCounter returns a count of finished DependencyContainerMock.GetK8sClient invocations
func (mmGetK8sClient *DependencyContainerMock) GetK8sClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetK8sClient.afterGetK8sClientCounter)
}

// GetK8sClientBeforeCounter returns a count of DependencyContainerMock.GetK8sClient invocations
func (mmGetK8sClient *DependencyContainerMock) GetK8sClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetK8sClient.beforeGetK8sClientCounter)
}

// Calls returns a list of arguments used in each call to DependencyContainerMock.GetK8sClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetK8sClient *mDependencyContainerMockGetK8sClient) Calls() []*DependencyContainerMockGetK8sClientParams {
	mmGetK8sClient.mutex.RLock()

	argCopy := make([]*DependencyContainerMockGetK8sClientParams, len(mmGetK8sClient.callArgs))
	copy(argCopy, mmGetK8sClient.callArgs)

	mmGetK8sClient.mutex.RUnlock()

	return argCopy
}

// MinimockGetK8sClientDone returns true if the count of the GetK8sClient invocations corresponds
// the number of defined expectations
func (m *DependencyContainerMock) MinimockGetK8sClientDone() bool {
	if m.GetK8sClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetK8sClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetK8sClientMock.invocationsDone()
}

// MinimockGetK8sClientInspect logs each unmet expectation
func (m *DependencyContainerMock) MinimockGetK8sClientInspect() {
	for _, e := range m.GetK8sClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DependencyContainerMock.GetK8sClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetK8sClientCounter := mm_atomic.LoadUint64(&m.afterGetK8sClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetK8sClientMock.defaultExpectation != nil && afterGetK8sClientCounter < 1 {
		if m.GetK8sClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DependencyContainerMock.GetK8sClient at\n%s", m.GetK8sClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DependencyContainerMock.GetK8sClient at\n%s with params: %#v", m.GetK8sClientMock.defaultExpectation.expectationOrigins.origin, *m.GetK8sClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetK8sClient != nil && afterGetK8sClientCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.GetK8sClient at\n%s", m.funcGetK8sClientOrigin)
	}

	if !m.GetK8sClientMock.invocationsDone() && afterGetK8sClientCounter > 0 {
		m.t.Errorf("Expected %d calls to DependencyContainerMock.GetK8sClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetK8sClientMock.expectedInvocations), m.GetK8sClientMock.expectedInvocationsOrigin, afterGetK8sClientCounter)
	}
}

type mDependencyContainerMockGetRegistryClient struct {
	optional           bool
	mock               *DependencyContainerMock
	defaultExpectation *DependencyContainerMockGetRegistryClientExpectation
	expectations       []*DependencyContainerMockGetRegistryClientExpectation

	callArgs []*DependencyContainerMockGetRegistryClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DependencyContainerMockGetRegistryClientExpectation specifies expectation struct of the DependencyContainer.GetRegistryClient
type DependencyContainerMockGetRegistryClientExpectation struct {
	mock               *DependencyContainerMock
	params             *DependencyContainerMockGetRegistryClientParams
	paramPtrs          *DependencyContainerMockGetRegistryClientParamPtrs
	expectationOrigins DependencyContainerMockGetRegistryClientExpectationOrigins
	results            *DependencyContainerMockGetRegistryClientResults
	returnOrigin       string
	Counter            uint64
}

// DependencyContainerMockGetRegistryClientParams contains parameters of the DependencyContainer.GetRegistryClient
type DependencyContainerMockGetRegistryClientParams struct {
	repo    string
	options []mm_pkg.RegistryOption
}

// DependencyContainerMockGetRegistryClientParamPtrs contains pointers to parameters of the DependencyContainer.GetRegistryClient
type DependencyContainerMockGetRegistryClientParamPtrs struct {
	repo    *string
	options *[]mm_pkg.RegistryOption
}

// DependencyContainerMockGetRegistryClientResults contains results of the DependencyContainer.GetRegistryClient
type DependencyContainerMockGetRegistryClientResults struct {
	r1  mm_pkg.RegistryClient
	err error
}

// DependencyContainerMockGetRegistryClientOrigins contains origins of expectations of the DependencyContainer.GetRegistryClient
type DependencyContainerMockGetRegistryClientExpectationOrigins struct {
	origin        string
	originRepo    string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) Optional() *mDependencyContainerMockGetRegistryClient {
	mmGetRegistryClient.optional = true
	return mmGetRegistryClient
}

// Expect sets up expected params for DependencyContainer.GetRegistryClient
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) Expect(repo string, options ...mm_pkg.RegistryOption) *mDependencyContainerMockGetRegistryClient {
	if mmGetRegistryClient.mock.funcGetRegistryClient != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by Set")
	}

	if mmGetRegistryClient.defaultExpectation == nil {
		mmGetRegistryClient.defaultExpectation = &DependencyContainerMockGetRegistryClientExpectation{}
	}

	if mmGetRegistryClient.defaultExpectation.paramPtrs != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by ExpectParams functions")
	}

	mmGetRegistryClient.defaultExpectation.params = &DependencyContainerMockGetRegistryClientParams{repo, options}
	mmGetRegistryClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRegistryClient.expectations {
		if minimock.Equal(e.params, mmGetRegistryClient.defaultExpectation.params) {
			mmGetRegistryClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRegistryClient.defaultExpectation.params)
		}
	}

	return mmGetRegistryClient
}

// ExpectRepoParam1 sets up expected param repo for DependencyContainer.GetRegistryClient
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) ExpectRepoParam1(repo string) *mDependencyContainerMockGetRegistryClient {
	if mmGetRegistryClient.mock.funcGetRegistryClient != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by Set")
	}

	if mmGetRegistryClient.defaultExpectation == nil {
		mmGetRegistryClient.defaultExpectation = &DependencyContainerMockGetRegistryClientExpectation{}
	}

	if mmGetRegistryClient.defaultExpectation.params != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by Expect")
	}

	if mmGetRegistryClient.defaultExpectation.paramPtrs == nil {
		mmGetRegistryClient.defaultExpectation.paramPtrs = &DependencyContainerMockGetRegistryClientParamPtrs{}
	}
	mmGetRegistryClient.defaultExpectation.paramPtrs.repo = &repo
	mmGetRegistryClient.defaultExpectation.expectationOrigins.originRepo = minimock.CallerInfo(1)

	return mmGetRegistryClient
}

// ExpectOptionsParam2 sets up expected param options for DependencyContainer.GetRegistryClient
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) ExpectOptionsParam2(options ...mm_pkg.RegistryOption) *mDependencyContainerMockGetRegistryClient {
	if mmGetRegistryClient.mock.funcGetRegistryClient != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by Set")
	}

	if mmGetRegistryClient.defaultExpectation == nil {
		mmGetRegistryClient.defaultExpectation = &DependencyContainerMockGetRegistryClientExpectation{}
	}

	if mmGetRegistryClient.defaultExpectation.params != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by Expect")
	}

	if mmGetRegistryClient.defaultExpectation.paramPtrs == nil {
		mmGetRegistryClient.defaultExpectation.paramPtrs = &DependencyContainerMockGetRegistryClientParamPtrs{}
	}
	mmGetRegistryClient.defaultExpectation.paramPtrs.options = &options
	mmGetRegistryClient.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetRegistryClient
}

// Inspect accepts an inspector function that has same arguments as the DependencyContainer.GetRegistryClient
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) Inspect(f func(repo string, options ...mm_pkg.RegistryOption)) *mDependencyContainerMockGetRegistryClient {
	if mmGetRegistryClient.mock.inspectFuncGetRegistryClient != nil {
		mmGetRegistryClient.mock.t.Fatalf("Inspect function is already set for DependencyContainerMock.GetRegistryClient")
	}

	mmGetRegistryClient.mock.inspectFuncGetRegistryClient = f

	return mmGetRegistryClient
}

// Return sets up results that will be returned by DependencyContainer.GetRegistryClient
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) Return(r1 mm_pkg.RegistryClient, err error) *DependencyContainerMock {
	if mmGetRegistryClient.mock.funcGetRegistryClient != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by Set")
	}

	if mmGetRegistryClient.defaultExpectation == nil {
		mmGetRegistryClient.defaultExpectation = &DependencyContainerMockGetRegistryClientExpectation{mock: mmGetRegistryClient.mock}
	}
	mmGetRegistryClient.defaultExpectation.results = &DependencyContainerMockGetRegistryClientResults{r1, err}
	mmGetRegistryClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRegistryClient.mock
}

// Set uses given function f to mock the DependencyContainer.GetRegistryClient method
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) Set(f func(repo string, options ...mm_pkg.RegistryOption) (r1 mm_pkg.RegistryClient, err error)) *DependencyContainerMock {
	if mmGetRegistryClient.defaultExpectation != nil {
		mmGetRegistryClient.mock.t.Fatalf("Default expectation is already set for the DependencyContainer.GetRegistryClient method")
	}

	if len(mmGetRegistryClient.expectations) > 0 {
		mmGetRegistryClient.mock.t.Fatalf("Some expectations are already set for the DependencyContainer.GetRegistryClient method")
	}

	mmGetRegistryClient.mock.funcGetRegistryClient = f
	mmGetRegistryClient.mock.funcGetRegistryClientOrigin = minimock.CallerInfo(1)
	return mmGetRegistryClient.mock
}

// When sets expectation for the DependencyContainer.GetRegistryClient which will trigger the result defined by the following
// Then helper
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) When(repo string, options ...mm_pkg.RegistryOption) *DependencyContainerMockGetRegistryClientExpectation {
	if mmGetRegistryClient.mock.funcGetRegistryClient != nil {
		mmGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.GetRegistryClient mock is already set by Set")
	}

	expectation := &DependencyContainerMockGetRegistryClientExpectation{
		mock:               mmGetRegistryClient.mock,
		params:             &DependencyContainerMockGetRegistryClientParams{repo, options},
		expectationOrigins: DependencyContainerMockGetRegistryClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRegistryClient.expectations = append(mmGetRegistryClient.expectations, expectation)
	return expectation
}

// Then sets up DependencyContainer.GetRegistryClient return parameters for the expectation previously defined by the When method
func (e *DependencyContainerMockGetRegistryClientExpectation) Then(r1 mm_pkg.RegistryClient, err error) *DependencyContainerMock {
	e.results = &DependencyContainerMockGetRegistryClientResults{r1, err}
	return e.mock
}

// Times sets number of times DependencyContainer.GetRegistryClient should be invoked
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) Times(n uint64) *mDependencyContainerMockGetRegistryClient {
	if n == 0 {
		mmGetRegistryClient.mock.t.Fatalf("Times of DependencyContainerMock.GetRegistryClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRegistryClient.expectedInvocations, n)
	mmGetRegistryClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRegistryClient
}

func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) invocationsDone() bool {
	if len(mmGetRegistryClient.expectations) == 0 && mmGetRegistryClient.defaultExpectation == nil && mmGetRegistryClient.mock.funcGetRegistryClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRegistryClient.mock.afterGetRegistryClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRegistryClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRegistryClient implements mm_pkg.DependencyContainer
func (mmGetRegistryClient *DependencyContainerMock) GetRegistryClient(repo string, options ...mm_pkg.RegistryOption) (r1 mm_pkg.RegistryClient, err error) {
	mm_atomic.AddUint64(&mmGetRegistryClient.beforeGetRegistryClientCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRegistryClient.afterGetRegistryClientCounter, 1)

	mmGetRegistryClient.t.Helper()

	if mmGetRegistryClient.inspectFuncGetRegistryClient != nil {
		mmGetRegistryClient.inspectFuncGetRegistryClient(repo, options...)
	}

	mm_params := DependencyContainerMockGetRegistryClientParams{repo, options}

	// Record call args
	mmGetRegistryClient.GetRegistryClientMock.mutex.Lock()
	mmGetRegistryClient.GetRegistryClientMock.callArgs = append(mmGetRegistryClient.GetRegistryClientMock.callArgs, &mm_params)
	mmGetRegistryClient.GetRegistryClientMock.mutex.Unlock()

	for _, e := range mmGetRegistryClient.GetRegistryClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetRegistryClient.GetRegistryClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRegistryClient.GetRegistryClientMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRegistryClient.GetRegistryClientMock.defaultExpectation.params
		mm_want_ptrs := mmGetRegistryClient.GetRegistryClientMock.defaultExpectation.paramPtrs

		mm_got := DependencyContainerMockGetRegistryClientParams{repo, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.repo != nil && !minimock.Equal(*mm_want_ptrs.repo, mm_got.repo) {
				mmGetRegistryClient.t.Errorf("DependencyContainerMock.GetRegistryClient got unexpected parameter repo, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRegistryClient.GetRegistryClientMock.defaultExpectation.expectationOrigins.originRepo, *mm_want_ptrs.repo, mm_got.repo, minimock.Diff(*mm_want_ptrs.repo, mm_got.repo))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetRegistryClient.t.Errorf("DependencyContainerMock.GetRegistryClient got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRegistryClient.GetRegistryClientMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRegistryClient.t.Errorf("DependencyContainerMock.GetRegistryClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRegistryClient.GetRegistryClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRegistryClient.GetRegistryClientMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRegistryClient.t.Fatal("No results are set for the DependencyContainerMock.GetRegistryClient")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetRegistryClient.funcGetRegistryClient != nil {
		return mmGetRegistryClient.funcGetRegistryClient(repo, options...)
	}
	mmGetRegistryClient.t.Fatalf("Unexpected call to DependencyContainerMock.GetRegistryClient. %v %v", repo, options)
	return
}

// GetRegistryClientAfterCounter returns a count of finished DependencyContainerMock.GetRegistryClient invocations
func (mmGetRegistryClient *DependencyContainerMock) GetRegistryClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistryClient.afterGetRegistryClientCounter)
}

// GetRegistryClientBeforeCounter returns a count of DependencyContainerMock.GetRegistryClient invocations
func (mmGetRegistryClient *DependencyContainerMock) GetRegistryClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistryClient.beforeGetRegistryClientCounter)
}

// Calls returns a list of arguments used in each call to DependencyContainerMock.GetRegistryClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRegistryClient *mDependencyContainerMockGetRegistryClient) Calls() []*DependencyContainerMockGetRegistryClientParams {
	mmGetRegistryClient.mutex.RLock()

	argCopy := make([]*DependencyContainerMockGetRegistryClientParams, len(mmGetRegistryClient.callArgs))
	copy(argCopy, mmGetRegistryClient.callArgs)

	mmGetRegistryClient.mutex.RUnlock()

	return argCopy
}

// MinimockGetRegistryClientDone returns true if the count of the GetRegistryClient invocations corresponds
// the number of defined expectations
func (m *DependencyContainerMock) MinimockGetRegistryClientDone() bool {
	if m.GetRegistryClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRegistryClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRegistryClientMock.invocationsDone()
}

// MinimockGetRegistryClientInspect logs each unmet expectation
func (m *DependencyContainerMock) MinimockGetRegistryClientInspect() {
	for _, e := range m.GetRegistryClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DependencyContainerMock.GetRegistryClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRegistryClientCounter := mm_atomic.LoadUint64(&m.afterGetRegistryClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRegistryClientMock.defaultExpectation != nil && afterGetRegistryClientCounter < 1 {
		if m.GetRegistryClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DependencyContainerMock.GetRegistryClient at\n%s", m.GetRegistryClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DependencyContainerMock.GetRegistryClient at\n%s with params: %#v", m.GetRegistryClientMock.defaultExpectation.expectationOrigins.origin, *m.GetRegistryClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRegistryClient != nil && afterGetRegistryClientCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.GetRegistryClient at\n%s", m.funcGetRegistryClientOrigin)
	}

	if !m.GetRegistryClientMock.invocationsDone() && afterGetRegistryClientCounter > 0 {
		m.t.Errorf("Expected %d calls to DependencyContainerMock.GetRegistryClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRegistryClientMock.expectedInvocations), m.GetRegistryClientMock.expectedInvocationsOrigin, afterGetRegistryClientCounter)
	}
}

type mDependencyContainerMockMustGetK8sClient struct {
	optional           bool
	mock               *DependencyContainerMock
	defaultExpectation *DependencyContainerMockMustGetK8sClientExpectation
	expectations       []*DependencyContainerMockMustGetK8sClientExpectation

	callArgs []*DependencyContainerMockMustGetK8sClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DependencyContainerMockMustGetK8sClientExpectation specifies expectation struct of the DependencyContainer.MustGetK8sClient
type DependencyContainerMockMustGetK8sClientExpectation struct {
	mock               *DependencyContainerMock
	params             *DependencyContainerMockMustGetK8sClientParams
	paramPtrs          *DependencyContainerMockMustGetK8sClientParamPtrs
	expectationOrigins DependencyContainerMockMustGetK8sClientExpectationOrigins
	results            *DependencyContainerMockMustGetK8sClientResults
	returnOrigin       string
	Counter            uint64
}

// DependencyContainerMockMustGetK8sClientParams contains parameters of the DependencyContainer.MustGetK8sClient
type DependencyContainerMockMustGetK8sClientParams struct {
	options []mm_pkg.KubernetesOption
}

// DependencyContainerMockMustGetK8sClientParamPtrs contains pointers to parameters of the DependencyContainer.MustGetK8sClient
type DependencyContainerMockMustGetK8sClientParamPtrs struct {
	options *[]mm_pkg.KubernetesOption
}

// DependencyContainerMockMustGetK8sClientResults contains results of the DependencyContainer.MustGetK8sClient
type DependencyContainerMockMustGetK8sClientResults struct {
	k1 mm_pkg.KubernetesClient
}

// DependencyContainerMockMustGetK8sClientOrigins contains origins of expectations of the DependencyContainer.MustGetK8sClient
type DependencyContainerMockMustGetK8sClientExpectationOrigins struct {
	origin        string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) Optional() *mDependencyContainerMockMustGetK8sClient {
	mmMustGetK8sClient.optional = true
	return mmMustGetK8sClient
}

// Expect sets up expected params for DependencyContainer.MustGetK8sClient
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) Expect(options ...mm_pkg.KubernetesOption) *mDependencyContainerMockMustGetK8sClient {
	if mmMustGetK8sClient.mock.funcMustGetK8sClient != nil {
		mmMustGetK8sClient.mock.t.Fatalf("DependencyContainerMock.MustGetK8sClient mock is already set by Set")
	}

	if mmMustGetK8sClient.defaultExpectation == nil {
		mmMustGetK8sClient.defaultExpectation = &DependencyContainerMockMustGetK8sClientExpectation{}
	}

	if mmMustGetK8sClient.defaultExpectation.paramPtrs != nil {
		mmMustGetK8sClient.mock.t.Fatalf("DependencyContainerMock.MustGetK8sClient mock is already set by ExpectParams functions")
	}

	mmMustGetK8sClient.defaultExpectation.params = &DependencyContainerMockMustGetK8sClientParams{options}
	mmMustGetK8sClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMustGetK8sClient.expectations {
		if minimock.Equal(e.params, mmMustGetK8sClient.defaultExpectation.params) {
			mmMustGetK8sClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMustGetK8sClient.defaultExpectation.params)
		}
	}

	return mmMustGetK8sClient
}

// ExpectOptionsParam1 sets up expected param options for DependencyContainer.MustGetK8sClient
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) ExpectOptionsParam1(options ...mm_pkg.KubernetesOption) *mDependencyContainerMockMustGetK8sClient {
	if mmMustGetK8sClient.mock.funcMustGetK8sClient != nil {
		mmMustGetK8sClient.mock.t.Fatalf("DependencyContainerMock.MustGetK8sClient mock is already set by Set")
	}

	if mmMustGetK8sClient.defaultExpectation == nil {
		mmMustGetK8sClient.defaultExpectation = &DependencyContainerMockMustGetK8sClientExpectation{}
	}

	if mmMustGetK8sClient.defaultExpectation.params != nil {
		mmMustGetK8sClient.mock.t.Fatalf("DependencyContainerMock.MustGetK8sClient mock is already set by Expect")
	}

	if mmMustGetK8sClient.defaultExpectation.paramPtrs == nil {
		mmMustGetK8sClient.defaultExpectation.paramPtrs = &DependencyContainerMockMustGetK8sClientParamPtrs{}
	}
	mmMustGetK8sClient.defaultExpectation.paramPtrs.options = &options
	mmMustGetK8sClient.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmMustGetK8sClient
}

// Inspect accepts an inspector function that has same arguments as the DependencyContainer.MustGetK8sClient
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) Inspect(f func(options ...mm_pkg.KubernetesOption)) *mDependencyContainerMockMustGetK8sClient {
	if mmMustGetK8sClient.mock.inspectFuncMustGetK8sClient != nil {
		mmMustGetK8sClient.mock.t.Fatalf("Inspect function is already set for DependencyContainerMock.MustGetK8sClient")
	}

	mmMustGetK8sClient.mock.inspectFuncMustGetK8sClient = f

	return mmMustGetK8sClient
}

// Return sets up results that will be returned by DependencyContainer.MustGetK8sClient
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) Return(k1 mm_pkg.KubernetesClient) *DependencyContainerMock {
	if mmMustGetK8sClient.mock.funcMustGetK8sClient != nil {
		mmMustGetK8sClient.mock.t.Fatalf("DependencyContainerMock.MustGetK8sClient mock is already set by Set")
	}

	if mmMustGetK8sClient.defaultExpectation == nil {
		mmMustGetK8sClient.defaultExpectation = &DependencyContainerMockMustGetK8sClientExpectation{mock: mmMustGetK8sClient.mock}
	}
	mmMustGetK8sClient.defaultExpectation.results = &DependencyContainerMockMustGetK8sClientResults{k1}
	mmMustGetK8sClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMustGetK8sClient.mock
}

// Set uses given function f to mock the DependencyContainer.MustGetK8sClient method
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) Set(f func(options ...mm_pkg.KubernetesOption) (k1 mm_pkg.KubernetesClient)) *DependencyContainerMock {
	if mmMustGetK8sClient.defaultExpectation != nil {
		mmMustGetK8sClient.mock.t.Fatalf("Default expectation is already set for the DependencyContainer.MustGetK8sClient method")
	}

	if len(mmMustGetK8sClient.expectations) > 0 {
		mmMustGetK8sClient.mock.t.Fatalf("Some expectations are already set for the DependencyContainer.MustGetK8sClient method")
	}

	mmMustGetK8sClient.mock.funcMustGetK8sClient = f
	mmMustGetK8sClient.mock.funcMustGetK8sClientOrigin = minimock.CallerInfo(1)
	return mmMustGetK8sClient.mock
}

// When sets expectation for the DependencyContainer.MustGetK8sClient which will trigger the result defined by the following
// Then helper
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) When(options ...mm_pkg.KubernetesOption) *DependencyContainerMockMustGetK8sClientExpectation {
	if mmMustGetK8sClient.mock.funcMustGetK8sClient != nil {
		mmMustGetK8sClient.mock.t.Fatalf("DependencyContainerMock.MustGetK8sClient mock is already set by Set")
	}

	expectation := &DependencyContainerMockMustGetK8sClientExpectation{
		mock:               mmMustGetK8sClient.mock,
		params:             &DependencyContainerMockMustGetK8sClientParams{options},
		expectationOrigins: DependencyContainerMockMustGetK8sClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMustGetK8sClient.expectations = append(mmMustGetK8sClient.expectations, expectation)
	return expectation
}

// Then sets up DependencyContainer.MustGetK8sClient return parameters for the expectation previously defined by the When method
func (e *DependencyContainerMockMustGetK8sClientExpectation) Then(k1 mm_pkg.KubernetesClient) *DependencyContainerMock {
	e.results = &DependencyContainerMockMustGetK8sClientResults{k1}
	return e.mock
}

// Times sets number of times DependencyContainer.MustGetK8sClient should be invoked
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) Times(n uint64) *mDependencyContainerMockMustGetK8sClient {
	if n == 0 {
		mmMustGetK8sClient.mock.t.Fatalf("Times of DependencyContainerMock.MustGetK8sClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMustGetK8sClient.expectedInvocations, n)
	mmMustGetK8sClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMustGetK8sClient
}

func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) invocationsDone() bool {
	if len(mmMustGetK8sClient.expectations) == 0 && mmMustGetK8sClient.defaultExpectation == nil && mmMustGetK8sClient.mock.funcMustGetK8sClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMustGetK8sClient.mock.afterMustGetK8sClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMustGetK8sClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MustGetK8sClient implements mm_pkg.DependencyContainer
func (mmMustGetK8sClient *DependencyContainerMock) MustGetK8sClient(options ...mm_pkg.KubernetesOption) (k1 mm_pkg.KubernetesClient) {
	mm_atomic.AddUint64(&mmMustGetK8sClient.beforeMustGetK8sClientCounter, 1)
	defer mm_atomic.AddUint64(&mmMustGetK8sClient.afterMustGetK8sClientCounter, 1)

	mmMustGetK8sClient.t.Helper()

	if mmMustGetK8sClient.inspectFuncMustGetK8sClient != nil {
		mmMustGetK8sClient.inspectFuncMustGetK8sClient(options...)
	}

	mm_params := DependencyContainerMockMustGetK8sClientParams{options}

	// Record call args
	mmMustGetK8sClient.MustGetK8sClientMock.mutex.Lock()
	mmMustGetK8sClient.MustGetK8sClientMock.callArgs = append(mmMustGetK8sClient.MustGetK8sClientMock.callArgs, &mm_params)
	mmMustGetK8sClient.MustGetK8sClientMock.mutex.Unlock()

	for _, e := range mmMustGetK8sClient.MustGetK8sClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.k1
		}
	}

	if mmMustGetK8sClient.MustGetK8sClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMustGetK8sClient.MustGetK8sClientMock.defaultExpectation.Counter, 1)
		mm_want := mmMustGetK8sClient.MustGetK8sClientMock.defaultExpectation.params
		mm_want_ptrs := mmMustGetK8sClient.MustGetK8sClientMock.defaultExpectation.paramPtrs

		mm_got := DependencyContainerMockMustGetK8sClientParams{options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmMustGetK8sClient.t.Errorf("DependencyContainerMock.MustGetK8sClient got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMustGetK8sClient.MustGetK8sClientMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMustGetK8sClient.t.Errorf("DependencyContainerMock.MustGetK8sClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMustGetK8sClient.MustGetK8sClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMustGetK8sClient.MustGetK8sClientMock.defaultExpectation.results
		if mm_results == nil {
			mmMustGetK8sClient.t.Fatal("No results are set for the DependencyContainerMock.MustGetK8sClient")
		}
		return (*mm_results).k1
	}
	if mmMustGetK8sClient.funcMustGetK8sClient != nil {
		return mmMustGetK8sClient.funcMustGetK8sClient(options...)
	}
	mmMustGetK8sClient.t.Fatalf("Unexpected call to DependencyContainerMock.MustGetK8sClient. %v", options)
	return
}

// MustGetK8sClientAfterCounter returns a count of finished DependencyContainerMock.MustGetK8sClient invocations
func (mmMustGetK8sClient *DependencyContainerMock) MustGetK8sClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustGetK8sClient.afterMustGetK8sClientCounter)
}

// MustGetK8sClientBeforeCounter returns a count of DependencyContainerMock.MustGetK8sClient invocations
func (mmMustGetK8sClient *DependencyContainerMock) MustGetK8sClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustGetK8sClient.beforeMustGetK8sClientCounter)
}

// Calls returns a list of arguments used in each call to DependencyContainerMock.MustGetK8sClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMustGetK8sClient *mDependencyContainerMockMustGetK8sClient) Calls() []*DependencyContainerMockMustGetK8sClientParams {
	mmMustGetK8sClient.mutex.RLock()

	argCopy := make([]*DependencyContainerMockMustGetK8sClientParams, len(mmMustGetK8sClient.callArgs))
	copy(argCopy, mmMustGetK8sClient.callArgs)

	mmMustGetK8sClient.mutex.RUnlock()

	return argCopy
}

// MinimockMustGetK8sClientDone returns true if the count of the MustGetK8sClient invocations corresponds
// the number of defined expectations
func (m *DependencyContainerMock) MinimockMustGetK8sClientDone() bool {
	if m.MustGetK8sClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MustGetK8sClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MustGetK8sClientMock.invocationsDone()
}

// MinimockMustGetK8sClientInspect logs each unmet expectation
func (m *DependencyContainerMock) MinimockMustGetK8sClientInspect() {
	for _, e := range m.MustGetK8sClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DependencyContainerMock.MustGetK8sClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMustGetK8sClientCounter := mm_atomic.LoadUint64(&m.afterMustGetK8sClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MustGetK8sClientMock.defaultExpectation != nil && afterMustGetK8sClientCounter < 1 {
		if m.MustGetK8sClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DependencyContainerMock.MustGetK8sClient at\n%s", m.MustGetK8sClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DependencyContainerMock.MustGetK8sClient at\n%s with params: %#v", m.MustGetK8sClientMock.defaultExpectation.expectationOrigins.origin, *m.MustGetK8sClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMustGetK8sClient != nil && afterMustGetK8sClientCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.MustGetK8sClient at\n%s", m.funcMustGetK8sClientOrigin)
	}

	if !m.MustGetK8sClientMock.invocationsDone() && afterMustGetK8sClientCounter > 0 {
		m.t.Errorf("Expected %d calls to DependencyContainerMock.MustGetK8sClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MustGetK8sClientMock.expectedInvocations), m.MustGetK8sClientMock.expectedInvocationsOrigin, afterMustGetK8sClientCounter)
	}
}

type mDependencyContainerMockMustGetRegistryClient struct {
	optional           bool
	mock               *DependencyContainerMock
	defaultExpectation *DependencyContainerMockMustGetRegistryClientExpectation
	expectations       []*DependencyContainerMockMustGetRegistryClientExpectation

	callArgs []*DependencyContainerMockMustGetRegistryClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DependencyContainerMockMustGetRegistryClientExpectation specifies expectation struct of the DependencyContainer.MustGetRegistryClient
type DependencyContainerMockMustGetRegistryClientExpectation struct {
	mock               *DependencyContainerMock
	params             *DependencyContainerMockMustGetRegistryClientParams
	paramPtrs          *DependencyContainerMockMustGetRegistryClientParamPtrs
	expectationOrigins DependencyContainerMockMustGetRegistryClientExpectationOrigins
	results            *DependencyContainerMockMustGetRegistryClientResults
	returnOrigin       string
	Counter            uint64
}

// DependencyContainerMockMustGetRegistryClientParams contains parameters of the DependencyContainer.MustGetRegistryClient
type DependencyContainerMockMustGetRegistryClientParams struct {
	repo    string
	options []mm_pkg.RegistryOption
}

// DependencyContainerMockMustGetRegistryClientParamPtrs contains pointers to parameters of the DependencyContainer.MustGetRegistryClient
type DependencyContainerMockMustGetRegistryClientParamPtrs struct {
	repo    *string
	options *[]mm_pkg.RegistryOption
}

// DependencyContainerMockMustGetRegistryClientResults contains results of the DependencyContainer.MustGetRegistryClient
type DependencyContainerMockMustGetRegistryClientResults struct {
	r1 mm_pkg.RegistryClient
}

// DependencyContainerMockMustGetRegistryClientOrigins contains origins of expectations of the DependencyContainer.MustGetRegistryClient
type DependencyContainerMockMustGetRegistryClientExpectationOrigins struct {
	origin        string
	originRepo    string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) Optional() *mDependencyContainerMockMustGetRegistryClient {
	mmMustGetRegistryClient.optional = true
	return mmMustGetRegistryClient
}

// Expect sets up expected params for DependencyContainer.MustGetRegistryClient
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) Expect(repo string, options ...mm_pkg.RegistryOption) *mDependencyContainerMockMustGetRegistryClient {
	if mmMustGetRegistryClient.mock.funcMustGetRegistryClient != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by Set")
	}

	if mmMustGetRegistryClient.defaultExpectation == nil {
		mmMustGetRegistryClient.defaultExpectation = &DependencyContainerMockMustGetRegistryClientExpectation{}
	}

	if mmMustGetRegistryClient.defaultExpectation.paramPtrs != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by ExpectParams functions")
	}

	mmMustGetRegistryClient.defaultExpectation.params = &DependencyContainerMockMustGetRegistryClientParams{repo, options}
	mmMustGetRegistryClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMustGetRegistryClient.expectations {
		if minimock.Equal(e.params, mmMustGetRegistryClient.defaultExpectation.params) {
			mmMustGetRegistryClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMustGetRegistryClient.defaultExpectation.params)
		}
	}

	return mmMustGetRegistryClient
}

// ExpectRepoParam1 sets up expected param repo for DependencyContainer.MustGetRegistryClient
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) ExpectRepoParam1(repo string) *mDependencyContainerMockMustGetRegistryClient {
	if mmMustGetRegistryClient.mock.funcMustGetRegistryClient != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by Set")
	}

	if mmMustGetRegistryClient.defaultExpectation == nil {
		mmMustGetRegistryClient.defaultExpectation = &DependencyContainerMockMustGetRegistryClientExpectation{}
	}

	if mmMustGetRegistryClient.defaultExpectation.params != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by Expect")
	}

	if mmMustGetRegistryClient.defaultExpectation.paramPtrs == nil {
		mmMustGetRegistryClient.defaultExpectation.paramPtrs = &DependencyContainerMockMustGetRegistryClientParamPtrs{}
	}
	mmMustGetRegistryClient.defaultExpectation.paramPtrs.repo = &repo
	mmMustGetRegistryClient.defaultExpectation.expectationOrigins.originRepo = minimock.CallerInfo(1)

	return mmMustGetRegistryClient
}

// ExpectOptionsParam2 sets up expected param options for DependencyContainer.MustGetRegistryClient
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) ExpectOptionsParam2(options ...mm_pkg.RegistryOption) *mDependencyContainerMockMustGetRegistryClient {
	if mmMustGetRegistryClient.mock.funcMustGetRegistryClient != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by Set")
	}

	if mmMustGetRegistryClient.defaultExpectation == nil {
		mmMustGetRegistryClient.defaultExpectation = &DependencyContainerMockMustGetRegistryClientExpectation{}
	}

	if mmMustGetRegistryClient.defaultExpectation.params != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by Expect")
	}

	if mmMustGetRegistryClient.defaultExpectation.paramPtrs == nil {
		mmMustGetRegistryClient.defaultExpectation.paramPtrs = &DependencyContainerMockMustGetRegistryClientParamPtrs{}
	}
	mmMustGetRegistryClient.defaultExpectation.paramPtrs.options = &options
	mmMustGetRegistryClient.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmMustGetRegistryClient
}

// Inspect accepts an inspector function that has same arguments as the DependencyContainer.MustGetRegistryClient
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) Inspect(f func(repo string, options ...mm_pkg.RegistryOption)) *mDependencyContainerMockMustGetRegistryClient {
	if mmMustGetRegistryClient.mock.inspectFuncMustGetRegistryClient != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("Inspect function is already set for DependencyContainerMock.MustGetRegistryClient")
	}

	mmMustGetRegistryClient.mock.inspectFuncMustGetRegistryClient = f

	return mmMustGetRegistryClient
}

// Return sets up results that will be returned by DependencyContainer.MustGetRegistryClient
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) Return(r1 mm_pkg.RegistryClient) *DependencyContainerMock {
	if mmMustGetRegistryClient.mock.funcMustGetRegistryClient != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by Set")
	}

	if mmMustGetRegistryClient.defaultExpectation == nil {
		mmMustGetRegistryClient.defaultExpectation = &DependencyContainerMockMustGetRegistryClientExpectation{mock: mmMustGetRegistryClient.mock}
	}
	mmMustGetRegistryClient.defaultExpectation.results = &DependencyContainerMockMustGetRegistryClientResults{r1}
	mmMustGetRegistryClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMustGetRegistryClient.mock
}

// Set uses given function f to mock the DependencyContainer.MustGetRegistryClient method
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) Set(f func(repo string, options ...mm_pkg.RegistryOption) (r1 mm_pkg.RegistryClient)) *DependencyContainerMock {
	if mmMustGetRegistryClient.defaultExpectation != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("Default expectation is already set for the DependencyContainer.MustGetRegistryClient method")
	}

	if len(mmMustGetRegistryClient.expectations) > 0 {
		mmMustGetRegistryClient.mock.t.Fatalf("Some expectations are already set for the DependencyContainer.MustGetRegistryClient method")
	}

	mmMustGetRegistryClient.mock.funcMustGetRegistryClient = f
	mmMustGetRegistryClient.mock.funcMustGetRegistryClientOrigin = minimock.CallerInfo(1)
	return mmMustGetRegistryClient.mock
}

// When sets expectation for the DependencyContainer.MustGetRegistryClient which will trigger the result defined by the following
// Then helper
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) When(repo string, options ...mm_pkg.RegistryOption) *DependencyContainerMockMustGetRegistryClientExpectation {
	if mmMustGetRegistryClient.mock.funcMustGetRegistryClient != nil {
		mmMustGetRegistryClient.mock.t.Fatalf("DependencyContainerMock.MustGetRegistryClient mock is already set by Set")
	}

	expectation := &DependencyContainerMockMustGetRegistryClientExpectation{
		mock:               mmMustGetRegistryClient.mock,
		params:             &DependencyContainerMockMustGetRegistryClientParams{repo, options},
		expectationOrigins: DependencyContainerMockMustGetRegistryClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMustGetRegistryClient.expectations = append(mmMustGetRegistryClient.expectations, expectation)
	return expectation
}

// Then sets up DependencyContainer.MustGetRegistryClient return parameters for the expectation previously defined by the When method
func (e *DependencyContainerMockMustGetRegistryClientExpectation) Then(r1 mm_pkg.RegistryClient) *DependencyContainerMock {
	e.results = &DependencyContainerMockMustGetRegistryClientResults{r1}
	return e.mock
}

// Times sets number of times DependencyContainer.MustGetRegistryClient should be invoked
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) Times(n uint64) *mDependencyContainerMockMustGetRegistryClient {
	if n == 0 {
		mmMustGetRegistryClient.mock.t.Fatalf("Times of DependencyContainerMock.MustGetRegistryClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMustGetRegistryClient.expectedInvocations, n)
	mmMustGetRegistryClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMustGetRegistryClient
}

func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) invocationsDone() bool {
	if len(mmMustGetRegistryClient.expectations) == 0 && mmMustGetRegistryClient.defaultExpectation == nil && mmMustGetRegistryClient.mock.funcMustGetRegistryClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMustGetRegistryClient.mock.afterMustGetRegistryClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMustGetRegistryClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MustGetRegistryClient implements mm_pkg.DependencyContainer
func (mmMustGetRegistryClient *DependencyContainerMock) MustGetRegistryClient(repo string, options ...mm_pkg.RegistryOption) (r1 mm_pkg.RegistryClient) {
	mm_atomic.AddUint64(&mmMustGetRegistryClient.beforeMustGetRegistryClientCounter, 1)
	defer mm_atomic.AddUint64(&mmMustGetRegistryClient.afterMustGetRegistryClientCounter, 1)

	mmMustGetRegistryClient.t.Helper()

	if mmMustGetRegistryClient.inspectFuncMustGetRegistryClient != nil {
		mmMustGetRegistryClient.inspectFuncMustGetRegistryClient(repo, options...)
	}

	mm_params := DependencyContainerMockMustGetRegistryClientParams{repo, options}

	// Record call args
	mmMustGetRegistryClient.MustGetRegistryClientMock.mutex.Lock()
	mmMustGetRegistryClient.MustGetRegistryClientMock.callArgs = append(mmMustGetRegistryClient.MustGetRegistryClientMock.callArgs, &mm_params)
	mmMustGetRegistryClient.MustGetRegistryClientMock.mutex.Unlock()

	for _, e := range mmMustGetRegistryClient.MustGetRegistryClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation.Counter, 1)
		mm_want := mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation.params
		mm_want_ptrs := mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation.paramPtrs

		mm_got := DependencyContainerMockMustGetRegistryClientParams{repo, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.repo != nil && !minimock.Equal(*mm_want_ptrs.repo, mm_got.repo) {
				mmMustGetRegistryClient.t.Errorf("DependencyContainerMock.MustGetRegistryClient got unexpected parameter repo, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation.expectationOrigins.originRepo, *mm_want_ptrs.repo, mm_got.repo, minimock.Diff(*mm_want_ptrs.repo, mm_got.repo))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmMustGetRegistryClient.t.Errorf("DependencyContainerMock.MustGetRegistryClient got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMustGetRegistryClient.t.Errorf("DependencyContainerMock.MustGetRegistryClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMustGetRegistryClient.MustGetRegistryClientMock.defaultExpectation.results
		if mm_results == nil {
			mmMustGetRegistryClient.t.Fatal("No results are set for the DependencyContainerMock.MustGetRegistryClient")
		}
		return (*mm_results).r1
	}
	if mmMustGetRegistryClient.funcMustGetRegistryClient != nil {
		return mmMustGetRegistryClient.funcMustGetRegistryClient(repo, options...)
	}
	mmMustGetRegistryClient.t.Fatalf("Unexpected call to DependencyContainerMock.MustGetRegistryClient. %v %v", repo, options)
	return
}

// MustGetRegistryClientAfterCounter returns a count of finished DependencyContainerMock.MustGetRegistryClient invocations
func (mmMustGetRegistryClient *DependencyContainerMock) MustGetRegistryClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustGetRegistryClient.afterMustGetRegistryClientCounter)
}

// MustGetRegistryClientBeforeCounter returns a count of DependencyContainerMock.MustGetRegistryClient invocations
func (mmMustGetRegistryClient *DependencyContainerMock) MustGetRegistryClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustGetRegistryClient.beforeMustGetRegistryClientCounter)
}

// Calls returns a list of arguments used in each call to DependencyContainerMock.MustGetRegistryClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMustGetRegistryClient *mDependencyContainerMockMustGetRegistryClient) Calls() []*DependencyContainerMockMustGetRegistryClientParams {
	mmMustGetRegistryClient.mutex.RLock()

	argCopy := make([]*DependencyContainerMockMustGetRegistryClientParams, len(mmMustGetRegistryClient.callArgs))
	copy(argCopy, mmMustGetRegistryClient.callArgs)

	mmMustGetRegistryClient.mutex.RUnlock()

	return argCopy
}

// MinimockMustGetRegistryClientDone returns true if the count of the MustGetRegistryClient invocations corresponds
// the number of defined expectations
func (m *DependencyContainerMock) MinimockMustGetRegistryClientDone() bool {
	if m.MustGetRegistryClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MustGetRegistryClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MustGetRegistryClientMock.invocationsDone()
}

// MinimockMustGetRegistryClientInspect logs each unmet expectation
func (m *DependencyContainerMock) MinimockMustGetRegistryClientInspect() {
	for _, e := range m.MustGetRegistryClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DependencyContainerMock.MustGetRegistryClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMustGetRegistryClientCounter := mm_atomic.LoadUint64(&m.afterMustGetRegistryClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MustGetRegistryClientMock.defaultExpectation != nil && afterMustGetRegistryClientCounter < 1 {
		if m.MustGetRegistryClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DependencyContainerMock.MustGetRegistryClient at\n%s", m.MustGetRegistryClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DependencyContainerMock.MustGetRegistryClient at\n%s with params: %#v", m.MustGetRegistryClientMock.defaultExpectation.expectationOrigins.origin, *m.MustGetRegistryClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMustGetRegistryClient != nil && afterMustGetRegistryClientCounter < 1 {
		m.t.Errorf("Expected call to DependencyContainerMock.MustGetRegistryClient at\n%s", m.funcMustGetRegistryClientOrigin)
	}

	if !m.MustGetRegistryClientMock.invocationsDone() && afterMustGetRegistryClientCounter > 0 {
		m.t.Errorf("Expected %d calls to DependencyContainerMock.MustGetRegistryClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MustGetRegistryClientMock.expectedInvocations), m.MustGetRegistryClientMock.expectedInvocationsOrigin, afterMustGetRegistryClientCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DependencyContainerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetClientConfigInspect()

			m.MinimockGetClockInspect()

			m.MinimockGetHTTPClientInspect()

			m.MinimockGetK8sClientInspect()

			m.MinimockGetRegistryClientInspect()

			m.MinimockMustGetK8sClientInspect()

			m.MinimockMustGetRegistryClientInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DependencyContainerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DependencyContainerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetClientConfigDone() &&
		m.MinimockGetClockDone() &&
		m.MinimockGetHTTPClientDone() &&
		m.MinimockGetK8sClientDone() &&
		m.MinimockGetRegistryClientDone() &&
		m.MinimockMustGetK8sClientDone() &&
		m.MinimockMustGetRegistryClientDone()
}
