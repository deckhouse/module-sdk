// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i k8s.io/client-go/dynamic.NamespaceableResourceInterface -o kubernetes_namespaceable_resource_interface_mock.go -n KubernetesNamespaceableResourceInterfaceMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	mm_dynamic "k8s.io/client-go/dynamic"
)

// KubernetesNamespaceableResourceInterfaceMock implements mm_dynamic.NamespaceableResourceInterface
type KubernetesNamespaceableResourceInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcApply          func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)
	funcApplyOrigin    string
	inspectFuncApply   func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string)
	afterApplyCounter  uint64
	beforeApplyCounter uint64
	ApplyMock          mKubernetesNamespaceableResourceInterfaceMockApply

	funcApplyStatus          func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions) (up1 *unstructured.Unstructured, err error)
	funcApplyStatusOrigin    string
	inspectFuncApplyStatus   func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions)
	afterApplyStatusCounter  uint64
	beforeApplyStatusCounter uint64
	ApplyStatusMock          mKubernetesNamespaceableResourceInterfaceMockApplyStatus

	funcCreate          func(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mKubernetesNamespaceableResourceInterfaceMockCreate

	funcDelete          func(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mKubernetesNamespaceableResourceInterfaceMockDelete

	funcDeleteCollection          func(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions) (err error)
	funcDeleteCollectionOrigin    string
	inspectFuncDeleteCollection   func(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions)
	afterDeleteCollectionCounter  uint64
	beforeDeleteCollectionCounter uint64
	DeleteCollectionMock          mKubernetesNamespaceableResourceInterfaceMockDeleteCollection

	funcGet          func(ctx context.Context, name string, options metav1.GetOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, name string, options metav1.GetOptions, subresources ...string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mKubernetesNamespaceableResourceInterfaceMockGet

	funcList          func(ctx context.Context, opts metav1.ListOptions) (up1 *unstructured.UnstructuredList, err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, opts metav1.ListOptions)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mKubernetesNamespaceableResourceInterfaceMockList

	funcNamespace          func(s1 string) (r1 mm_dynamic.ResourceInterface)
	funcNamespaceOrigin    string
	inspectFuncNamespace   func(s1 string)
	afterNamespaceCounter  uint64
	beforeNamespaceCounter uint64
	NamespaceMock          mKubernetesNamespaceableResourceInterfaceMockNamespace

	funcPatch          func(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)
	funcPatchOrigin    string
	inspectFuncPatch   func(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string)
	afterPatchCounter  uint64
	beforePatchCounter uint64
	PatchMock          mKubernetesNamespaceableResourceInterfaceMockPatch

	funcUpdate          func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mKubernetesNamespaceableResourceInterfaceMockUpdate

	funcUpdateStatus          func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions) (up1 *unstructured.Unstructured, err error)
	funcUpdateStatusOrigin    string
	inspectFuncUpdateStatus   func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions)
	afterUpdateStatusCounter  uint64
	beforeUpdateStatusCounter uint64
	UpdateStatusMock          mKubernetesNamespaceableResourceInterfaceMockUpdateStatus

	funcWatch          func(ctx context.Context, opts metav1.ListOptions) (i1 watch.Interface, err error)
	funcWatchOrigin    string
	inspectFuncWatch   func(ctx context.Context, opts metav1.ListOptions)
	afterWatchCounter  uint64
	beforeWatchCounter uint64
	WatchMock          mKubernetesNamespaceableResourceInterfaceMockWatch
}

// NewKubernetesNamespaceableResourceInterfaceMock returns a mock for mm_dynamic.NamespaceableResourceInterface
func NewKubernetesNamespaceableResourceInterfaceMock(t minimock.Tester) *KubernetesNamespaceableResourceInterfaceMock {
	m := &KubernetesNamespaceableResourceInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApplyMock = mKubernetesNamespaceableResourceInterfaceMockApply{mock: m}
	m.ApplyMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockApplyParams{}

	m.ApplyStatusMock = mKubernetesNamespaceableResourceInterfaceMockApplyStatus{mock: m}
	m.ApplyStatusMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockApplyStatusParams{}

	m.CreateMock = mKubernetesNamespaceableResourceInterfaceMockCreate{mock: m}
	m.CreateMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockCreateParams{}

	m.DeleteMock = mKubernetesNamespaceableResourceInterfaceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockDeleteParams{}

	m.DeleteCollectionMock = mKubernetesNamespaceableResourceInterfaceMockDeleteCollection{mock: m}
	m.DeleteCollectionMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams{}

	m.GetMock = mKubernetesNamespaceableResourceInterfaceMockGet{mock: m}
	m.GetMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockGetParams{}

	m.ListMock = mKubernetesNamespaceableResourceInterfaceMockList{mock: m}
	m.ListMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockListParams{}

	m.NamespaceMock = mKubernetesNamespaceableResourceInterfaceMockNamespace{mock: m}
	m.NamespaceMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockNamespaceParams{}

	m.PatchMock = mKubernetesNamespaceableResourceInterfaceMockPatch{mock: m}
	m.PatchMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockPatchParams{}

	m.UpdateMock = mKubernetesNamespaceableResourceInterfaceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockUpdateParams{}

	m.UpdateStatusMock = mKubernetesNamespaceableResourceInterfaceMockUpdateStatus{mock: m}
	m.UpdateStatusMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams{}

	m.WatchMock = mKubernetesNamespaceableResourceInterfaceMockWatch{mock: m}
	m.WatchMock.callArgs = []*KubernetesNamespaceableResourceInterfaceMockWatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mKubernetesNamespaceableResourceInterfaceMockApply struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockApplyExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockApplyExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockApplyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockApplyExpectation specifies expectation struct of the NamespaceableResourceInterface.Apply
type KubernetesNamespaceableResourceInterfaceMockApplyExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockApplyParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockApplyExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockApplyResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockApplyParams contains parameters of the NamespaceableResourceInterface.Apply
type KubernetesNamespaceableResourceInterfaceMockApplyParams struct {
	ctx          context.Context
	name         string
	obj          *unstructured.Unstructured
	options      metav1.ApplyOptions
	subresources []string
}

// KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Apply
type KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs struct {
	ctx          *context.Context
	name         *string
	obj          **unstructured.Unstructured
	options      *metav1.ApplyOptions
	subresources *[]string
}

// KubernetesNamespaceableResourceInterfaceMockApplyResults contains results of the NamespaceableResourceInterface.Apply
type KubernetesNamespaceableResourceInterfaceMockApplyResults struct {
	up1 *unstructured.Unstructured
	err error
}

// KubernetesNamespaceableResourceInterfaceMockApplyOrigins contains origins of expectations of the NamespaceableResourceInterface.Apply
type KubernetesNamespaceableResourceInterfaceMockApplyExpectationOrigins struct {
	origin             string
	originCtx          string
	originName         string
	originObj          string
	originOptions      string
	originSubresources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) Optional() *mKubernetesNamespaceableResourceInterfaceMockApply {
	mmApply.optional = true
	return mmApply
}

// Expect sets up expected params for NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) Expect(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.paramPtrs != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by ExpectParams functions")
	}

	mmApply.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockApplyParams{ctx, name, obj, options, subresources}
	mmApply.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApply.expectations {
		if minimock.Equal(e.params, mmApply.defaultExpectation.params) {
			mmApply.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApply.defaultExpectation.params)
		}
	}

	return mmApply
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.ctx = &ctx
	mmApply.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmApply
}

// ExpectNameParam2 sets up expected param name for NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) ExpectNameParam2(name string) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.name = &name
	mmApply.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmApply
}

// ExpectObjParam3 sets up expected param obj for NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) ExpectObjParam3(obj *unstructured.Unstructured) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.obj = &obj
	mmApply.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmApply
}

// ExpectOptionsParam4 sets up expected param options for NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) ExpectOptionsParam4(options metav1.ApplyOptions) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.options = &options
	mmApply.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmApply
}

// ExpectSubresourcesParam5 sets up expected param subresources for NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) ExpectSubresourcesParam5(subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{}
	}

	if mmApply.defaultExpectation.params != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Expect")
	}

	if mmApply.defaultExpectation.paramPtrs == nil {
		mmApply.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyParamPtrs{}
	}
	mmApply.defaultExpectation.paramPtrs.subresources = &subresources
	mmApply.defaultExpectation.expectationOrigins.originSubresources = minimock.CallerInfo(1)

	return mmApply
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) Inspect(f func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string)) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if mmApply.mock.inspectFuncApply != nil {
		mmApply.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Apply")
	}

	mmApply.mock.inspectFuncApply = f

	return mmApply
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Apply
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) Return(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	if mmApply.defaultExpectation == nil {
		mmApply.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{mock: mmApply.mock}
	}
	mmApply.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockApplyResults{up1, err}
	mmApply.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApply.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Apply method
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) Set(f func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmApply.defaultExpectation != nil {
		mmApply.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Apply method")
	}

	if len(mmApply.expectations) > 0 {
		mmApply.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Apply method")
	}

	mmApply.mock.funcApply = f
	mmApply.mock.funcApplyOrigin = minimock.CallerInfo(1)
	return mmApply.mock
}

// When sets expectation for the NamespaceableResourceInterface.Apply which will trigger the result defined by the following
// Then helper
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) When(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string) *KubernetesNamespaceableResourceInterfaceMockApplyExpectation {
	if mmApply.mock.funcApply != nil {
		mmApply.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Apply mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockApplyExpectation{
		mock:               mmApply.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockApplyParams{ctx, name, obj, options, subresources},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockApplyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmApply.expectations = append(mmApply.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Apply return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockApplyExpectation) Then(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockApplyResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Apply should be invoked
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockApply {
	if n == 0 {
		mmApply.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Apply mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApply.expectedInvocations, n)
	mmApply.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApply
}

func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) invocationsDone() bool {
	if len(mmApply.expectations) == 0 && mmApply.defaultExpectation == nil && mmApply.mock.funcApply == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApply.mock.afterApplyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApply.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Apply implements mm_dynamic.NamespaceableResourceInterface
func (mmApply *KubernetesNamespaceableResourceInterfaceMock) Apply(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string) (up1 *unstructured.Unstructured, err error) {
	mm_atomic.AddUint64(&mmApply.beforeApplyCounter, 1)
	defer mm_atomic.AddUint64(&mmApply.afterApplyCounter, 1)

	mmApply.t.Helper()

	if mmApply.inspectFuncApply != nil {
		mmApply.inspectFuncApply(ctx, name, obj, options, subresources...)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockApplyParams{ctx, name, obj, options, subresources}

	// Record call args
	mmApply.ApplyMock.mutex.Lock()
	mmApply.ApplyMock.callArgs = append(mmApply.ApplyMock.callArgs, &mm_params)
	mmApply.ApplyMock.mutex.Unlock()

	for _, e := range mmApply.ApplyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmApply.ApplyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApply.ApplyMock.defaultExpectation.Counter, 1)
		mm_want := mmApply.ApplyMock.defaultExpectation.params
		mm_want_ptrs := mmApply.ApplyMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockApplyParams{ctx, name, obj, options, subresources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmApply.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Apply got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmApply.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Apply got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmApply.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Apply got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmApply.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Apply got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

			if mm_want_ptrs.subresources != nil && !minimock.Equal(*mm_want_ptrs.subresources, mm_got.subresources) {
				mmApply.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Apply got unexpected parameter subresources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApply.ApplyMock.defaultExpectation.expectationOrigins.originSubresources, *mm_want_ptrs.subresources, mm_got.subresources, minimock.Diff(*mm_want_ptrs.subresources, mm_got.subresources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApply.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Apply got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApply.ApplyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApply.ApplyMock.defaultExpectation.results
		if mm_results == nil {
			mmApply.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Apply")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmApply.funcApply != nil {
		return mmApply.funcApply(ctx, name, obj, options, subresources...)
	}
	mmApply.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Apply. %v %v %v %v %v", ctx, name, obj, options, subresources)
	return
}

// ApplyAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Apply invocations
func (mmApply *KubernetesNamespaceableResourceInterfaceMock) ApplyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApply.afterApplyCounter)
}

// ApplyBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Apply invocations
func (mmApply *KubernetesNamespaceableResourceInterfaceMock) ApplyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApply.beforeApplyCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Apply.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApply *mKubernetesNamespaceableResourceInterfaceMockApply) Calls() []*KubernetesNamespaceableResourceInterfaceMockApplyParams {
	mmApply.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockApplyParams, len(mmApply.callArgs))
	copy(argCopy, mmApply.callArgs)

	mmApply.mutex.RUnlock()

	return argCopy
}

// MinimockApplyDone returns true if the count of the Apply invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockApplyDone() bool {
	if m.ApplyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyMock.invocationsDone()
}

// MinimockApplyInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockApplyInspect() {
	for _, e := range m.ApplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Apply at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyCounter := mm_atomic.LoadUint64(&m.afterApplyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyMock.defaultExpectation != nil && afterApplyCounter < 1 {
		if m.ApplyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Apply at\n%s", m.ApplyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Apply at\n%s with params: %#v", m.ApplyMock.defaultExpectation.expectationOrigins.origin, *m.ApplyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApply != nil && afterApplyCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Apply at\n%s", m.funcApplyOrigin)
	}

	if !m.ApplyMock.invocationsDone() && afterApplyCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Apply at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyMock.expectedInvocations), m.ApplyMock.expectedInvocationsOrigin, afterApplyCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockApplyStatus struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockApplyStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation specifies expectation struct of the NamespaceableResourceInterface.ApplyStatus
type KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockApplyStatusParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockApplyStatusParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockApplyStatusResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockApplyStatusParams contains parameters of the NamespaceableResourceInterface.ApplyStatus
type KubernetesNamespaceableResourceInterfaceMockApplyStatusParams struct {
	ctx     context.Context
	name    string
	obj     *unstructured.Unstructured
	options metav1.ApplyOptions
}

// KubernetesNamespaceableResourceInterfaceMockApplyStatusParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.ApplyStatus
type KubernetesNamespaceableResourceInterfaceMockApplyStatusParamPtrs struct {
	ctx     *context.Context
	name    *string
	obj     **unstructured.Unstructured
	options *metav1.ApplyOptions
}

// KubernetesNamespaceableResourceInterfaceMockApplyStatusResults contains results of the NamespaceableResourceInterface.ApplyStatus
type KubernetesNamespaceableResourceInterfaceMockApplyStatusResults struct {
	up1 *unstructured.Unstructured
	err error
}

// KubernetesNamespaceableResourceInterfaceMockApplyStatusOrigins contains origins of expectations of the NamespaceableResourceInterface.ApplyStatus
type KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectationOrigins struct {
	origin        string
	originCtx     string
	originName    string
	originObj     string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) Optional() *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	mmApplyStatus.optional = true
	return mmApplyStatus
}

// Expect sets up expected params for NamespaceableResourceInterface.ApplyStatus
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) Expect(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions) *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	if mmApplyStatus.mock.funcApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Set")
	}

	if mmApplyStatus.defaultExpectation == nil {
		mmApplyStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation{}
	}

	if mmApplyStatus.defaultExpectation.paramPtrs != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by ExpectParams functions")
	}

	mmApplyStatus.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockApplyStatusParams{ctx, name, obj, options}
	mmApplyStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApplyStatus.expectations {
		if minimock.Equal(e.params, mmApplyStatus.defaultExpectation.params) {
			mmApplyStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyStatus.defaultExpectation.params)
		}
	}

	return mmApplyStatus
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.ApplyStatus
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	if mmApplyStatus.mock.funcApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Set")
	}

	if mmApplyStatus.defaultExpectation == nil {
		mmApplyStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation{}
	}

	if mmApplyStatus.defaultExpectation.params != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Expect")
	}

	if mmApplyStatus.defaultExpectation.paramPtrs == nil {
		mmApplyStatus.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyStatusParamPtrs{}
	}
	mmApplyStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmApplyStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmApplyStatus
}

// ExpectNameParam2 sets up expected param name for NamespaceableResourceInterface.ApplyStatus
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) ExpectNameParam2(name string) *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	if mmApplyStatus.mock.funcApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Set")
	}

	if mmApplyStatus.defaultExpectation == nil {
		mmApplyStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation{}
	}

	if mmApplyStatus.defaultExpectation.params != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Expect")
	}

	if mmApplyStatus.defaultExpectation.paramPtrs == nil {
		mmApplyStatus.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyStatusParamPtrs{}
	}
	mmApplyStatus.defaultExpectation.paramPtrs.name = &name
	mmApplyStatus.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmApplyStatus
}

// ExpectObjParam3 sets up expected param obj for NamespaceableResourceInterface.ApplyStatus
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) ExpectObjParam3(obj *unstructured.Unstructured) *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	if mmApplyStatus.mock.funcApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Set")
	}

	if mmApplyStatus.defaultExpectation == nil {
		mmApplyStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation{}
	}

	if mmApplyStatus.defaultExpectation.params != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Expect")
	}

	if mmApplyStatus.defaultExpectation.paramPtrs == nil {
		mmApplyStatus.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyStatusParamPtrs{}
	}
	mmApplyStatus.defaultExpectation.paramPtrs.obj = &obj
	mmApplyStatus.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmApplyStatus
}

// ExpectOptionsParam4 sets up expected param options for NamespaceableResourceInterface.ApplyStatus
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) ExpectOptionsParam4(options metav1.ApplyOptions) *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	if mmApplyStatus.mock.funcApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Set")
	}

	if mmApplyStatus.defaultExpectation == nil {
		mmApplyStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation{}
	}

	if mmApplyStatus.defaultExpectation.params != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Expect")
	}

	if mmApplyStatus.defaultExpectation.paramPtrs == nil {
		mmApplyStatus.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockApplyStatusParamPtrs{}
	}
	mmApplyStatus.defaultExpectation.paramPtrs.options = &options
	mmApplyStatus.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmApplyStatus
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.ApplyStatus
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) Inspect(f func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions)) *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	if mmApplyStatus.mock.inspectFuncApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.ApplyStatus")
	}

	mmApplyStatus.mock.inspectFuncApplyStatus = f

	return mmApplyStatus
}

// Return sets up results that will be returned by NamespaceableResourceInterface.ApplyStatus
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) Return(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmApplyStatus.mock.funcApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Set")
	}

	if mmApplyStatus.defaultExpectation == nil {
		mmApplyStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation{mock: mmApplyStatus.mock}
	}
	mmApplyStatus.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockApplyStatusResults{up1, err}
	mmApplyStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApplyStatus.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.ApplyStatus method
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) Set(f func(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions) (up1 *unstructured.Unstructured, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmApplyStatus.defaultExpectation != nil {
		mmApplyStatus.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.ApplyStatus method")
	}

	if len(mmApplyStatus.expectations) > 0 {
		mmApplyStatus.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.ApplyStatus method")
	}

	mmApplyStatus.mock.funcApplyStatus = f
	mmApplyStatus.mock.funcApplyStatusOrigin = minimock.CallerInfo(1)
	return mmApplyStatus.mock
}

// When sets expectation for the NamespaceableResourceInterface.ApplyStatus which will trigger the result defined by the following
// Then helper
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) When(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions) *KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation {
	if mmApplyStatus.mock.funcApplyStatus != nil {
		mmApplyStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation{
		mock:               mmApplyStatus.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockApplyStatusParams{ctx, name, obj, options},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmApplyStatus.expectations = append(mmApplyStatus.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.ApplyStatus return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockApplyStatusExpectation) Then(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockApplyStatusResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.ApplyStatus should be invoked
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockApplyStatus {
	if n == 0 {
		mmApplyStatus.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.ApplyStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApplyStatus.expectedInvocations, n)
	mmApplyStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApplyStatus
}

func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) invocationsDone() bool {
	if len(mmApplyStatus.expectations) == 0 && mmApplyStatus.defaultExpectation == nil && mmApplyStatus.mock.funcApplyStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApplyStatus.mock.afterApplyStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApplyStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ApplyStatus implements mm_dynamic.NamespaceableResourceInterface
func (mmApplyStatus *KubernetesNamespaceableResourceInterfaceMock) ApplyStatus(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions) (up1 *unstructured.Unstructured, err error) {
	mm_atomic.AddUint64(&mmApplyStatus.beforeApplyStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyStatus.afterApplyStatusCounter, 1)

	mmApplyStatus.t.Helper()

	if mmApplyStatus.inspectFuncApplyStatus != nil {
		mmApplyStatus.inspectFuncApplyStatus(ctx, name, obj, options)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockApplyStatusParams{ctx, name, obj, options}

	// Record call args
	mmApplyStatus.ApplyStatusMock.mutex.Lock()
	mmApplyStatus.ApplyStatusMock.callArgs = append(mmApplyStatus.ApplyStatusMock.callArgs, &mm_params)
	mmApplyStatus.ApplyStatusMock.mutex.Unlock()

	for _, e := range mmApplyStatus.ApplyStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmApplyStatus.ApplyStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyStatus.ApplyStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyStatus.ApplyStatusMock.defaultExpectation.params
		mm_want_ptrs := mmApplyStatus.ApplyStatusMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockApplyStatusParams{ctx, name, obj, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmApplyStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyStatus.ApplyStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmApplyStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyStatus.ApplyStatusMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmApplyStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyStatus.ApplyStatusMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmApplyStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyStatus.ApplyStatusMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.ApplyStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApplyStatus.ApplyStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApplyStatus.ApplyStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyStatus.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.ApplyStatus")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmApplyStatus.funcApplyStatus != nil {
		return mmApplyStatus.funcApplyStatus(ctx, name, obj, options)
	}
	mmApplyStatus.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.ApplyStatus. %v %v %v %v", ctx, name, obj, options)
	return
}

// ApplyStatusAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.ApplyStatus invocations
func (mmApplyStatus *KubernetesNamespaceableResourceInterfaceMock) ApplyStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyStatus.afterApplyStatusCounter)
}

// ApplyStatusBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.ApplyStatus invocations
func (mmApplyStatus *KubernetesNamespaceableResourceInterfaceMock) ApplyStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyStatus.beforeApplyStatusCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.ApplyStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyStatus *mKubernetesNamespaceableResourceInterfaceMockApplyStatus) Calls() []*KubernetesNamespaceableResourceInterfaceMockApplyStatusParams {
	mmApplyStatus.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockApplyStatusParams, len(mmApplyStatus.callArgs))
	copy(argCopy, mmApplyStatus.callArgs)

	mmApplyStatus.mutex.RUnlock()

	return argCopy
}

// MinimockApplyStatusDone returns true if the count of the ApplyStatus invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockApplyStatusDone() bool {
	if m.ApplyStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyStatusMock.invocationsDone()
}

// MinimockApplyStatusInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockApplyStatusInspect() {
	for _, e := range m.ApplyStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.ApplyStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyStatusCounter := mm_atomic.LoadUint64(&m.afterApplyStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyStatusMock.defaultExpectation != nil && afterApplyStatusCounter < 1 {
		if m.ApplyStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.ApplyStatus at\n%s", m.ApplyStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.ApplyStatus at\n%s with params: %#v", m.ApplyStatusMock.defaultExpectation.expectationOrigins.origin, *m.ApplyStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyStatus != nil && afterApplyStatusCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.ApplyStatus at\n%s", m.funcApplyStatusOrigin)
	}

	if !m.ApplyStatusMock.invocationsDone() && afterApplyStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.ApplyStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyStatusMock.expectedInvocations), m.ApplyStatusMock.expectedInvocationsOrigin, afterApplyStatusCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockCreate struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockCreateExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockCreateExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockCreateExpectation specifies expectation struct of the NamespaceableResourceInterface.Create
type KubernetesNamespaceableResourceInterfaceMockCreateExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockCreateParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockCreateParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockCreateExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockCreateParams contains parameters of the NamespaceableResourceInterface.Create
type KubernetesNamespaceableResourceInterfaceMockCreateParams struct {
	ctx          context.Context
	obj          *unstructured.Unstructured
	options      metav1.CreateOptions
	subresources []string
}

// KubernetesNamespaceableResourceInterfaceMockCreateParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Create
type KubernetesNamespaceableResourceInterfaceMockCreateParamPtrs struct {
	ctx          *context.Context
	obj          **unstructured.Unstructured
	options      *metav1.CreateOptions
	subresources *[]string
}

// KubernetesNamespaceableResourceInterfaceMockCreateResults contains results of the NamespaceableResourceInterface.Create
type KubernetesNamespaceableResourceInterfaceMockCreateResults struct {
	up1 *unstructured.Unstructured
	err error
}

// KubernetesNamespaceableResourceInterfaceMockCreateOrigins contains origins of expectations of the NamespaceableResourceInterface.Create
type KubernetesNamespaceableResourceInterfaceMockCreateExpectationOrigins struct {
	origin             string
	originCtx          string
	originObj          string
	originOptions      string
	originSubresources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) Optional() *mKubernetesNamespaceableResourceInterfaceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for NamespaceableResourceInterface.Create
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) Expect(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockCreateParams{ctx, obj, options, subresources}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.Create
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectObjParam2 sets up expected param obj for NamespaceableResourceInterface.Create
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) ExpectObjParam2(obj *unstructured.Unstructured) *mKubernetesNamespaceableResourceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.obj = &obj
	mmCreate.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectOptionsParam3 sets up expected param options for NamespaceableResourceInterface.Create
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) ExpectOptionsParam3(options metav1.CreateOptions) *mKubernetesNamespaceableResourceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.options = &options
	mmCreate.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectSubresourcesParam4 sets up expected param subresources for NamespaceableResourceInterface.Create
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) ExpectSubresourcesParam4(subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.subresources = &subresources
	mmCreate.defaultExpectation.expectationOrigins.originSubresources = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Create
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) Inspect(f func(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string)) *mKubernetesNamespaceableResourceInterfaceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Create
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) Return(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockCreateResults{up1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Create method
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) Set(f func(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the NamespaceableResourceInterface.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) When(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string) *KubernetesNamespaceableResourceInterfaceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Create mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockCreateParams{ctx, obj, options, subresources},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Create return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockCreateExpectation) Then(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockCreateResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Create should be invoked
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_dynamic.NamespaceableResourceInterface
func (mmCreate *KubernetesNamespaceableResourceInterfaceMock) Create(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string) (up1 *unstructured.Unstructured, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, obj, options, subresources...)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockCreateParams{ctx, obj, options, subresources}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockCreateParams{ctx, obj, options, subresources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmCreate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Create got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmCreate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Create got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

			if mm_want_ptrs.subresources != nil && !minimock.Equal(*mm_want_ptrs.subresources, mm_got.subresources) {
				mmCreate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Create got unexpected parameter subresources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originSubresources, *mm_want_ptrs.subresources, mm_got.subresources, minimock.Diff(*mm_want_ptrs.subresources, mm_got.subresources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Create")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, obj, options, subresources...)
	}
	mmCreate.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Create. %v %v %v %v", ctx, obj, options, subresources)
	return
}

// CreateAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Create invocations
func (mmCreate *KubernetesNamespaceableResourceInterfaceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Create invocations
func (mmCreate *KubernetesNamespaceableResourceInterfaceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mKubernetesNamespaceableResourceInterfaceMockCreate) Calls() []*KubernetesNamespaceableResourceInterfaceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockDelete struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockDeleteExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockDeleteExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockDeleteExpectation specifies expectation struct of the NamespaceableResourceInterface.Delete
type KubernetesNamespaceableResourceInterfaceMockDeleteExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockDeleteParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockDeleteParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockDeleteExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockDeleteParams contains parameters of the NamespaceableResourceInterface.Delete
type KubernetesNamespaceableResourceInterfaceMockDeleteParams struct {
	ctx          context.Context
	name         string
	options      metav1.DeleteOptions
	subresources []string
}

// KubernetesNamespaceableResourceInterfaceMockDeleteParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Delete
type KubernetesNamespaceableResourceInterfaceMockDeleteParamPtrs struct {
	ctx          *context.Context
	name         *string
	options      *metav1.DeleteOptions
	subresources *[]string
}

// KubernetesNamespaceableResourceInterfaceMockDeleteResults contains results of the NamespaceableResourceInterface.Delete
type KubernetesNamespaceableResourceInterfaceMockDeleteResults struct {
	err error
}

// KubernetesNamespaceableResourceInterfaceMockDeleteOrigins contains origins of expectations of the NamespaceableResourceInterface.Delete
type KubernetesNamespaceableResourceInterfaceMockDeleteExpectationOrigins struct {
	origin             string
	originCtx          string
	originName         string
	originOptions      string
	originSubresources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) Optional() *mKubernetesNamespaceableResourceInterfaceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for NamespaceableResourceInterface.Delete
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) Expect(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockDeleteParams{ctx, name, options, subresources}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.Delete
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectNameParam2 sets up expected param name for NamespaceableResourceInterface.Delete
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) ExpectNameParam2(name string) *mKubernetesNamespaceableResourceInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.name = &name
	mmDelete.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectOptionsParam3 sets up expected param options for NamespaceableResourceInterface.Delete
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) ExpectOptionsParam3(options metav1.DeleteOptions) *mKubernetesNamespaceableResourceInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.options = &options
	mmDelete.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectSubresourcesParam4 sets up expected param subresources for NamespaceableResourceInterface.Delete
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) ExpectSubresourcesParam4(subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.subresources = &subresources
	mmDelete.defaultExpectation.expectationOrigins.originSubresources = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Delete
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) Inspect(f func(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string)) *mKubernetesNamespaceableResourceInterfaceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Delete
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) Return(err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Delete method
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) Set(f func(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string) (err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the NamespaceableResourceInterface.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) When(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string) *KubernetesNamespaceableResourceInterfaceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Delete mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockDeleteParams{ctx, name, options, subresources},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Delete return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockDeleteExpectation) Then(err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Delete should be invoked
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_dynamic.NamespaceableResourceInterface
func (mmDelete *KubernetesNamespaceableResourceInterfaceMock) Delete(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, name, options, subresources...)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockDeleteParams{ctx, name, options, subresources}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockDeleteParams{ctx, name, options, subresources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDelete.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Delete got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmDelete.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Delete got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

			if mm_want_ptrs.subresources != nil && !minimock.Equal(*mm_want_ptrs.subresources, mm_got.subresources) {
				mmDelete.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Delete got unexpected parameter subresources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originSubresources, *mm_want_ptrs.subresources, mm_got.subresources, minimock.Diff(*mm_want_ptrs.subresources, mm_got.subresources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, name, options, subresources...)
	}
	mmDelete.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Delete. %v %v %v %v", ctx, name, options, subresources)
	return
}

// DeleteAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Delete invocations
func (mmDelete *KubernetesNamespaceableResourceInterfaceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Delete invocations
func (mmDelete *KubernetesNamespaceableResourceInterfaceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mKubernetesNamespaceableResourceInterfaceMockDelete) Calls() []*KubernetesNamespaceableResourceInterfaceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockDeleteCollection struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation specifies expectation struct of the NamespaceableResourceInterface.DeleteCollection
type KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockDeleteCollectionResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams contains parameters of the NamespaceableResourceInterface.DeleteCollection
type KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams struct {
	ctx         context.Context
	options     metav1.DeleteOptions
	listOptions metav1.ListOptions
}

// KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.DeleteCollection
type KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParamPtrs struct {
	ctx         *context.Context
	options     *metav1.DeleteOptions
	listOptions *metav1.ListOptions
}

// KubernetesNamespaceableResourceInterfaceMockDeleteCollectionResults contains results of the NamespaceableResourceInterface.DeleteCollection
type KubernetesNamespaceableResourceInterfaceMockDeleteCollectionResults struct {
	err error
}

// KubernetesNamespaceableResourceInterfaceMockDeleteCollectionOrigins contains origins of expectations of the NamespaceableResourceInterface.DeleteCollection
type KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectationOrigins struct {
	origin            string
	originCtx         string
	originOptions     string
	originListOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) Optional() *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection {
	mmDeleteCollection.optional = true
	return mmDeleteCollection
}

// Expect sets up expected params for NamespaceableResourceInterface.DeleteCollection
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) Expect(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions) *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection {
	if mmDeleteCollection.mock.funcDeleteCollection != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Set")
	}

	if mmDeleteCollection.defaultExpectation == nil {
		mmDeleteCollection.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation{}
	}

	if mmDeleteCollection.defaultExpectation.paramPtrs != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by ExpectParams functions")
	}

	mmDeleteCollection.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams{ctx, options, listOptions}
	mmDeleteCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCollection.expectations {
		if minimock.Equal(e.params, mmDeleteCollection.defaultExpectation.params) {
			mmDeleteCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCollection.defaultExpectation.params)
		}
	}

	return mmDeleteCollection
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.DeleteCollection
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection {
	if mmDeleteCollection.mock.funcDeleteCollection != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Set")
	}

	if mmDeleteCollection.defaultExpectation == nil {
		mmDeleteCollection.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation{}
	}

	if mmDeleteCollection.defaultExpectation.params != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Expect")
	}

	if mmDeleteCollection.defaultExpectation.paramPtrs == nil {
		mmDeleteCollection.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParamPtrs{}
	}
	mmDeleteCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCollection
}

// ExpectOptionsParam2 sets up expected param options for NamespaceableResourceInterface.DeleteCollection
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) ExpectOptionsParam2(options metav1.DeleteOptions) *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection {
	if mmDeleteCollection.mock.funcDeleteCollection != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Set")
	}

	if mmDeleteCollection.defaultExpectation == nil {
		mmDeleteCollection.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation{}
	}

	if mmDeleteCollection.defaultExpectation.params != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Expect")
	}

	if mmDeleteCollection.defaultExpectation.paramPtrs == nil {
		mmDeleteCollection.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParamPtrs{}
	}
	mmDeleteCollection.defaultExpectation.paramPtrs.options = &options
	mmDeleteCollection.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmDeleteCollection
}

// ExpectListOptionsParam3 sets up expected param listOptions for NamespaceableResourceInterface.DeleteCollection
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) ExpectListOptionsParam3(listOptions metav1.ListOptions) *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection {
	if mmDeleteCollection.mock.funcDeleteCollection != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Set")
	}

	if mmDeleteCollection.defaultExpectation == nil {
		mmDeleteCollection.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation{}
	}

	if mmDeleteCollection.defaultExpectation.params != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Expect")
	}

	if mmDeleteCollection.defaultExpectation.paramPtrs == nil {
		mmDeleteCollection.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParamPtrs{}
	}
	mmDeleteCollection.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmDeleteCollection.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmDeleteCollection
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.DeleteCollection
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) Inspect(f func(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions)) *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection {
	if mmDeleteCollection.mock.inspectFuncDeleteCollection != nil {
		mmDeleteCollection.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.DeleteCollection")
	}

	mmDeleteCollection.mock.inspectFuncDeleteCollection = f

	return mmDeleteCollection
}

// Return sets up results that will be returned by NamespaceableResourceInterface.DeleteCollection
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) Return(err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmDeleteCollection.mock.funcDeleteCollection != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Set")
	}

	if mmDeleteCollection.defaultExpectation == nil {
		mmDeleteCollection.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation{mock: mmDeleteCollection.mock}
	}
	mmDeleteCollection.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionResults{err}
	mmDeleteCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCollection.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.DeleteCollection method
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) Set(f func(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions) (err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmDeleteCollection.defaultExpectation != nil {
		mmDeleteCollection.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.DeleteCollection method")
	}

	if len(mmDeleteCollection.expectations) > 0 {
		mmDeleteCollection.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.DeleteCollection method")
	}

	mmDeleteCollection.mock.funcDeleteCollection = f
	mmDeleteCollection.mock.funcDeleteCollectionOrigin = minimock.CallerInfo(1)
	return mmDeleteCollection.mock
}

// When sets expectation for the NamespaceableResourceInterface.DeleteCollection which will trigger the result defined by the following
// Then helper
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) When(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions) *KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation {
	if mmDeleteCollection.mock.funcDeleteCollection != nil {
		mmDeleteCollection.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation{
		mock:               mmDeleteCollection.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams{ctx, options, listOptions},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCollection.expectations = append(mmDeleteCollection.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.DeleteCollection return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockDeleteCollectionExpectation) Then(err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockDeleteCollectionResults{err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.DeleteCollection should be invoked
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection {
	if n == 0 {
		mmDeleteCollection.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.DeleteCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCollection.expectedInvocations, n)
	mmDeleteCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCollection
}

func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) invocationsDone() bool {
	if len(mmDeleteCollection.expectations) == 0 && mmDeleteCollection.defaultExpectation == nil && mmDeleteCollection.mock.funcDeleteCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCollection.mock.afterDeleteCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCollection implements mm_dynamic.NamespaceableResourceInterface
func (mmDeleteCollection *KubernetesNamespaceableResourceInterfaceMock) DeleteCollection(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions) (err error) {
	mm_atomic.AddUint64(&mmDeleteCollection.beforeDeleteCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCollection.afterDeleteCollectionCounter, 1)

	mmDeleteCollection.t.Helper()

	if mmDeleteCollection.inspectFuncDeleteCollection != nil {
		mmDeleteCollection.inspectFuncDeleteCollection(ctx, options, listOptions)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams{ctx, options, listOptions}

	// Record call args
	mmDeleteCollection.DeleteCollectionMock.mutex.Lock()
	mmDeleteCollection.DeleteCollectionMock.callArgs = append(mmDeleteCollection.DeleteCollectionMock.callArgs, &mm_params)
	mmDeleteCollection.DeleteCollectionMock.mutex.Unlock()

	for _, e := range mmDeleteCollection.DeleteCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCollection.DeleteCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCollection.DeleteCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCollection.DeleteCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCollection.DeleteCollectionMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams{ctx, options, listOptions}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCollection.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCollection.DeleteCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmDeleteCollection.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCollection.DeleteCollectionMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmDeleteCollection.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCollection.DeleteCollectionMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCollection.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.DeleteCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCollection.DeleteCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCollection.DeleteCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCollection.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.DeleteCollection")
		}
		return (*mm_results).err
	}
	if mmDeleteCollection.funcDeleteCollection != nil {
		return mmDeleteCollection.funcDeleteCollection(ctx, options, listOptions)
	}
	mmDeleteCollection.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.DeleteCollection. %v %v %v", ctx, options, listOptions)
	return
}

// DeleteCollectionAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.DeleteCollection invocations
func (mmDeleteCollection *KubernetesNamespaceableResourceInterfaceMock) DeleteCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCollection.afterDeleteCollectionCounter)
}

// DeleteCollectionBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.DeleteCollection invocations
func (mmDeleteCollection *KubernetesNamespaceableResourceInterfaceMock) DeleteCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCollection.beforeDeleteCollectionCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.DeleteCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCollection *mKubernetesNamespaceableResourceInterfaceMockDeleteCollection) Calls() []*KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams {
	mmDeleteCollection.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockDeleteCollectionParams, len(mmDeleteCollection.callArgs))
	copy(argCopy, mmDeleteCollection.callArgs)

	mmDeleteCollection.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCollectionDone returns true if the count of the DeleteCollection invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockDeleteCollectionDone() bool {
	if m.DeleteCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCollectionMock.invocationsDone()
}

// MinimockDeleteCollectionInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockDeleteCollectionInspect() {
	for _, e := range m.DeleteCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.DeleteCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCollectionCounter := mm_atomic.LoadUint64(&m.afterDeleteCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCollectionMock.defaultExpectation != nil && afterDeleteCollectionCounter < 1 {
		if m.DeleteCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.DeleteCollection at\n%s", m.DeleteCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.DeleteCollection at\n%s with params: %#v", m.DeleteCollectionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCollection != nil && afterDeleteCollectionCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.DeleteCollection at\n%s", m.funcDeleteCollectionOrigin)
	}

	if !m.DeleteCollectionMock.invocationsDone() && afterDeleteCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.DeleteCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCollectionMock.expectedInvocations), m.DeleteCollectionMock.expectedInvocationsOrigin, afterDeleteCollectionCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockGet struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockGetExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockGetExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockGetExpectation specifies expectation struct of the NamespaceableResourceInterface.Get
type KubernetesNamespaceableResourceInterfaceMockGetExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockGetParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockGetParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockGetExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockGetResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockGetParams contains parameters of the NamespaceableResourceInterface.Get
type KubernetesNamespaceableResourceInterfaceMockGetParams struct {
	ctx          context.Context
	name         string
	options      metav1.GetOptions
	subresources []string
}

// KubernetesNamespaceableResourceInterfaceMockGetParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Get
type KubernetesNamespaceableResourceInterfaceMockGetParamPtrs struct {
	ctx          *context.Context
	name         *string
	options      *metav1.GetOptions
	subresources *[]string
}

// KubernetesNamespaceableResourceInterfaceMockGetResults contains results of the NamespaceableResourceInterface.Get
type KubernetesNamespaceableResourceInterfaceMockGetResults struct {
	up1 *unstructured.Unstructured
	err error
}

// KubernetesNamespaceableResourceInterfaceMockGetOrigins contains origins of expectations of the NamespaceableResourceInterface.Get
type KubernetesNamespaceableResourceInterfaceMockGetExpectationOrigins struct {
	origin             string
	originCtx          string
	originName         string
	originOptions      string
	originSubresources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) Optional() *mKubernetesNamespaceableResourceInterfaceMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for NamespaceableResourceInterface.Get
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) Expect(ctx context.Context, name string, options metav1.GetOptions, subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockGetParams{ctx, name, options, subresources}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.Get
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectNameParam2 sets up expected param name for NamespaceableResourceInterface.Get
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) ExpectNameParam2(name string) *mKubernetesNamespaceableResourceInterfaceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.name = &name
	mmGet.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGet
}

// ExpectOptionsParam3 sets up expected param options for NamespaceableResourceInterface.Get
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) ExpectOptionsParam3(options metav1.GetOptions) *mKubernetesNamespaceableResourceInterfaceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.options = &options
	mmGet.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGet
}

// ExpectSubresourcesParam4 sets up expected param subresources for NamespaceableResourceInterface.Get
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) ExpectSubresourcesParam4(subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.subresources = &subresources
	mmGet.defaultExpectation.expectationOrigins.originSubresources = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Get
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) Inspect(f func(ctx context.Context, name string, options metav1.GetOptions, subresources ...string)) *mKubernetesNamespaceableResourceInterfaceMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Get
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) Return(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Get method
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) Set(f func(ctx context.Context, name string, options metav1.GetOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the NamespaceableResourceInterface.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) When(ctx context.Context, name string, options metav1.GetOptions, subresources ...string) *KubernetesNamespaceableResourceInterfaceMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Get mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockGetExpectation{
		mock:               mmGet.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockGetParams{ctx, name, options, subresources},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Get return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockGetExpectation) Then(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Get should be invoked
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_dynamic.NamespaceableResourceInterface
func (mmGet *KubernetesNamespaceableResourceInterfaceMock) Get(ctx context.Context, name string, options metav1.GetOptions, subresources ...string) (up1 *unstructured.Unstructured, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, name, options, subresources...)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockGetParams{ctx, name, options, subresources}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockGetParams{ctx, name, options, subresources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGet.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Get got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGet.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Get got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

			if mm_want_ptrs.subresources != nil && !minimock.Equal(*mm_want_ptrs.subresources, mm_got.subresources) {
				mmGet.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Get got unexpected parameter subresources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originSubresources, *mm_want_ptrs.subresources, mm_got.subresources, minimock.Diff(*mm_want_ptrs.subresources, mm_got.subresources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, name, options, subresources...)
	}
	mmGet.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Get. %v %v %v %v", ctx, name, options, subresources)
	return
}

// GetAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Get invocations
func (mmGet *KubernetesNamespaceableResourceInterfaceMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Get invocations
func (mmGet *KubernetesNamespaceableResourceInterfaceMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mKubernetesNamespaceableResourceInterfaceMockGet) Calls() []*KubernetesNamespaceableResourceInterfaceMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockList struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockListExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockListExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockListExpectation specifies expectation struct of the NamespaceableResourceInterface.List
type KubernetesNamespaceableResourceInterfaceMockListExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockListParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockListParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockListExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockListResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockListParams contains parameters of the NamespaceableResourceInterface.List
type KubernetesNamespaceableResourceInterfaceMockListParams struct {
	ctx  context.Context
	opts metav1.ListOptions
}

// KubernetesNamespaceableResourceInterfaceMockListParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.List
type KubernetesNamespaceableResourceInterfaceMockListParamPtrs struct {
	ctx  *context.Context
	opts *metav1.ListOptions
}

// KubernetesNamespaceableResourceInterfaceMockListResults contains results of the NamespaceableResourceInterface.List
type KubernetesNamespaceableResourceInterfaceMockListResults struct {
	up1 *unstructured.UnstructuredList
	err error
}

// KubernetesNamespaceableResourceInterfaceMockListOrigins contains origins of expectations of the NamespaceableResourceInterface.List
type KubernetesNamespaceableResourceInterfaceMockListExpectationOrigins struct {
	origin     string
	originCtx  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) Optional() *mKubernetesNamespaceableResourceInterfaceMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for NamespaceableResourceInterface.List
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) Expect(ctx context.Context, opts metav1.ListOptions) *mKubernetesNamespaceableResourceInterfaceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockListParams{ctx, opts}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.List
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectOptsParam2 sets up expected param opts for NamespaceableResourceInterface.List
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) ExpectOptsParam2(opts metav1.ListOptions) *mKubernetesNamespaceableResourceInterfaceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.opts = &opts
	mmList.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.List
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) Inspect(f func(ctx context.Context, opts metav1.ListOptions)) *mKubernetesNamespaceableResourceInterfaceMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by NamespaceableResourceInterface.List
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) Return(up1 *unstructured.UnstructuredList, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockListResults{up1, err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.List method
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) Set(f func(ctx context.Context, opts metav1.ListOptions) (up1 *unstructured.UnstructuredList, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the NamespaceableResourceInterface.List which will trigger the result defined by the following
// Then helper
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) When(ctx context.Context, opts metav1.ListOptions) *KubernetesNamespaceableResourceInterfaceMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.List mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockListExpectation{
		mock:               mmList.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockListParams{ctx, opts},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.List return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockListExpectation) Then(up1 *unstructured.UnstructuredList, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockListResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.List should be invoked
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_dynamic.NamespaceableResourceInterface
func (mmList *KubernetesNamespaceableResourceInterfaceMock) List(ctx context.Context, opts metav1.ListOptions) (up1 *unstructured.UnstructuredList, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, opts)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockListParams{ctx, opts}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockListParams{ctx, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmList.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.List got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.List")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, opts)
	}
	mmList.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.List. %v %v", ctx, opts)
	return
}

// ListAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.List invocations
func (mmList *KubernetesNamespaceableResourceInterfaceMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.List invocations
func (mmList *KubernetesNamespaceableResourceInterfaceMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mKubernetesNamespaceableResourceInterfaceMockList) Calls() []*KubernetesNamespaceableResourceInterfaceMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockNamespace struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockNamespaceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation specifies expectation struct of the NamespaceableResourceInterface.Namespace
type KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockNamespaceParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockNamespaceParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockNamespaceExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockNamespaceResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockNamespaceParams contains parameters of the NamespaceableResourceInterface.Namespace
type KubernetesNamespaceableResourceInterfaceMockNamespaceParams struct {
	s1 string
}

// KubernetesNamespaceableResourceInterfaceMockNamespaceParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Namespace
type KubernetesNamespaceableResourceInterfaceMockNamespaceParamPtrs struct {
	s1 *string
}

// KubernetesNamespaceableResourceInterfaceMockNamespaceResults contains results of the NamespaceableResourceInterface.Namespace
type KubernetesNamespaceableResourceInterfaceMockNamespaceResults struct {
	r1 mm_dynamic.ResourceInterface
}

// KubernetesNamespaceableResourceInterfaceMockNamespaceOrigins contains origins of expectations of the NamespaceableResourceInterface.Namespace
type KubernetesNamespaceableResourceInterfaceMockNamespaceExpectationOrigins struct {
	origin   string
	originS1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) Optional() *mKubernetesNamespaceableResourceInterfaceMockNamespace {
	mmNamespace.optional = true
	return mmNamespace
}

// Expect sets up expected params for NamespaceableResourceInterface.Namespace
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) Expect(s1 string) *mKubernetesNamespaceableResourceInterfaceMockNamespace {
	if mmNamespace.mock.funcNamespace != nil {
		mmNamespace.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Namespace mock is already set by Set")
	}

	if mmNamespace.defaultExpectation == nil {
		mmNamespace.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation{}
	}

	if mmNamespace.defaultExpectation.paramPtrs != nil {
		mmNamespace.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Namespace mock is already set by ExpectParams functions")
	}

	mmNamespace.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockNamespaceParams{s1}
	mmNamespace.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNamespace.expectations {
		if minimock.Equal(e.params, mmNamespace.defaultExpectation.params) {
			mmNamespace.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNamespace.defaultExpectation.params)
		}
	}

	return mmNamespace
}

// ExpectS1Param1 sets up expected param s1 for NamespaceableResourceInterface.Namespace
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) ExpectS1Param1(s1 string) *mKubernetesNamespaceableResourceInterfaceMockNamespace {
	if mmNamespace.mock.funcNamespace != nil {
		mmNamespace.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Namespace mock is already set by Set")
	}

	if mmNamespace.defaultExpectation == nil {
		mmNamespace.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation{}
	}

	if mmNamespace.defaultExpectation.params != nil {
		mmNamespace.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Namespace mock is already set by Expect")
	}

	if mmNamespace.defaultExpectation.paramPtrs == nil {
		mmNamespace.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockNamespaceParamPtrs{}
	}
	mmNamespace.defaultExpectation.paramPtrs.s1 = &s1
	mmNamespace.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmNamespace
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Namespace
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) Inspect(f func(s1 string)) *mKubernetesNamespaceableResourceInterfaceMockNamespace {
	if mmNamespace.mock.inspectFuncNamespace != nil {
		mmNamespace.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Namespace")
	}

	mmNamespace.mock.inspectFuncNamespace = f

	return mmNamespace
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Namespace
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) Return(r1 mm_dynamic.ResourceInterface) *KubernetesNamespaceableResourceInterfaceMock {
	if mmNamespace.mock.funcNamespace != nil {
		mmNamespace.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Namespace mock is already set by Set")
	}

	if mmNamespace.defaultExpectation == nil {
		mmNamespace.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation{mock: mmNamespace.mock}
	}
	mmNamespace.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockNamespaceResults{r1}
	mmNamespace.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNamespace.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Namespace method
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) Set(f func(s1 string) (r1 mm_dynamic.ResourceInterface)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmNamespace.defaultExpectation != nil {
		mmNamespace.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Namespace method")
	}

	if len(mmNamespace.expectations) > 0 {
		mmNamespace.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Namespace method")
	}

	mmNamespace.mock.funcNamespace = f
	mmNamespace.mock.funcNamespaceOrigin = minimock.CallerInfo(1)
	return mmNamespace.mock
}

// When sets expectation for the NamespaceableResourceInterface.Namespace which will trigger the result defined by the following
// Then helper
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) When(s1 string) *KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation {
	if mmNamespace.mock.funcNamespace != nil {
		mmNamespace.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Namespace mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation{
		mock:               mmNamespace.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockNamespaceParams{s1},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockNamespaceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNamespace.expectations = append(mmNamespace.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Namespace return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockNamespaceExpectation) Then(r1 mm_dynamic.ResourceInterface) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockNamespaceResults{r1}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Namespace should be invoked
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockNamespace {
	if n == 0 {
		mmNamespace.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Namespace mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNamespace.expectedInvocations, n)
	mmNamespace.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNamespace
}

func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) invocationsDone() bool {
	if len(mmNamespace.expectations) == 0 && mmNamespace.defaultExpectation == nil && mmNamespace.mock.funcNamespace == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNamespace.mock.afterNamespaceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNamespace.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Namespace implements mm_dynamic.NamespaceableResourceInterface
func (mmNamespace *KubernetesNamespaceableResourceInterfaceMock) Namespace(s1 string) (r1 mm_dynamic.ResourceInterface) {
	mm_atomic.AddUint64(&mmNamespace.beforeNamespaceCounter, 1)
	defer mm_atomic.AddUint64(&mmNamespace.afterNamespaceCounter, 1)

	mmNamespace.t.Helper()

	if mmNamespace.inspectFuncNamespace != nil {
		mmNamespace.inspectFuncNamespace(s1)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockNamespaceParams{s1}

	// Record call args
	mmNamespace.NamespaceMock.mutex.Lock()
	mmNamespace.NamespaceMock.callArgs = append(mmNamespace.NamespaceMock.callArgs, &mm_params)
	mmNamespace.NamespaceMock.mutex.Unlock()

	for _, e := range mmNamespace.NamespaceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmNamespace.NamespaceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNamespace.NamespaceMock.defaultExpectation.Counter, 1)
		mm_want := mmNamespace.NamespaceMock.defaultExpectation.params
		mm_want_ptrs := mmNamespace.NamespaceMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockNamespaceParams{s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmNamespace.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Namespace got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNamespace.NamespaceMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNamespace.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Namespace got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNamespace.NamespaceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNamespace.NamespaceMock.defaultExpectation.results
		if mm_results == nil {
			mmNamespace.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Namespace")
		}
		return (*mm_results).r1
	}
	if mmNamespace.funcNamespace != nil {
		return mmNamespace.funcNamespace(s1)
	}
	mmNamespace.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Namespace. %v", s1)
	return
}

// NamespaceAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Namespace invocations
func (mmNamespace *KubernetesNamespaceableResourceInterfaceMock) NamespaceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNamespace.afterNamespaceCounter)
}

// NamespaceBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Namespace invocations
func (mmNamespace *KubernetesNamespaceableResourceInterfaceMock) NamespaceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNamespace.beforeNamespaceCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Namespace.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNamespace *mKubernetesNamespaceableResourceInterfaceMockNamespace) Calls() []*KubernetesNamespaceableResourceInterfaceMockNamespaceParams {
	mmNamespace.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockNamespaceParams, len(mmNamespace.callArgs))
	copy(argCopy, mmNamespace.callArgs)

	mmNamespace.mutex.RUnlock()

	return argCopy
}

// MinimockNamespaceDone returns true if the count of the Namespace invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockNamespaceDone() bool {
	if m.NamespaceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NamespaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NamespaceMock.invocationsDone()
}

// MinimockNamespaceInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockNamespaceInspect() {
	for _, e := range m.NamespaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Namespace at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNamespaceCounter := mm_atomic.LoadUint64(&m.afterNamespaceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NamespaceMock.defaultExpectation != nil && afterNamespaceCounter < 1 {
		if m.NamespaceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Namespace at\n%s", m.NamespaceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Namespace at\n%s with params: %#v", m.NamespaceMock.defaultExpectation.expectationOrigins.origin, *m.NamespaceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNamespace != nil && afterNamespaceCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Namespace at\n%s", m.funcNamespaceOrigin)
	}

	if !m.NamespaceMock.invocationsDone() && afterNamespaceCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Namespace at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NamespaceMock.expectedInvocations), m.NamespaceMock.expectedInvocationsOrigin, afterNamespaceCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockPatch struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockPatchExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockPatchExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockPatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockPatchExpectation specifies expectation struct of the NamespaceableResourceInterface.Patch
type KubernetesNamespaceableResourceInterfaceMockPatchExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockPatchParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockPatchExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockPatchResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockPatchParams contains parameters of the NamespaceableResourceInterface.Patch
type KubernetesNamespaceableResourceInterfaceMockPatchParams struct {
	ctx          context.Context
	name         string
	pt           types.PatchType
	data         []byte
	options      metav1.PatchOptions
	subresources []string
}

// KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Patch
type KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs struct {
	ctx          *context.Context
	name         *string
	pt           *types.PatchType
	data         *[]byte
	options      *metav1.PatchOptions
	subresources *[]string
}

// KubernetesNamespaceableResourceInterfaceMockPatchResults contains results of the NamespaceableResourceInterface.Patch
type KubernetesNamespaceableResourceInterfaceMockPatchResults struct {
	up1 *unstructured.Unstructured
	err error
}

// KubernetesNamespaceableResourceInterfaceMockPatchOrigins contains origins of expectations of the NamespaceableResourceInterface.Patch
type KubernetesNamespaceableResourceInterfaceMockPatchExpectationOrigins struct {
	origin             string
	originCtx          string
	originName         string
	originPt           string
	originData         string
	originOptions      string
	originSubresources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) Optional() *mKubernetesNamespaceableResourceInterfaceMockPatch {
	mmPatch.optional = true
	return mmPatch
}

// Expect sets up expected params for NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) Expect(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.paramPtrs != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by ExpectParams functions")
	}

	mmPatch.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockPatchParams{ctx, name, pt, data, options, subresources}
	mmPatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPatch.expectations {
		if minimock.Equal(e.params, mmPatch.defaultExpectation.params) {
			mmPatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatch.defaultExpectation.params)
		}
	}

	return mmPatch
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmPatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectNameParam2 sets up expected param name for NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) ExpectNameParam2(name string) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.name = &name
	mmPatch.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectPtParam3 sets up expected param pt for NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) ExpectPtParam3(pt types.PatchType) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.pt = &pt
	mmPatch.defaultExpectation.expectationOrigins.originPt = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectDataParam4 sets up expected param data for NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) ExpectDataParam4(data []byte) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.data = &data
	mmPatch.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectOptionsParam5 sets up expected param options for NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) ExpectOptionsParam5(options metav1.PatchOptions) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.options = &options
	mmPatch.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectSubresourcesParam6 sets up expected param subresources for NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) ExpectSubresourcesParam6(subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.subresources = &subresources
	mmPatch.defaultExpectation.expectationOrigins.originSubresources = minimock.CallerInfo(1)

	return mmPatch
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) Inspect(f func(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string)) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if mmPatch.mock.inspectFuncPatch != nil {
		mmPatch.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Patch")
	}

	mmPatch.mock.inspectFuncPatch = f

	return mmPatch
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Patch
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) Return(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{mock: mmPatch.mock}
	}
	mmPatch.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockPatchResults{up1, err}
	mmPatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Patch method
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) Set(f func(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmPatch.defaultExpectation != nil {
		mmPatch.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Patch method")
	}

	if len(mmPatch.expectations) > 0 {
		mmPatch.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Patch method")
	}

	mmPatch.mock.funcPatch = f
	mmPatch.mock.funcPatchOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// When sets expectation for the NamespaceableResourceInterface.Patch which will trigger the result defined by the following
// Then helper
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) When(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string) *KubernetesNamespaceableResourceInterfaceMockPatchExpectation {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Patch mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockPatchExpectation{
		mock:               mmPatch.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockPatchParams{ctx, name, pt, data, options, subresources},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockPatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPatch.expectations = append(mmPatch.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Patch return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockPatchExpectation) Then(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockPatchResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Patch should be invoked
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockPatch {
	if n == 0 {
		mmPatch.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Patch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPatch.expectedInvocations, n)
	mmPatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPatch
}

func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) invocationsDone() bool {
	if len(mmPatch.expectations) == 0 && mmPatch.defaultExpectation == nil && mmPatch.mock.funcPatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPatch.mock.afterPatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Patch implements mm_dynamic.NamespaceableResourceInterface
func (mmPatch *KubernetesNamespaceableResourceInterfaceMock) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string) (up1 *unstructured.Unstructured, err error) {
	mm_atomic.AddUint64(&mmPatch.beforePatchCounter, 1)
	defer mm_atomic.AddUint64(&mmPatch.afterPatchCounter, 1)

	mmPatch.t.Helper()

	if mmPatch.inspectFuncPatch != nil {
		mmPatch.inspectFuncPatch(ctx, name, pt, data, options, subresources...)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockPatchParams{ctx, name, pt, data, options, subresources}

	// Record call args
	mmPatch.PatchMock.mutex.Lock()
	mmPatch.PatchMock.callArgs = append(mmPatch.PatchMock.callArgs, &mm_params)
	mmPatch.PatchMock.mutex.Unlock()

	for _, e := range mmPatch.PatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmPatch.PatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatch.PatchMock.defaultExpectation.Counter, 1)
		mm_want := mmPatch.PatchMock.defaultExpectation.params
		mm_want_ptrs := mmPatch.PatchMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockPatchParams{ctx, name, pt, data, options, subresources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Patch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmPatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Patch got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.pt != nil && !minimock.Equal(*mm_want_ptrs.pt, mm_got.pt) {
				mmPatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Patch got unexpected parameter pt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originPt, *mm_want_ptrs.pt, mm_got.pt, minimock.Diff(*mm_want_ptrs.pt, mm_got.pt))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmPatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Patch got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmPatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Patch got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

			if mm_want_ptrs.subresources != nil && !minimock.Equal(*mm_want_ptrs.subresources, mm_got.subresources) {
				mmPatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Patch got unexpected parameter subresources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originSubresources, *mm_want_ptrs.subresources, mm_got.subresources, minimock.Diff(*mm_want_ptrs.subresources, mm_got.subresources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Patch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPatch.PatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatch.PatchMock.defaultExpectation.results
		if mm_results == nil {
			mmPatch.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Patch")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmPatch.funcPatch != nil {
		return mmPatch.funcPatch(ctx, name, pt, data, options, subresources...)
	}
	mmPatch.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Patch. %v %v %v %v %v %v", ctx, name, pt, data, options, subresources)
	return
}

// PatchAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Patch invocations
func (mmPatch *KubernetesNamespaceableResourceInterfaceMock) PatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.afterPatchCounter)
}

// PatchBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Patch invocations
func (mmPatch *KubernetesNamespaceableResourceInterfaceMock) PatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.beforePatchCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Patch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatch *mKubernetesNamespaceableResourceInterfaceMockPatch) Calls() []*KubernetesNamespaceableResourceInterfaceMockPatchParams {
	mmPatch.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockPatchParams, len(mmPatch.callArgs))
	copy(argCopy, mmPatch.callArgs)

	mmPatch.mutex.RUnlock()

	return argCopy
}

// MinimockPatchDone returns true if the count of the Patch invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockPatchDone() bool {
	if m.PatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PatchMock.invocationsDone()
}

// MinimockPatchInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockPatchInspect() {
	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Patch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPatchCounter := mm_atomic.LoadUint64(&m.afterPatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PatchMock.defaultExpectation != nil && afterPatchCounter < 1 {
		if m.PatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Patch at\n%s", m.PatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Patch at\n%s with params: %#v", m.PatchMock.defaultExpectation.expectationOrigins.origin, *m.PatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatch != nil && afterPatchCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Patch at\n%s", m.funcPatchOrigin)
	}

	if !m.PatchMock.invocationsDone() && afterPatchCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Patch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PatchMock.expectedInvocations), m.PatchMock.expectedInvocationsOrigin, afterPatchCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockUpdate struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockUpdateExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockUpdateExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockUpdateExpectation specifies expectation struct of the NamespaceableResourceInterface.Update
type KubernetesNamespaceableResourceInterfaceMockUpdateExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockUpdateParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockUpdateParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockUpdateExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockUpdateParams contains parameters of the NamespaceableResourceInterface.Update
type KubernetesNamespaceableResourceInterfaceMockUpdateParams struct {
	ctx          context.Context
	obj          *unstructured.Unstructured
	options      metav1.UpdateOptions
	subresources []string
}

// KubernetesNamespaceableResourceInterfaceMockUpdateParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Update
type KubernetesNamespaceableResourceInterfaceMockUpdateParamPtrs struct {
	ctx          *context.Context
	obj          **unstructured.Unstructured
	options      *metav1.UpdateOptions
	subresources *[]string
}

// KubernetesNamespaceableResourceInterfaceMockUpdateResults contains results of the NamespaceableResourceInterface.Update
type KubernetesNamespaceableResourceInterfaceMockUpdateResults struct {
	up1 *unstructured.Unstructured
	err error
}

// KubernetesNamespaceableResourceInterfaceMockUpdateOrigins contains origins of expectations of the NamespaceableResourceInterface.Update
type KubernetesNamespaceableResourceInterfaceMockUpdateExpectationOrigins struct {
	origin             string
	originCtx          string
	originObj          string
	originOptions      string
	originSubresources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) Optional() *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for NamespaceableResourceInterface.Update
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) Expect(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockUpdateParams{ctx, obj, options, subresources}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.Update
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectObjParam2 sets up expected param obj for NamespaceableResourceInterface.Update
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) ExpectObjParam2(obj *unstructured.Unstructured) *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.obj = &obj
	mmUpdate.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectOptionsParam3 sets up expected param options for NamespaceableResourceInterface.Update
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) ExpectOptionsParam3(options metav1.UpdateOptions) *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.options = &options
	mmUpdate.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectSubresourcesParam4 sets up expected param subresources for NamespaceableResourceInterface.Update
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) ExpectSubresourcesParam4(subresources ...string) *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.subresources = &subresources
	mmUpdate.defaultExpectation.expectationOrigins.originSubresources = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Update
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) Inspect(f func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string)) *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Update
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) Return(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockUpdateResults{up1, err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Update method
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) Set(f func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string) (up1 *unstructured.Unstructured, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the NamespaceableResourceInterface.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) When(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string) *KubernetesNamespaceableResourceInterfaceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Update mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockUpdateParams{ctx, obj, options, subresources},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Update return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockUpdateExpectation) Then(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockUpdateResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Update should be invoked
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_dynamic.NamespaceableResourceInterface
func (mmUpdate *KubernetesNamespaceableResourceInterfaceMock) Update(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string) (up1 *unstructured.Unstructured, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, obj, options, subresources...)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockUpdateParams{ctx, obj, options, subresources}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockUpdateParams{ctx, obj, options, subresources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmUpdate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Update got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmUpdate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Update got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

			if mm_want_ptrs.subresources != nil && !minimock.Equal(*mm_want_ptrs.subresources, mm_got.subresources) {
				mmUpdate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Update got unexpected parameter subresources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originSubresources, *mm_want_ptrs.subresources, mm_got.subresources, minimock.Diff(*mm_want_ptrs.subresources, mm_got.subresources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Update")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, obj, options, subresources...)
	}
	mmUpdate.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Update. %v %v %v %v", ctx, obj, options, subresources)
	return
}

// UpdateAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Update invocations
func (mmUpdate *KubernetesNamespaceableResourceInterfaceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Update invocations
func (mmUpdate *KubernetesNamespaceableResourceInterfaceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mKubernetesNamespaceableResourceInterfaceMockUpdate) Calls() []*KubernetesNamespaceableResourceInterfaceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockUpdateStatus struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation specifies expectation struct of the NamespaceableResourceInterface.UpdateStatus
type KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockUpdateStatusParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockUpdateStatusResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams contains parameters of the NamespaceableResourceInterface.UpdateStatus
type KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams struct {
	ctx     context.Context
	obj     *unstructured.Unstructured
	options metav1.UpdateOptions
}

// KubernetesNamespaceableResourceInterfaceMockUpdateStatusParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.UpdateStatus
type KubernetesNamespaceableResourceInterfaceMockUpdateStatusParamPtrs struct {
	ctx     *context.Context
	obj     **unstructured.Unstructured
	options *metav1.UpdateOptions
}

// KubernetesNamespaceableResourceInterfaceMockUpdateStatusResults contains results of the NamespaceableResourceInterface.UpdateStatus
type KubernetesNamespaceableResourceInterfaceMockUpdateStatusResults struct {
	up1 *unstructured.Unstructured
	err error
}

// KubernetesNamespaceableResourceInterfaceMockUpdateStatusOrigins contains origins of expectations of the NamespaceableResourceInterface.UpdateStatus
type KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectationOrigins struct {
	origin        string
	originCtx     string
	originObj     string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) Optional() *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus {
	mmUpdateStatus.optional = true
	return mmUpdateStatus
}

// Expect sets up expected params for NamespaceableResourceInterface.UpdateStatus
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) Expect(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions) *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by ExpectParams functions")
	}

	mmUpdateStatus.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams{ctx, obj, options}
	mmUpdateStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateStatus.expectations {
		if minimock.Equal(e.params, mmUpdateStatus.defaultExpectation.params) {
			mmUpdateStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStatus.defaultExpectation.params)
		}
	}

	return mmUpdateStatus
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.UpdateStatus
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.params != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Expect")
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateStatus.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusParamPtrs{}
	}
	mmUpdateStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateStatus
}

// ExpectObjParam2 sets up expected param obj for NamespaceableResourceInterface.UpdateStatus
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) ExpectObjParam2(obj *unstructured.Unstructured) *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.params != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Expect")
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateStatus.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusParamPtrs{}
	}
	mmUpdateStatus.defaultExpectation.paramPtrs.obj = &obj
	mmUpdateStatus.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmUpdateStatus
}

// ExpectOptionsParam3 sets up expected param options for NamespaceableResourceInterface.UpdateStatus
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) ExpectOptionsParam3(options metav1.UpdateOptions) *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.params != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Expect")
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateStatus.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusParamPtrs{}
	}
	mmUpdateStatus.defaultExpectation.paramPtrs.options = &options
	mmUpdateStatus.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmUpdateStatus
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.UpdateStatus
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) Inspect(f func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions)) *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus {
	if mmUpdateStatus.mock.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.UpdateStatus")
	}

	mmUpdateStatus.mock.inspectFuncUpdateStatus = f

	return mmUpdateStatus
}

// Return sets up results that will be returned by NamespaceableResourceInterface.UpdateStatus
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) Return(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation{mock: mmUpdateStatus.mock}
	}
	mmUpdateStatus.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusResults{up1, err}
	mmUpdateStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateStatus.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.UpdateStatus method
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) Set(f func(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions) (up1 *unstructured.Unstructured, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmUpdateStatus.defaultExpectation != nil {
		mmUpdateStatus.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.UpdateStatus method")
	}

	if len(mmUpdateStatus.expectations) > 0 {
		mmUpdateStatus.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.UpdateStatus method")
	}

	mmUpdateStatus.mock.funcUpdateStatus = f
	mmUpdateStatus.mock.funcUpdateStatusOrigin = minimock.CallerInfo(1)
	return mmUpdateStatus.mock
}

// When sets expectation for the NamespaceableResourceInterface.UpdateStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) When(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions) *KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation{
		mock:               mmUpdateStatus.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams{ctx, obj, options},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateStatus.expectations = append(mmUpdateStatus.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.UpdateStatus return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockUpdateStatusExpectation) Then(up1 *unstructured.Unstructured, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockUpdateStatusResults{up1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.UpdateStatus should be invoked
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus {
	if n == 0 {
		mmUpdateStatus.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.UpdateStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateStatus.expectedInvocations, n)
	mmUpdateStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateStatus
}

func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) invocationsDone() bool {
	if len(mmUpdateStatus.expectations) == 0 && mmUpdateStatus.defaultExpectation == nil && mmUpdateStatus.mock.funcUpdateStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateStatus.mock.afterUpdateStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateStatus implements mm_dynamic.NamespaceableResourceInterface
func (mmUpdateStatus *KubernetesNamespaceableResourceInterfaceMock) UpdateStatus(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions) (up1 *unstructured.Unstructured, err error) {
	mm_atomic.AddUint64(&mmUpdateStatus.beforeUpdateStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStatus.afterUpdateStatusCounter, 1)

	mmUpdateStatus.t.Helper()

	if mmUpdateStatus.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.inspectFuncUpdateStatus(ctx, obj, options)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams{ctx, obj, options}

	// Record call args
	mmUpdateStatus.UpdateStatusMock.mutex.Lock()
	mmUpdateStatus.UpdateStatusMock.callArgs = append(mmUpdateStatus.UpdateStatusMock.callArgs, &mm_params)
	mmUpdateStatus.UpdateStatusMock.mutex.Unlock()

	for _, e := range mmUpdateStatus.UpdateStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateStatus.UpdateStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStatus.UpdateStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStatus.UpdateStatusMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateStatus.UpdateStatusMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams{ctx, obj, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmUpdateStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmUpdateStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStatus.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.UpdateStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStatus.UpdateStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStatus.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.UpdateStatus")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateStatus.funcUpdateStatus != nil {
		return mmUpdateStatus.funcUpdateStatus(ctx, obj, options)
	}
	mmUpdateStatus.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.UpdateStatus. %v %v %v", ctx, obj, options)
	return
}

// UpdateStatusAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.UpdateStatus invocations
func (mmUpdateStatus *KubernetesNamespaceableResourceInterfaceMock) UpdateStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.afterUpdateStatusCounter)
}

// UpdateStatusBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.UpdateStatus invocations
func (mmUpdateStatus *KubernetesNamespaceableResourceInterfaceMock) UpdateStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.beforeUpdateStatusCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.UpdateStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStatus *mKubernetesNamespaceableResourceInterfaceMockUpdateStatus) Calls() []*KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams {
	mmUpdateStatus.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockUpdateStatusParams, len(mmUpdateStatus.callArgs))
	copy(argCopy, mmUpdateStatus.callArgs)

	mmUpdateStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStatusDone returns true if the count of the UpdateStatus invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockUpdateStatusDone() bool {
	if m.UpdateStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateStatusMock.invocationsDone()
}

// MinimockUpdateStatusInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockUpdateStatusInspect() {
	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.UpdateStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateStatusCounter := mm_atomic.LoadUint64(&m.afterUpdateStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStatusMock.defaultExpectation != nil && afterUpdateStatusCounter < 1 {
		if m.UpdateStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.UpdateStatus at\n%s", m.UpdateStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.UpdateStatus at\n%s with params: %#v", m.UpdateStatusMock.defaultExpectation.expectationOrigins.origin, *m.UpdateStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStatus != nil && afterUpdateStatusCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.UpdateStatus at\n%s", m.funcUpdateStatusOrigin)
	}

	if !m.UpdateStatusMock.invocationsDone() && afterUpdateStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.UpdateStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateStatusMock.expectedInvocations), m.UpdateStatusMock.expectedInvocationsOrigin, afterUpdateStatusCounter)
	}
}

type mKubernetesNamespaceableResourceInterfaceMockWatch struct {
	optional           bool
	mock               *KubernetesNamespaceableResourceInterfaceMock
	defaultExpectation *KubernetesNamespaceableResourceInterfaceMockWatchExpectation
	expectations       []*KubernetesNamespaceableResourceInterfaceMockWatchExpectation

	callArgs []*KubernetesNamespaceableResourceInterfaceMockWatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubernetesNamespaceableResourceInterfaceMockWatchExpectation specifies expectation struct of the NamespaceableResourceInterface.Watch
type KubernetesNamespaceableResourceInterfaceMockWatchExpectation struct {
	mock               *KubernetesNamespaceableResourceInterfaceMock
	params             *KubernetesNamespaceableResourceInterfaceMockWatchParams
	paramPtrs          *KubernetesNamespaceableResourceInterfaceMockWatchParamPtrs
	expectationOrigins KubernetesNamespaceableResourceInterfaceMockWatchExpectationOrigins
	results            *KubernetesNamespaceableResourceInterfaceMockWatchResults
	returnOrigin       string
	Counter            uint64
}

// KubernetesNamespaceableResourceInterfaceMockWatchParams contains parameters of the NamespaceableResourceInterface.Watch
type KubernetesNamespaceableResourceInterfaceMockWatchParams struct {
	ctx  context.Context
	opts metav1.ListOptions
}

// KubernetesNamespaceableResourceInterfaceMockWatchParamPtrs contains pointers to parameters of the NamespaceableResourceInterface.Watch
type KubernetesNamespaceableResourceInterfaceMockWatchParamPtrs struct {
	ctx  *context.Context
	opts *metav1.ListOptions
}

// KubernetesNamespaceableResourceInterfaceMockWatchResults contains results of the NamespaceableResourceInterface.Watch
type KubernetesNamespaceableResourceInterfaceMockWatchResults struct {
	i1  watch.Interface
	err error
}

// KubernetesNamespaceableResourceInterfaceMockWatchOrigins contains origins of expectations of the NamespaceableResourceInterface.Watch
type KubernetesNamespaceableResourceInterfaceMockWatchExpectationOrigins struct {
	origin     string
	originCtx  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) Optional() *mKubernetesNamespaceableResourceInterfaceMockWatch {
	mmWatch.optional = true
	return mmWatch
}

// Expect sets up expected params for NamespaceableResourceInterface.Watch
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) Expect(ctx context.Context, opts metav1.ListOptions) *mKubernetesNamespaceableResourceInterfaceMockWatch {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockWatchExpectation{}
	}

	if mmWatch.defaultExpectation.paramPtrs != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by ExpectParams functions")
	}

	mmWatch.defaultExpectation.params = &KubernetesNamespaceableResourceInterfaceMockWatchParams{ctx, opts}
	mmWatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWatch.expectations {
		if minimock.Equal(e.params, mmWatch.defaultExpectation.params) {
			mmWatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatch.defaultExpectation.params)
		}
	}

	return mmWatch
}

// ExpectCtxParam1 sets up expected param ctx for NamespaceableResourceInterface.Watch
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) ExpectCtxParam1(ctx context.Context) *mKubernetesNamespaceableResourceInterfaceMockWatch {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockWatchExpectation{}
	}

	if mmWatch.defaultExpectation.params != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by Expect")
	}

	if mmWatch.defaultExpectation.paramPtrs == nil {
		mmWatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockWatchParamPtrs{}
	}
	mmWatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmWatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWatch
}

// ExpectOptsParam2 sets up expected param opts for NamespaceableResourceInterface.Watch
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) ExpectOptsParam2(opts metav1.ListOptions) *mKubernetesNamespaceableResourceInterfaceMockWatch {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockWatchExpectation{}
	}

	if mmWatch.defaultExpectation.params != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by Expect")
	}

	if mmWatch.defaultExpectation.paramPtrs == nil {
		mmWatch.defaultExpectation.paramPtrs = &KubernetesNamespaceableResourceInterfaceMockWatchParamPtrs{}
	}
	mmWatch.defaultExpectation.paramPtrs.opts = &opts
	mmWatch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmWatch
}

// Inspect accepts an inspector function that has same arguments as the NamespaceableResourceInterface.Watch
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) Inspect(f func(ctx context.Context, opts metav1.ListOptions)) *mKubernetesNamespaceableResourceInterfaceMockWatch {
	if mmWatch.mock.inspectFuncWatch != nil {
		mmWatch.mock.t.Fatalf("Inspect function is already set for KubernetesNamespaceableResourceInterfaceMock.Watch")
	}

	mmWatch.mock.inspectFuncWatch = f

	return mmWatch
}

// Return sets up results that will be returned by NamespaceableResourceInterface.Watch
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) Return(i1 watch.Interface, err error) *KubernetesNamespaceableResourceInterfaceMock {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &KubernetesNamespaceableResourceInterfaceMockWatchExpectation{mock: mmWatch.mock}
	}
	mmWatch.defaultExpectation.results = &KubernetesNamespaceableResourceInterfaceMockWatchResults{i1, err}
	mmWatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWatch.mock
}

// Set uses given function f to mock the NamespaceableResourceInterface.Watch method
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) Set(f func(ctx context.Context, opts metav1.ListOptions) (i1 watch.Interface, err error)) *KubernetesNamespaceableResourceInterfaceMock {
	if mmWatch.defaultExpectation != nil {
		mmWatch.mock.t.Fatalf("Default expectation is already set for the NamespaceableResourceInterface.Watch method")
	}

	if len(mmWatch.expectations) > 0 {
		mmWatch.mock.t.Fatalf("Some expectations are already set for the NamespaceableResourceInterface.Watch method")
	}

	mmWatch.mock.funcWatch = f
	mmWatch.mock.funcWatchOrigin = minimock.CallerInfo(1)
	return mmWatch.mock
}

// When sets expectation for the NamespaceableResourceInterface.Watch which will trigger the result defined by the following
// Then helper
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) When(ctx context.Context, opts metav1.ListOptions) *KubernetesNamespaceableResourceInterfaceMockWatchExpectation {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("KubernetesNamespaceableResourceInterfaceMock.Watch mock is already set by Set")
	}

	expectation := &KubernetesNamespaceableResourceInterfaceMockWatchExpectation{
		mock:               mmWatch.mock,
		params:             &KubernetesNamespaceableResourceInterfaceMockWatchParams{ctx, opts},
		expectationOrigins: KubernetesNamespaceableResourceInterfaceMockWatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWatch.expectations = append(mmWatch.expectations, expectation)
	return expectation
}

// Then sets up NamespaceableResourceInterface.Watch return parameters for the expectation previously defined by the When method
func (e *KubernetesNamespaceableResourceInterfaceMockWatchExpectation) Then(i1 watch.Interface, err error) *KubernetesNamespaceableResourceInterfaceMock {
	e.results = &KubernetesNamespaceableResourceInterfaceMockWatchResults{i1, err}
	return e.mock
}

// Times sets number of times NamespaceableResourceInterface.Watch should be invoked
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) Times(n uint64) *mKubernetesNamespaceableResourceInterfaceMockWatch {
	if n == 0 {
		mmWatch.mock.t.Fatalf("Times of KubernetesNamespaceableResourceInterfaceMock.Watch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWatch.expectedInvocations, n)
	mmWatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWatch
}

func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) invocationsDone() bool {
	if len(mmWatch.expectations) == 0 && mmWatch.defaultExpectation == nil && mmWatch.mock.funcWatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWatch.mock.afterWatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Watch implements mm_dynamic.NamespaceableResourceInterface
func (mmWatch *KubernetesNamespaceableResourceInterfaceMock) Watch(ctx context.Context, opts metav1.ListOptions) (i1 watch.Interface, err error) {
	mm_atomic.AddUint64(&mmWatch.beforeWatchCounter, 1)
	defer mm_atomic.AddUint64(&mmWatch.afterWatchCounter, 1)

	mmWatch.t.Helper()

	if mmWatch.inspectFuncWatch != nil {
		mmWatch.inspectFuncWatch(ctx, opts)
	}

	mm_params := KubernetesNamespaceableResourceInterfaceMockWatchParams{ctx, opts}

	// Record call args
	mmWatch.WatchMock.mutex.Lock()
	mmWatch.WatchMock.callArgs = append(mmWatch.WatchMock.callArgs, &mm_params)
	mmWatch.WatchMock.mutex.Unlock()

	for _, e := range mmWatch.WatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmWatch.WatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatch.WatchMock.defaultExpectation.Counter, 1)
		mm_want := mmWatch.WatchMock.defaultExpectation.params
		mm_want_ptrs := mmWatch.WatchMock.defaultExpectation.paramPtrs

		mm_got := KubernetesNamespaceableResourceInterfaceMockWatchParams{ctx, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Watch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatch.WatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmWatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Watch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatch.WatchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatch.t.Errorf("KubernetesNamespaceableResourceInterfaceMock.Watch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWatch.WatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatch.WatchMock.defaultExpectation.results
		if mm_results == nil {
			mmWatch.t.Fatal("No results are set for the KubernetesNamespaceableResourceInterfaceMock.Watch")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmWatch.funcWatch != nil {
		return mmWatch.funcWatch(ctx, opts)
	}
	mmWatch.t.Fatalf("Unexpected call to KubernetesNamespaceableResourceInterfaceMock.Watch. %v %v", ctx, opts)
	return
}

// WatchAfterCounter returns a count of finished KubernetesNamespaceableResourceInterfaceMock.Watch invocations
func (mmWatch *KubernetesNamespaceableResourceInterfaceMock) WatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.afterWatchCounter)
}

// WatchBeforeCounter returns a count of KubernetesNamespaceableResourceInterfaceMock.Watch invocations
func (mmWatch *KubernetesNamespaceableResourceInterfaceMock) WatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.beforeWatchCounter)
}

// Calls returns a list of arguments used in each call to KubernetesNamespaceableResourceInterfaceMock.Watch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatch *mKubernetesNamespaceableResourceInterfaceMockWatch) Calls() []*KubernetesNamespaceableResourceInterfaceMockWatchParams {
	mmWatch.mutex.RLock()

	argCopy := make([]*KubernetesNamespaceableResourceInterfaceMockWatchParams, len(mmWatch.callArgs))
	copy(argCopy, mmWatch.callArgs)

	mmWatch.mutex.RUnlock()

	return argCopy
}

// MinimockWatchDone returns true if the count of the Watch invocations corresponds
// the number of defined expectations
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockWatchDone() bool {
	if m.WatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WatchMock.invocationsDone()
}

// MinimockWatchInspect logs each unmet expectation
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockWatchInspect() {
	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Watch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWatchCounter := mm_atomic.LoadUint64(&m.afterWatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WatchMock.defaultExpectation != nil && afterWatchCounter < 1 {
		if m.WatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Watch at\n%s", m.WatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Watch at\n%s with params: %#v", m.WatchMock.defaultExpectation.expectationOrigins.origin, *m.WatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatch != nil && afterWatchCounter < 1 {
		m.t.Errorf("Expected call to KubernetesNamespaceableResourceInterfaceMock.Watch at\n%s", m.funcWatchOrigin)
	}

	if !m.WatchMock.invocationsDone() && afterWatchCounter > 0 {
		m.t.Errorf("Expected %d calls to KubernetesNamespaceableResourceInterfaceMock.Watch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WatchMock.expectedInvocations), m.WatchMock.expectedInvocationsOrigin, afterWatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockApplyInspect()

			m.MinimockApplyStatusInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockDeleteCollectionInspect()

			m.MinimockGetInspect()

			m.MinimockListInspect()

			m.MinimockNamespaceInspect()

			m.MinimockPatchInspect()

			m.MinimockUpdateInspect()

			m.MinimockUpdateStatusInspect()

			m.MinimockWatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *KubernetesNamespaceableResourceInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *KubernetesNamespaceableResourceInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApplyDone() &&
		m.MinimockApplyStatusDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteCollectionDone() &&
		m.MinimockGetDone() &&
		m.MinimockListDone() &&
		m.MinimockNamespaceDone() &&
		m.MinimockPatchDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdateStatusDone() &&
		m.MinimockWatchDone()
}
