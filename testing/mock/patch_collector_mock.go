// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.EMPatchCollector -o patch_collector_mock.go -n PatchCollectorMock -p mock

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/module-sdk/pkg"
	"github.com/gojuno/minimock/v3"
)

// PatchCollectorMock implements mm_pkg.EMPatchCollector
type PatchCollectorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(object any, opts ...mm_pkg.PatchCollectorCreateOption)
	funcCreateOrigin    string
	inspectFuncCreate   func(object any, opts ...mm_pkg.PatchCollectorCreateOption)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mPatchCollectorMockCreate

	funcCreateIfNotExists          func(object any, opts ...mm_pkg.PatchCollectorCreateOption)
	funcCreateIfNotExistsOrigin    string
	inspectFuncCreateIfNotExists   func(object any, opts ...mm_pkg.PatchCollectorCreateOption)
	afterCreateIfNotExistsCounter  uint64
	beforeCreateIfNotExistsCounter uint64
	CreateIfNotExistsMock          mPatchCollectorMockCreateIfNotExists

	funcCreateOrUpdate          func(object any, opts ...mm_pkg.PatchCollectorCreateOption)
	funcCreateOrUpdateOrigin    string
	inspectFuncCreateOrUpdate   func(object any, opts ...mm_pkg.PatchCollectorCreateOption)
	afterCreateOrUpdateCounter  uint64
	beforeCreateOrUpdateCounter uint64
	CreateOrUpdateMock          mPatchCollectorMockCreateOrUpdate

	funcDelete          func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	funcDeleteOrigin    string
	inspectFuncDelete   func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mPatchCollectorMockDelete

	funcDeleteInBackground          func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	funcDeleteInBackgroundOrigin    string
	inspectFuncDeleteInBackground   func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	afterDeleteInBackgroundCounter  uint64
	beforeDeleteInBackgroundCounter uint64
	DeleteInBackgroundMock          mPatchCollectorMockDeleteInBackground

	funcDeleteNonCascading          func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	funcDeleteNonCascadingOrigin    string
	inspectFuncDeleteNonCascading   func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	afterDeleteNonCascadingCounter  uint64
	beforeDeleteNonCascadingCounter uint64
	DeleteNonCascadingMock          mPatchCollectorMockDeleteNonCascading

	funcJQFilter          func(jqfilter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorFilterOption)
	funcJQFilterOrigin    string
	inspectFuncJQFilter   func(jqfilter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorFilterOption)
	afterJQFilterCounter  uint64
	beforeJQFilterCounter uint64
	JQFilterMock          mPatchCollectorMockJQFilter

	funcJSONPatch          func(jsonPatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)
	funcJSONPatchOrigin    string
	inspectFuncJSONPatch   func(jsonPatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)
	afterJSONPatchCounter  uint64
	beforeJSONPatchCounter uint64
	JSONPatchMock          mPatchCollectorMockJSONPatch

	funcMergePatch          func(mergePatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)
	funcMergePatchOrigin    string
	inspectFuncMergePatch   func(mergePatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)
	afterMergePatchCounter  uint64
	beforeMergePatchCounter uint64
	MergePatchMock          mPatchCollectorMockMergePatch

	funcOperations          func() (pa1 []mm_pkg.PatchCollectorOperation)
	funcOperationsOrigin    string
	inspectFuncOperations   func()
	afterOperationsCounter  uint64
	beforeOperationsCounter uint64
	OperationsMock          mPatchCollectorMockOperations

	funcWriteOutput          func(writer io.Writer) (err error)
	funcWriteOutputOrigin    string
	inspectFuncWriteOutput   func(writer io.Writer)
	afterWriteOutputCounter  uint64
	beforeWriteOutputCounter uint64
	WriteOutputMock          mPatchCollectorMockWriteOutput
}

// NewPatchCollectorMock returns a mock for mm_pkg.EMPatchCollector
func NewPatchCollectorMock(t minimock.Tester) *PatchCollectorMock {
	m := &PatchCollectorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mPatchCollectorMockCreate{mock: m}
	m.CreateMock.callArgs = []*PatchCollectorMockCreateParams{}

	m.CreateIfNotExistsMock = mPatchCollectorMockCreateIfNotExists{mock: m}
	m.CreateIfNotExistsMock.callArgs = []*PatchCollectorMockCreateIfNotExistsParams{}

	m.CreateOrUpdateMock = mPatchCollectorMockCreateOrUpdate{mock: m}
	m.CreateOrUpdateMock.callArgs = []*PatchCollectorMockCreateOrUpdateParams{}

	m.DeleteMock = mPatchCollectorMockDelete{mock: m}
	m.DeleteMock.callArgs = []*PatchCollectorMockDeleteParams{}

	m.DeleteInBackgroundMock = mPatchCollectorMockDeleteInBackground{mock: m}
	m.DeleteInBackgroundMock.callArgs = []*PatchCollectorMockDeleteInBackgroundParams{}

	m.DeleteNonCascadingMock = mPatchCollectorMockDeleteNonCascading{mock: m}
	m.DeleteNonCascadingMock.callArgs = []*PatchCollectorMockDeleteNonCascadingParams{}

	m.JQFilterMock = mPatchCollectorMockJQFilter{mock: m}
	m.JQFilterMock.callArgs = []*PatchCollectorMockJQFilterParams{}

	m.JSONPatchMock = mPatchCollectorMockJSONPatch{mock: m}
	m.JSONPatchMock.callArgs = []*PatchCollectorMockJSONPatchParams{}

	m.MergePatchMock = mPatchCollectorMockMergePatch{mock: m}
	m.MergePatchMock.callArgs = []*PatchCollectorMockMergePatchParams{}

	m.OperationsMock = mPatchCollectorMockOperations{mock: m}

	m.WriteOutputMock = mPatchCollectorMockWriteOutput{mock: m}
	m.WriteOutputMock.callArgs = []*PatchCollectorMockWriteOutputParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPatchCollectorMockCreate struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockCreateExpectation
	expectations       []*PatchCollectorMockCreateExpectation

	callArgs []*PatchCollectorMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockCreateExpectation specifies expectation struct of the EMPatchCollector.Create
type PatchCollectorMockCreateExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockCreateParams
	paramPtrs          *PatchCollectorMockCreateParamPtrs
	expectationOrigins PatchCollectorMockCreateExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockCreateParams contains parameters of the EMPatchCollector.Create
type PatchCollectorMockCreateParams struct {
	object any
	opts   []mm_pkg.PatchCollectorCreateOption
}

// PatchCollectorMockCreateParamPtrs contains pointers to parameters of the EMPatchCollector.Create
type PatchCollectorMockCreateParamPtrs struct {
	object *any
	opts   *[]mm_pkg.PatchCollectorCreateOption
}

// PatchCollectorMockCreateOrigins contains origins of expectations of the EMPatchCollector.Create
type PatchCollectorMockCreateExpectationOrigins struct {
	origin       string
	originObject string
	originOpts   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mPatchCollectorMockCreate) Optional() *mPatchCollectorMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for EMPatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) Expect(object any, opts ...mm_pkg.PatchCollectorCreateOption) *mPatchCollectorMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PatchCollectorMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &PatchCollectorMockCreateParams{object, opts}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectObjectParam1 sets up expected param object for EMPatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) ExpectObjectParam1(object any) *mPatchCollectorMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PatchCollectorMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PatchCollectorMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.object = &object
	mmCreate.defaultExpectation.expectationOrigins.originObject = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectOptsParam2 sets up expected param opts for EMPatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) ExpectOptsParam2(opts ...mm_pkg.PatchCollectorCreateOption) *mPatchCollectorMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PatchCollectorMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PatchCollectorMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.opts = &opts
	mmCreate.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) Inspect(f func(object any, opts ...mm_pkg.PatchCollectorCreateOption)) *mPatchCollectorMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by EMPatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) Return() *PatchCollectorMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PatchCollectorMockCreateExpectation{mock: mmCreate.mock}
	}

	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the EMPatchCollector.Create method
func (mmCreate *mPatchCollectorMockCreate) Set(f func(object any, opts ...mm_pkg.PatchCollectorCreateOption)) *PatchCollectorMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the EMPatchCollector.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mPatchCollectorMockCreate) When(object any, opts ...mm_pkg.PatchCollectorCreateOption) *PatchCollectorMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	expectation := &PatchCollectorMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &PatchCollectorMockCreateParams{object, opts},
		expectationOrigins: PatchCollectorMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.Create return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockCreateExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.Create should be invoked
func (mmCreate *mPatchCollectorMockCreate) Times(n uint64) *mPatchCollectorMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of PatchCollectorMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mPatchCollectorMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_pkg.EMPatchCollector
func (mmCreate *PatchCollectorMock) Create(object any, opts ...mm_pkg.PatchCollectorCreateOption) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(object, opts...)
	}

	mm_params := PatchCollectorMockCreateParams{object, opts}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockCreateParams{object, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.object != nil && !minimock.Equal(*mm_want_ptrs.object, mm_got.object) {
				mmCreate.t.Errorf("PatchCollectorMock.Create got unexpected parameter object, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originObject, *mm_want_ptrs.object, mm_got.object, minimock.Diff(*mm_want_ptrs.object, mm_got.object))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreate.t.Errorf("PatchCollectorMock.Create got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("PatchCollectorMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCreate.funcCreate != nil {
		mmCreate.funcCreate(object, opts...)
		return
	}
	mmCreate.t.Fatalf("Unexpected call to PatchCollectorMock.Create. %v %v", object, opts)

}

// CreateAfterCounter returns a count of finished PatchCollectorMock.Create invocations
func (mmCreate *PatchCollectorMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of PatchCollectorMock.Create invocations
func (mmCreate *PatchCollectorMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mPatchCollectorMockCreate) Calls() []*PatchCollectorMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*PatchCollectorMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mPatchCollectorMockCreateIfNotExists struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockCreateIfNotExistsExpectation
	expectations       []*PatchCollectorMockCreateIfNotExistsExpectation

	callArgs []*PatchCollectorMockCreateIfNotExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockCreateIfNotExistsExpectation specifies expectation struct of the EMPatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockCreateIfNotExistsParams
	paramPtrs          *PatchCollectorMockCreateIfNotExistsParamPtrs
	expectationOrigins PatchCollectorMockCreateIfNotExistsExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockCreateIfNotExistsParams contains parameters of the EMPatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsParams struct {
	object any
	opts   []mm_pkg.PatchCollectorCreateOption
}

// PatchCollectorMockCreateIfNotExistsParamPtrs contains pointers to parameters of the EMPatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsParamPtrs struct {
	object *any
	opts   *[]mm_pkg.PatchCollectorCreateOption
}

// PatchCollectorMockCreateIfNotExistsOrigins contains origins of expectations of the EMPatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsExpectationOrigins struct {
	origin       string
	originObject string
	originOpts   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Optional() *mPatchCollectorMockCreateIfNotExists {
	mmCreateIfNotExists.optional = true
	return mmCreateIfNotExists
}

// Expect sets up expected params for EMPatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Expect(object any, opts ...mm_pkg.PatchCollectorCreateOption) *mPatchCollectorMockCreateIfNotExists {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	if mmCreateIfNotExists.defaultExpectation == nil {
		mmCreateIfNotExists.defaultExpectation = &PatchCollectorMockCreateIfNotExistsExpectation{}
	}

	if mmCreateIfNotExists.defaultExpectation.paramPtrs != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by ExpectParams functions")
	}

	mmCreateIfNotExists.defaultExpectation.params = &PatchCollectorMockCreateIfNotExistsParams{object, opts}
	mmCreateIfNotExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateIfNotExists.expectations {
		if minimock.Equal(e.params, mmCreateIfNotExists.defaultExpectation.params) {
			mmCreateIfNotExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateIfNotExists.defaultExpectation.params)
		}
	}

	return mmCreateIfNotExists
}

// ExpectObjectParam1 sets up expected param object for EMPatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) ExpectObjectParam1(object any) *mPatchCollectorMockCreateIfNotExists {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	if mmCreateIfNotExists.defaultExpectation == nil {
		mmCreateIfNotExists.defaultExpectation = &PatchCollectorMockCreateIfNotExistsExpectation{}
	}

	if mmCreateIfNotExists.defaultExpectation.params != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Expect")
	}

	if mmCreateIfNotExists.defaultExpectation.paramPtrs == nil {
		mmCreateIfNotExists.defaultExpectation.paramPtrs = &PatchCollectorMockCreateIfNotExistsParamPtrs{}
	}
	mmCreateIfNotExists.defaultExpectation.paramPtrs.object = &object
	mmCreateIfNotExists.defaultExpectation.expectationOrigins.originObject = minimock.CallerInfo(1)

	return mmCreateIfNotExists
}

// ExpectOptsParam2 sets up expected param opts for EMPatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) ExpectOptsParam2(opts ...mm_pkg.PatchCollectorCreateOption) *mPatchCollectorMockCreateIfNotExists {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	if mmCreateIfNotExists.defaultExpectation == nil {
		mmCreateIfNotExists.defaultExpectation = &PatchCollectorMockCreateIfNotExistsExpectation{}
	}

	if mmCreateIfNotExists.defaultExpectation.params != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Expect")
	}

	if mmCreateIfNotExists.defaultExpectation.paramPtrs == nil {
		mmCreateIfNotExists.defaultExpectation.paramPtrs = &PatchCollectorMockCreateIfNotExistsParamPtrs{}
	}
	mmCreateIfNotExists.defaultExpectation.paramPtrs.opts = &opts
	mmCreateIfNotExists.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmCreateIfNotExists
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Inspect(f func(object any, opts ...mm_pkg.PatchCollectorCreateOption)) *mPatchCollectorMockCreateIfNotExists {
	if mmCreateIfNotExists.mock.inspectFuncCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.CreateIfNotExists")
	}

	mmCreateIfNotExists.mock.inspectFuncCreateIfNotExists = f

	return mmCreateIfNotExists
}

// Return sets up results that will be returned by EMPatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Return() *PatchCollectorMock {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	if mmCreateIfNotExists.defaultExpectation == nil {
		mmCreateIfNotExists.defaultExpectation = &PatchCollectorMockCreateIfNotExistsExpectation{mock: mmCreateIfNotExists.mock}
	}

	mmCreateIfNotExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateIfNotExists.mock
}

// Set uses given function f to mock the EMPatchCollector.CreateIfNotExists method
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Set(f func(object any, opts ...mm_pkg.PatchCollectorCreateOption)) *PatchCollectorMock {
	if mmCreateIfNotExists.defaultExpectation != nil {
		mmCreateIfNotExists.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.CreateIfNotExists method")
	}

	if len(mmCreateIfNotExists.expectations) > 0 {
		mmCreateIfNotExists.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.CreateIfNotExists method")
	}

	mmCreateIfNotExists.mock.funcCreateIfNotExists = f
	mmCreateIfNotExists.mock.funcCreateIfNotExistsOrigin = minimock.CallerInfo(1)
	return mmCreateIfNotExists.mock
}

// When sets expectation for the EMPatchCollector.CreateIfNotExists which will trigger the result defined by the following
// Then helper
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) When(object any, opts ...mm_pkg.PatchCollectorCreateOption) *PatchCollectorMockCreateIfNotExistsExpectation {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	expectation := &PatchCollectorMockCreateIfNotExistsExpectation{
		mock:               mmCreateIfNotExists.mock,
		params:             &PatchCollectorMockCreateIfNotExistsParams{object, opts},
		expectationOrigins: PatchCollectorMockCreateIfNotExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateIfNotExists.expectations = append(mmCreateIfNotExists.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.CreateIfNotExists return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockCreateIfNotExistsExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.CreateIfNotExists should be invoked
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Times(n uint64) *mPatchCollectorMockCreateIfNotExists {
	if n == 0 {
		mmCreateIfNotExists.mock.t.Fatalf("Times of PatchCollectorMock.CreateIfNotExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateIfNotExists.expectedInvocations, n)
	mmCreateIfNotExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateIfNotExists
}

func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) invocationsDone() bool {
	if len(mmCreateIfNotExists.expectations) == 0 && mmCreateIfNotExists.defaultExpectation == nil && mmCreateIfNotExists.mock.funcCreateIfNotExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateIfNotExists.mock.afterCreateIfNotExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateIfNotExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateIfNotExists implements mm_pkg.EMPatchCollector
func (mmCreateIfNotExists *PatchCollectorMock) CreateIfNotExists(object any, opts ...mm_pkg.PatchCollectorCreateOption) {
	mm_atomic.AddUint64(&mmCreateIfNotExists.beforeCreateIfNotExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateIfNotExists.afterCreateIfNotExistsCounter, 1)

	mmCreateIfNotExists.t.Helper()

	if mmCreateIfNotExists.inspectFuncCreateIfNotExists != nil {
		mmCreateIfNotExists.inspectFuncCreateIfNotExists(object, opts...)
	}

	mm_params := PatchCollectorMockCreateIfNotExistsParams{object, opts}

	// Record call args
	mmCreateIfNotExists.CreateIfNotExistsMock.mutex.Lock()
	mmCreateIfNotExists.CreateIfNotExistsMock.callArgs = append(mmCreateIfNotExists.CreateIfNotExistsMock.callArgs, &mm_params)
	mmCreateIfNotExists.CreateIfNotExistsMock.mutex.Unlock()

	for _, e := range mmCreateIfNotExists.CreateIfNotExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockCreateIfNotExistsParams{object, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.object != nil && !minimock.Equal(*mm_want_ptrs.object, mm_got.object) {
				mmCreateIfNotExists.t.Errorf("PatchCollectorMock.CreateIfNotExists got unexpected parameter object, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.expectationOrigins.originObject, *mm_want_ptrs.object, mm_got.object, minimock.Diff(*mm_want_ptrs.object, mm_got.object))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateIfNotExists.t.Errorf("PatchCollectorMock.CreateIfNotExists got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateIfNotExists.t.Errorf("PatchCollectorMock.CreateIfNotExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCreateIfNotExists.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.funcCreateIfNotExists(object, opts...)
		return
	}
	mmCreateIfNotExists.t.Fatalf("Unexpected call to PatchCollectorMock.CreateIfNotExists. %v %v", object, opts)

}

// CreateIfNotExistsAfterCounter returns a count of finished PatchCollectorMock.CreateIfNotExists invocations
func (mmCreateIfNotExists *PatchCollectorMock) CreateIfNotExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateIfNotExists.afterCreateIfNotExistsCounter)
}

// CreateIfNotExistsBeforeCounter returns a count of PatchCollectorMock.CreateIfNotExists invocations
func (mmCreateIfNotExists *PatchCollectorMock) CreateIfNotExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateIfNotExists.beforeCreateIfNotExistsCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.CreateIfNotExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Calls() []*PatchCollectorMockCreateIfNotExistsParams {
	mmCreateIfNotExists.mutex.RLock()

	argCopy := make([]*PatchCollectorMockCreateIfNotExistsParams, len(mmCreateIfNotExists.callArgs))
	copy(argCopy, mmCreateIfNotExists.callArgs)

	mmCreateIfNotExists.mutex.RUnlock()

	return argCopy
}

// MinimockCreateIfNotExistsDone returns true if the count of the CreateIfNotExists invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockCreateIfNotExistsDone() bool {
	if m.CreateIfNotExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateIfNotExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateIfNotExistsMock.invocationsDone()
}

// MinimockCreateIfNotExistsInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockCreateIfNotExistsInspect() {
	for _, e := range m.CreateIfNotExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateIfNotExistsCounter := mm_atomic.LoadUint64(&m.afterCreateIfNotExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateIfNotExistsMock.defaultExpectation != nil && afterCreateIfNotExistsCounter < 1 {
		if m.CreateIfNotExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s", m.CreateIfNotExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s with params: %#v", m.CreateIfNotExistsMock.defaultExpectation.expectationOrigins.origin, *m.CreateIfNotExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateIfNotExists != nil && afterCreateIfNotExistsCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s", m.funcCreateIfNotExistsOrigin)
	}

	if !m.CreateIfNotExistsMock.invocationsDone() && afterCreateIfNotExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.CreateIfNotExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateIfNotExistsMock.expectedInvocations), m.CreateIfNotExistsMock.expectedInvocationsOrigin, afterCreateIfNotExistsCounter)
	}
}

type mPatchCollectorMockCreateOrUpdate struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockCreateOrUpdateExpectation
	expectations       []*PatchCollectorMockCreateOrUpdateExpectation

	callArgs []*PatchCollectorMockCreateOrUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockCreateOrUpdateExpectation specifies expectation struct of the EMPatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockCreateOrUpdateParams
	paramPtrs          *PatchCollectorMockCreateOrUpdateParamPtrs
	expectationOrigins PatchCollectorMockCreateOrUpdateExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockCreateOrUpdateParams contains parameters of the EMPatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateParams struct {
	object any
	opts   []mm_pkg.PatchCollectorCreateOption
}

// PatchCollectorMockCreateOrUpdateParamPtrs contains pointers to parameters of the EMPatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateParamPtrs struct {
	object *any
	opts   *[]mm_pkg.PatchCollectorCreateOption
}

// PatchCollectorMockCreateOrUpdateOrigins contains origins of expectations of the EMPatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateExpectationOrigins struct {
	origin       string
	originObject string
	originOpts   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Optional() *mPatchCollectorMockCreateOrUpdate {
	mmCreateOrUpdate.optional = true
	return mmCreateOrUpdate
}

// Expect sets up expected params for EMPatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Expect(object any, opts ...mm_pkg.PatchCollectorCreateOption) *mPatchCollectorMockCreateOrUpdate {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	if mmCreateOrUpdate.defaultExpectation == nil {
		mmCreateOrUpdate.defaultExpectation = &PatchCollectorMockCreateOrUpdateExpectation{}
	}

	if mmCreateOrUpdate.defaultExpectation.paramPtrs != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by ExpectParams functions")
	}

	mmCreateOrUpdate.defaultExpectation.params = &PatchCollectorMockCreateOrUpdateParams{object, opts}
	mmCreateOrUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrUpdate.expectations {
		if minimock.Equal(e.params, mmCreateOrUpdate.defaultExpectation.params) {
			mmCreateOrUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrUpdate.defaultExpectation.params)
		}
	}

	return mmCreateOrUpdate
}

// ExpectObjectParam1 sets up expected param object for EMPatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) ExpectObjectParam1(object any) *mPatchCollectorMockCreateOrUpdate {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	if mmCreateOrUpdate.defaultExpectation == nil {
		mmCreateOrUpdate.defaultExpectation = &PatchCollectorMockCreateOrUpdateExpectation{}
	}

	if mmCreateOrUpdate.defaultExpectation.params != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Expect")
	}

	if mmCreateOrUpdate.defaultExpectation.paramPtrs == nil {
		mmCreateOrUpdate.defaultExpectation.paramPtrs = &PatchCollectorMockCreateOrUpdateParamPtrs{}
	}
	mmCreateOrUpdate.defaultExpectation.paramPtrs.object = &object
	mmCreateOrUpdate.defaultExpectation.expectationOrigins.originObject = minimock.CallerInfo(1)

	return mmCreateOrUpdate
}

// ExpectOptsParam2 sets up expected param opts for EMPatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) ExpectOptsParam2(opts ...mm_pkg.PatchCollectorCreateOption) *mPatchCollectorMockCreateOrUpdate {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	if mmCreateOrUpdate.defaultExpectation == nil {
		mmCreateOrUpdate.defaultExpectation = &PatchCollectorMockCreateOrUpdateExpectation{}
	}

	if mmCreateOrUpdate.defaultExpectation.params != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Expect")
	}

	if mmCreateOrUpdate.defaultExpectation.paramPtrs == nil {
		mmCreateOrUpdate.defaultExpectation.paramPtrs = &PatchCollectorMockCreateOrUpdateParamPtrs{}
	}
	mmCreateOrUpdate.defaultExpectation.paramPtrs.opts = &opts
	mmCreateOrUpdate.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmCreateOrUpdate
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Inspect(f func(object any, opts ...mm_pkg.PatchCollectorCreateOption)) *mPatchCollectorMockCreateOrUpdate {
	if mmCreateOrUpdate.mock.inspectFuncCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.CreateOrUpdate")
	}

	mmCreateOrUpdate.mock.inspectFuncCreateOrUpdate = f

	return mmCreateOrUpdate
}

// Return sets up results that will be returned by EMPatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Return() *PatchCollectorMock {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	if mmCreateOrUpdate.defaultExpectation == nil {
		mmCreateOrUpdate.defaultExpectation = &PatchCollectorMockCreateOrUpdateExpectation{mock: mmCreateOrUpdate.mock}
	}

	mmCreateOrUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrUpdate.mock
}

// Set uses given function f to mock the EMPatchCollector.CreateOrUpdate method
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Set(f func(object any, opts ...mm_pkg.PatchCollectorCreateOption)) *PatchCollectorMock {
	if mmCreateOrUpdate.defaultExpectation != nil {
		mmCreateOrUpdate.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.CreateOrUpdate method")
	}

	if len(mmCreateOrUpdate.expectations) > 0 {
		mmCreateOrUpdate.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.CreateOrUpdate method")
	}

	mmCreateOrUpdate.mock.funcCreateOrUpdate = f
	mmCreateOrUpdate.mock.funcCreateOrUpdateOrigin = minimock.CallerInfo(1)
	return mmCreateOrUpdate.mock
}

// When sets expectation for the EMPatchCollector.CreateOrUpdate which will trigger the result defined by the following
// Then helper
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) When(object any, opts ...mm_pkg.PatchCollectorCreateOption) *PatchCollectorMockCreateOrUpdateExpectation {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	expectation := &PatchCollectorMockCreateOrUpdateExpectation{
		mock:               mmCreateOrUpdate.mock,
		params:             &PatchCollectorMockCreateOrUpdateParams{object, opts},
		expectationOrigins: PatchCollectorMockCreateOrUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrUpdate.expectations = append(mmCreateOrUpdate.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.CreateOrUpdate return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockCreateOrUpdateExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.CreateOrUpdate should be invoked
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Times(n uint64) *mPatchCollectorMockCreateOrUpdate {
	if n == 0 {
		mmCreateOrUpdate.mock.t.Fatalf("Times of PatchCollectorMock.CreateOrUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrUpdate.expectedInvocations, n)
	mmCreateOrUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrUpdate
}

func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) invocationsDone() bool {
	if len(mmCreateOrUpdate.expectations) == 0 && mmCreateOrUpdate.defaultExpectation == nil && mmCreateOrUpdate.mock.funcCreateOrUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrUpdate.mock.afterCreateOrUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrUpdate implements mm_pkg.EMPatchCollector
func (mmCreateOrUpdate *PatchCollectorMock) CreateOrUpdate(object any, opts ...mm_pkg.PatchCollectorCreateOption) {
	mm_atomic.AddUint64(&mmCreateOrUpdate.beforeCreateOrUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrUpdate.afterCreateOrUpdateCounter, 1)

	mmCreateOrUpdate.t.Helper()

	if mmCreateOrUpdate.inspectFuncCreateOrUpdate != nil {
		mmCreateOrUpdate.inspectFuncCreateOrUpdate(object, opts...)
	}

	mm_params := PatchCollectorMockCreateOrUpdateParams{object, opts}

	// Record call args
	mmCreateOrUpdate.CreateOrUpdateMock.mutex.Lock()
	mmCreateOrUpdate.CreateOrUpdateMock.callArgs = append(mmCreateOrUpdate.CreateOrUpdateMock.callArgs, &mm_params)
	mmCreateOrUpdate.CreateOrUpdateMock.mutex.Unlock()

	for _, e := range mmCreateOrUpdate.CreateOrUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockCreateOrUpdateParams{object, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.object != nil && !minimock.Equal(*mm_want_ptrs.object, mm_got.object) {
				mmCreateOrUpdate.t.Errorf("PatchCollectorMock.CreateOrUpdate got unexpected parameter object, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.expectationOrigins.originObject, *mm_want_ptrs.object, mm_got.object, minimock.Diff(*mm_want_ptrs.object, mm_got.object))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateOrUpdate.t.Errorf("PatchCollectorMock.CreateOrUpdate got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrUpdate.t.Errorf("PatchCollectorMock.CreateOrUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCreateOrUpdate.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.funcCreateOrUpdate(object, opts...)
		return
	}
	mmCreateOrUpdate.t.Fatalf("Unexpected call to PatchCollectorMock.CreateOrUpdate. %v %v", object, opts)

}

// CreateOrUpdateAfterCounter returns a count of finished PatchCollectorMock.CreateOrUpdate invocations
func (mmCreateOrUpdate *PatchCollectorMock) CreateOrUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrUpdate.afterCreateOrUpdateCounter)
}

// CreateOrUpdateBeforeCounter returns a count of PatchCollectorMock.CreateOrUpdate invocations
func (mmCreateOrUpdate *PatchCollectorMock) CreateOrUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrUpdate.beforeCreateOrUpdateCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.CreateOrUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Calls() []*PatchCollectorMockCreateOrUpdateParams {
	mmCreateOrUpdate.mutex.RLock()

	argCopy := make([]*PatchCollectorMockCreateOrUpdateParams, len(mmCreateOrUpdate.callArgs))
	copy(argCopy, mmCreateOrUpdate.callArgs)

	mmCreateOrUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrUpdateDone returns true if the count of the CreateOrUpdate invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockCreateOrUpdateDone() bool {
	if m.CreateOrUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrUpdateMock.invocationsDone()
}

// MinimockCreateOrUpdateInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockCreateOrUpdateInspect() {
	for _, e := range m.CreateOrUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrUpdateCounter := mm_atomic.LoadUint64(&m.afterCreateOrUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrUpdateMock.defaultExpectation != nil && afterCreateOrUpdateCounter < 1 {
		if m.CreateOrUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s", m.CreateOrUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s with params: %#v", m.CreateOrUpdateMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrUpdate != nil && afterCreateOrUpdateCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s", m.funcCreateOrUpdateOrigin)
	}

	if !m.CreateOrUpdateMock.invocationsDone() && afterCreateOrUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.CreateOrUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrUpdateMock.expectedInvocations), m.CreateOrUpdateMock.expectedInvocationsOrigin, afterCreateOrUpdateCounter)
	}
}

type mPatchCollectorMockDelete struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockDeleteExpectation
	expectations       []*PatchCollectorMockDeleteExpectation

	callArgs []*PatchCollectorMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockDeleteExpectation specifies expectation struct of the EMPatchCollector.Delete
type PatchCollectorMockDeleteExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockDeleteParams
	paramPtrs          *PatchCollectorMockDeleteParamPtrs
	expectationOrigins PatchCollectorMockDeleteExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockDeleteParams contains parameters of the EMPatchCollector.Delete
type PatchCollectorMockDeleteParams struct {
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteParamPtrs contains pointers to parameters of the EMPatchCollector.Delete
type PatchCollectorMockDeleteParamPtrs struct {
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteOrigins contains origins of expectations of the EMPatchCollector.Delete
type PatchCollectorMockDeleteExpectationOrigins struct {
	origin           string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mPatchCollectorMockDelete) Optional() *mPatchCollectorMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) Expect(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectApiVersionParam1 sets up expected param apiVersion for EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectApiVersionParam1(apiVersion string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmDelete.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectKindParam2 sets up expected param kind for EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectKindParam2(kind string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.kind = &kind
	mmDelete.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectNamespaceParam3 sets up expected param namespace for EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectNamespaceParam3(namespace string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.namespace = &namespace
	mmDelete.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectNameParam4 sets up expected param name for EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectNameParam4(name string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.name = &name
	mmDelete.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectOptsParam5 sets up expected param opts for EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectOptsParam5(opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.opts = &opts
	mmDelete.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) Inspect(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *mPatchCollectorMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by EMPatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) Return() *PatchCollectorMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{mock: mmDelete.mock}
	}

	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the EMPatchCollector.Delete method
func (mmDelete *mPatchCollectorMockDelete) Set(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *PatchCollectorMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the EMPatchCollector.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mPatchCollectorMockDelete) When(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *PatchCollectorMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	expectation := &PatchCollectorMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.Delete return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockDeleteExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.Delete should be invoked
func (mmDelete *mPatchCollectorMockDelete) Times(n uint64) *mPatchCollectorMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of PatchCollectorMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mPatchCollectorMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_pkg.EMPatchCollector
func (mmDelete *PatchCollectorMock) Delete(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDelete.funcDelete != nil {
		mmDelete.funcDelete(apiVersion, kind, namespace, name, opts...)
		return
	}
	mmDelete.t.Fatalf("Unexpected call to PatchCollectorMock.Delete. %v %v %v %v %v", apiVersion, kind, namespace, name, opts)

}

// DeleteAfterCounter returns a count of finished PatchCollectorMock.Delete invocations
func (mmDelete *PatchCollectorMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of PatchCollectorMock.Delete invocations
func (mmDelete *PatchCollectorMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mPatchCollectorMockDelete) Calls() []*PatchCollectorMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*PatchCollectorMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mPatchCollectorMockDeleteInBackground struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockDeleteInBackgroundExpectation
	expectations       []*PatchCollectorMockDeleteInBackgroundExpectation

	callArgs []*PatchCollectorMockDeleteInBackgroundParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockDeleteInBackgroundExpectation specifies expectation struct of the EMPatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockDeleteInBackgroundParams
	paramPtrs          *PatchCollectorMockDeleteInBackgroundParamPtrs
	expectationOrigins PatchCollectorMockDeleteInBackgroundExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockDeleteInBackgroundParams contains parameters of the EMPatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundParams struct {
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteInBackgroundParamPtrs contains pointers to parameters of the EMPatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundParamPtrs struct {
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteInBackgroundOrigins contains origins of expectations of the EMPatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundExpectationOrigins struct {
	origin           string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Optional() *mPatchCollectorMockDeleteInBackground {
	mmDeleteInBackground.optional = true
	return mmDeleteInBackground
}

// Expect sets up expected params for EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Expect(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by ExpectParams functions")
	}

	mmDeleteInBackground.defaultExpectation.params = &PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts}
	mmDeleteInBackground.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteInBackground.expectations {
		if minimock.Equal(e.params, mmDeleteInBackground.defaultExpectation.params) {
			mmDeleteInBackground.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteInBackground.defaultExpectation.params)
		}
	}

	return mmDeleteInBackground
}

// ExpectApiVersionParam1 sets up expected param apiVersion for EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectApiVersionParam1(apiVersion string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectKindParam2 sets up expected param kind for EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectKindParam2(kind string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.kind = &kind
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectNamespaceParam3 sets up expected param namespace for EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectNamespaceParam3(namespace string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.namespace = &namespace
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectNameParam4 sets up expected param name for EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectNameParam4(name string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.name = &name
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectOptsParam5 sets up expected param opts for EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectOptsParam5(opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Inspect(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.inspectFuncDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.DeleteInBackground")
	}

	mmDeleteInBackground.mock.inspectFuncDeleteInBackground = f

	return mmDeleteInBackground
}

// Return sets up results that will be returned by EMPatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Return() *PatchCollectorMock {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{mock: mmDeleteInBackground.mock}
	}

	mmDeleteInBackground.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteInBackground.mock
}

// Set uses given function f to mock the EMPatchCollector.DeleteInBackground method
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Set(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *PatchCollectorMock {
	if mmDeleteInBackground.defaultExpectation != nil {
		mmDeleteInBackground.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.DeleteInBackground method")
	}

	if len(mmDeleteInBackground.expectations) > 0 {
		mmDeleteInBackground.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.DeleteInBackground method")
	}

	mmDeleteInBackground.mock.funcDeleteInBackground = f
	mmDeleteInBackground.mock.funcDeleteInBackgroundOrigin = minimock.CallerInfo(1)
	return mmDeleteInBackground.mock
}

// When sets expectation for the EMPatchCollector.DeleteInBackground which will trigger the result defined by the following
// Then helper
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) When(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *PatchCollectorMockDeleteInBackgroundExpectation {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	expectation := &PatchCollectorMockDeleteInBackgroundExpectation{
		mock:               mmDeleteInBackground.mock,
		params:             &PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockDeleteInBackgroundExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteInBackground.expectations = append(mmDeleteInBackground.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.DeleteInBackground return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockDeleteInBackgroundExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.DeleteInBackground should be invoked
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Times(n uint64) *mPatchCollectorMockDeleteInBackground {
	if n == 0 {
		mmDeleteInBackground.mock.t.Fatalf("Times of PatchCollectorMock.DeleteInBackground mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteInBackground.expectedInvocations, n)
	mmDeleteInBackground.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteInBackground
}

func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) invocationsDone() bool {
	if len(mmDeleteInBackground.expectations) == 0 && mmDeleteInBackground.defaultExpectation == nil && mmDeleteInBackground.mock.funcDeleteInBackground == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteInBackground.mock.afterDeleteInBackgroundCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteInBackground.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteInBackground implements mm_pkg.EMPatchCollector
func (mmDeleteInBackground *PatchCollectorMock) DeleteInBackground(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) {
	mm_atomic.AddUint64(&mmDeleteInBackground.beforeDeleteInBackgroundCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteInBackground.afterDeleteInBackgroundCounter, 1)

	mmDeleteInBackground.t.Helper()

	if mmDeleteInBackground.inspectFuncDeleteInBackground != nil {
		mmDeleteInBackground.inspectFuncDeleteInBackground(apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts}

	// Record call args
	mmDeleteInBackground.DeleteInBackgroundMock.mutex.Lock()
	mmDeleteInBackground.DeleteInBackgroundMock.callArgs = append(mmDeleteInBackground.DeleteInBackgroundMock.callArgs, &mm_params)
	mmDeleteInBackground.DeleteInBackgroundMock.mutex.Unlock()

	for _, e := range mmDeleteInBackground.DeleteInBackgroundMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteInBackground.funcDeleteInBackground != nil {
		mmDeleteInBackground.funcDeleteInBackground(apiVersion, kind, namespace, name, opts...)
		return
	}
	mmDeleteInBackground.t.Fatalf("Unexpected call to PatchCollectorMock.DeleteInBackground. %v %v %v %v %v", apiVersion, kind, namespace, name, opts)

}

// DeleteInBackgroundAfterCounter returns a count of finished PatchCollectorMock.DeleteInBackground invocations
func (mmDeleteInBackground *PatchCollectorMock) DeleteInBackgroundAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteInBackground.afterDeleteInBackgroundCounter)
}

// DeleteInBackgroundBeforeCounter returns a count of PatchCollectorMock.DeleteInBackground invocations
func (mmDeleteInBackground *PatchCollectorMock) DeleteInBackgroundBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteInBackground.beforeDeleteInBackgroundCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.DeleteInBackground.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Calls() []*PatchCollectorMockDeleteInBackgroundParams {
	mmDeleteInBackground.mutex.RLock()

	argCopy := make([]*PatchCollectorMockDeleteInBackgroundParams, len(mmDeleteInBackground.callArgs))
	copy(argCopy, mmDeleteInBackground.callArgs)

	mmDeleteInBackground.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteInBackgroundDone returns true if the count of the DeleteInBackground invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockDeleteInBackgroundDone() bool {
	if m.DeleteInBackgroundMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteInBackgroundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteInBackgroundMock.invocationsDone()
}

// MinimockDeleteInBackgroundInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockDeleteInBackgroundInspect() {
	for _, e := range m.DeleteInBackgroundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteInBackgroundCounter := mm_atomic.LoadUint64(&m.afterDeleteInBackgroundCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteInBackgroundMock.defaultExpectation != nil && afterDeleteInBackgroundCounter < 1 {
		if m.DeleteInBackgroundMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s", m.DeleteInBackgroundMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s with params: %#v", m.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.origin, *m.DeleteInBackgroundMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteInBackground != nil && afterDeleteInBackgroundCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s", m.funcDeleteInBackgroundOrigin)
	}

	if !m.DeleteInBackgroundMock.invocationsDone() && afterDeleteInBackgroundCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.DeleteInBackground at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteInBackgroundMock.expectedInvocations), m.DeleteInBackgroundMock.expectedInvocationsOrigin, afterDeleteInBackgroundCounter)
	}
}

type mPatchCollectorMockDeleteNonCascading struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockDeleteNonCascadingExpectation
	expectations       []*PatchCollectorMockDeleteNonCascadingExpectation

	callArgs []*PatchCollectorMockDeleteNonCascadingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockDeleteNonCascadingExpectation specifies expectation struct of the EMPatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockDeleteNonCascadingParams
	paramPtrs          *PatchCollectorMockDeleteNonCascadingParamPtrs
	expectationOrigins PatchCollectorMockDeleteNonCascadingExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockDeleteNonCascadingParams contains parameters of the EMPatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingParams struct {
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteNonCascadingParamPtrs contains pointers to parameters of the EMPatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingParamPtrs struct {
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteNonCascadingOrigins contains origins of expectations of the EMPatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingExpectationOrigins struct {
	origin           string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Optional() *mPatchCollectorMockDeleteNonCascading {
	mmDeleteNonCascading.optional = true
	return mmDeleteNonCascading
}

// Expect sets up expected params for EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Expect(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by ExpectParams functions")
	}

	mmDeleteNonCascading.defaultExpectation.params = &PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts}
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNonCascading.expectations {
		if minimock.Equal(e.params, mmDeleteNonCascading.defaultExpectation.params) {
			mmDeleteNonCascading.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNonCascading.defaultExpectation.params)
		}
	}

	return mmDeleteNonCascading
}

// ExpectApiVersionParam1 sets up expected param apiVersion for EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectApiVersionParam1(apiVersion string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectKindParam2 sets up expected param kind for EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectKindParam2(kind string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.kind = &kind
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectNamespaceParam3 sets up expected param namespace for EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectNamespaceParam3(namespace string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.namespace = &namespace
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectNameParam4 sets up expected param name for EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectNameParam4(name string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.name = &name
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectOptsParam5 sets up expected param opts for EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectOptsParam5(opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Inspect(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.inspectFuncDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.DeleteNonCascading")
	}

	mmDeleteNonCascading.mock.inspectFuncDeleteNonCascading = f

	return mmDeleteNonCascading
}

// Return sets up results that will be returned by EMPatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Return() *PatchCollectorMock {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{mock: mmDeleteNonCascading.mock}
	}

	mmDeleteNonCascading.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNonCascading.mock
}

// Set uses given function f to mock the EMPatchCollector.DeleteNonCascading method
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Set(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *PatchCollectorMock {
	if mmDeleteNonCascading.defaultExpectation != nil {
		mmDeleteNonCascading.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.DeleteNonCascading method")
	}

	if len(mmDeleteNonCascading.expectations) > 0 {
		mmDeleteNonCascading.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.DeleteNonCascading method")
	}

	mmDeleteNonCascading.mock.funcDeleteNonCascading = f
	mmDeleteNonCascading.mock.funcDeleteNonCascadingOrigin = minimock.CallerInfo(1)
	return mmDeleteNonCascading.mock
}

// When sets expectation for the EMPatchCollector.DeleteNonCascading which will trigger the result defined by the following
// Then helper
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) When(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *PatchCollectorMockDeleteNonCascadingExpectation {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	expectation := &PatchCollectorMockDeleteNonCascadingExpectation{
		mock:               mmDeleteNonCascading.mock,
		params:             &PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockDeleteNonCascadingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNonCascading.expectations = append(mmDeleteNonCascading.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.DeleteNonCascading return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockDeleteNonCascadingExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.DeleteNonCascading should be invoked
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Times(n uint64) *mPatchCollectorMockDeleteNonCascading {
	if n == 0 {
		mmDeleteNonCascading.mock.t.Fatalf("Times of PatchCollectorMock.DeleteNonCascading mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNonCascading.expectedInvocations, n)
	mmDeleteNonCascading.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNonCascading
}

func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) invocationsDone() bool {
	if len(mmDeleteNonCascading.expectations) == 0 && mmDeleteNonCascading.defaultExpectation == nil && mmDeleteNonCascading.mock.funcDeleteNonCascading == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNonCascading.mock.afterDeleteNonCascadingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNonCascading.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNonCascading implements mm_pkg.EMPatchCollector
func (mmDeleteNonCascading *PatchCollectorMock) DeleteNonCascading(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) {
	mm_atomic.AddUint64(&mmDeleteNonCascading.beforeDeleteNonCascadingCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNonCascading.afterDeleteNonCascadingCounter, 1)

	mmDeleteNonCascading.t.Helper()

	if mmDeleteNonCascading.inspectFuncDeleteNonCascading != nil {
		mmDeleteNonCascading.inspectFuncDeleteNonCascading(apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts}

	// Record call args
	mmDeleteNonCascading.DeleteNonCascadingMock.mutex.Lock()
	mmDeleteNonCascading.DeleteNonCascadingMock.callArgs = append(mmDeleteNonCascading.DeleteNonCascadingMock.callArgs, &mm_params)
	mmDeleteNonCascading.DeleteNonCascadingMock.mutex.Unlock()

	for _, e := range mmDeleteNonCascading.DeleteNonCascadingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteNonCascading.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.funcDeleteNonCascading(apiVersion, kind, namespace, name, opts...)
		return
	}
	mmDeleteNonCascading.t.Fatalf("Unexpected call to PatchCollectorMock.DeleteNonCascading. %v %v %v %v %v", apiVersion, kind, namespace, name, opts)

}

// DeleteNonCascadingAfterCounter returns a count of finished PatchCollectorMock.DeleteNonCascading invocations
func (mmDeleteNonCascading *PatchCollectorMock) DeleteNonCascadingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNonCascading.afterDeleteNonCascadingCounter)
}

// DeleteNonCascadingBeforeCounter returns a count of PatchCollectorMock.DeleteNonCascading invocations
func (mmDeleteNonCascading *PatchCollectorMock) DeleteNonCascadingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNonCascading.beforeDeleteNonCascadingCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.DeleteNonCascading.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Calls() []*PatchCollectorMockDeleteNonCascadingParams {
	mmDeleteNonCascading.mutex.RLock()

	argCopy := make([]*PatchCollectorMockDeleteNonCascadingParams, len(mmDeleteNonCascading.callArgs))
	copy(argCopy, mmDeleteNonCascading.callArgs)

	mmDeleteNonCascading.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNonCascadingDone returns true if the count of the DeleteNonCascading invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockDeleteNonCascadingDone() bool {
	if m.DeleteNonCascadingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNonCascadingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNonCascadingMock.invocationsDone()
}

// MinimockDeleteNonCascadingInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockDeleteNonCascadingInspect() {
	for _, e := range m.DeleteNonCascadingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNonCascadingCounter := mm_atomic.LoadUint64(&m.afterDeleteNonCascadingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNonCascadingMock.defaultExpectation != nil && afterDeleteNonCascadingCounter < 1 {
		if m.DeleteNonCascadingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s", m.DeleteNonCascadingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s with params: %#v", m.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNonCascadingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNonCascading != nil && afterDeleteNonCascadingCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s", m.funcDeleteNonCascadingOrigin)
	}

	if !m.DeleteNonCascadingMock.invocationsDone() && afterDeleteNonCascadingCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.DeleteNonCascading at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNonCascadingMock.expectedInvocations), m.DeleteNonCascadingMock.expectedInvocationsOrigin, afterDeleteNonCascadingCounter)
	}
}

type mPatchCollectorMockJQFilter struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockJQFilterExpectation
	expectations       []*PatchCollectorMockJQFilterExpectation

	callArgs []*PatchCollectorMockJQFilterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockJQFilterExpectation specifies expectation struct of the EMPatchCollector.JQFilter
type PatchCollectorMockJQFilterExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockJQFilterParams
	paramPtrs          *PatchCollectorMockJQFilterParamPtrs
	expectationOrigins PatchCollectorMockJQFilterExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockJQFilterParams contains parameters of the EMPatchCollector.JQFilter
type PatchCollectorMockJQFilterParams struct {
	jqfilter   string
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorFilterOption
}

// PatchCollectorMockJQFilterParamPtrs contains pointers to parameters of the EMPatchCollector.JQFilter
type PatchCollectorMockJQFilterParamPtrs struct {
	jqfilter   *string
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorFilterOption
}

// PatchCollectorMockJQFilterOrigins contains origins of expectations of the EMPatchCollector.JQFilter
type PatchCollectorMockJQFilterExpectationOrigins struct {
	origin           string
	originJqfilter   string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmJQFilter *mPatchCollectorMockJQFilter) Optional() *mPatchCollectorMockJQFilter {
	mmJQFilter.optional = true
	return mmJQFilter
}

// Expect sets up expected params for EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) Expect(jqfilter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorFilterOption) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{}
	}

	if mmJQFilter.defaultExpectation.paramPtrs != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by ExpectParams functions")
	}

	mmJQFilter.defaultExpectation.params = &PatchCollectorMockJQFilterParams{jqfilter, apiVersion, kind, namespace, name, opts}
	mmJQFilter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmJQFilter.expectations {
		if minimock.Equal(e.params, mmJQFilter.defaultExpectation.params) {
			mmJQFilter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJQFilter.defaultExpectation.params)
		}
	}

	return mmJQFilter
}

// ExpectJqfilterParam1 sets up expected param jqfilter for EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) ExpectJqfilterParam1(jqfilter string) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{}
	}

	if mmJQFilter.defaultExpectation.params != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Expect")
	}

	if mmJQFilter.defaultExpectation.paramPtrs == nil {
		mmJQFilter.defaultExpectation.paramPtrs = &PatchCollectorMockJQFilterParamPtrs{}
	}
	mmJQFilter.defaultExpectation.paramPtrs.jqfilter = &jqfilter
	mmJQFilter.defaultExpectation.expectationOrigins.originJqfilter = minimock.CallerInfo(1)

	return mmJQFilter
}

// ExpectApiVersionParam2 sets up expected param apiVersion for EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) ExpectApiVersionParam2(apiVersion string) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{}
	}

	if mmJQFilter.defaultExpectation.params != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Expect")
	}

	if mmJQFilter.defaultExpectation.paramPtrs == nil {
		mmJQFilter.defaultExpectation.paramPtrs = &PatchCollectorMockJQFilterParamPtrs{}
	}
	mmJQFilter.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmJQFilter.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmJQFilter
}

// ExpectKindParam3 sets up expected param kind for EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) ExpectKindParam3(kind string) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{}
	}

	if mmJQFilter.defaultExpectation.params != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Expect")
	}

	if mmJQFilter.defaultExpectation.paramPtrs == nil {
		mmJQFilter.defaultExpectation.paramPtrs = &PatchCollectorMockJQFilterParamPtrs{}
	}
	mmJQFilter.defaultExpectation.paramPtrs.kind = &kind
	mmJQFilter.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmJQFilter
}

// ExpectNamespaceParam4 sets up expected param namespace for EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) ExpectNamespaceParam4(namespace string) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{}
	}

	if mmJQFilter.defaultExpectation.params != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Expect")
	}

	if mmJQFilter.defaultExpectation.paramPtrs == nil {
		mmJQFilter.defaultExpectation.paramPtrs = &PatchCollectorMockJQFilterParamPtrs{}
	}
	mmJQFilter.defaultExpectation.paramPtrs.namespace = &namespace
	mmJQFilter.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmJQFilter
}

// ExpectNameParam5 sets up expected param name for EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) ExpectNameParam5(name string) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{}
	}

	if mmJQFilter.defaultExpectation.params != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Expect")
	}

	if mmJQFilter.defaultExpectation.paramPtrs == nil {
		mmJQFilter.defaultExpectation.paramPtrs = &PatchCollectorMockJQFilterParamPtrs{}
	}
	mmJQFilter.defaultExpectation.paramPtrs.name = &name
	mmJQFilter.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmJQFilter
}

// ExpectOptsParam6 sets up expected param opts for EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) ExpectOptsParam6(opts ...mm_pkg.PatchCollectorFilterOption) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{}
	}

	if mmJQFilter.defaultExpectation.params != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Expect")
	}

	if mmJQFilter.defaultExpectation.paramPtrs == nil {
		mmJQFilter.defaultExpectation.paramPtrs = &PatchCollectorMockJQFilterParamPtrs{}
	}
	mmJQFilter.defaultExpectation.paramPtrs.opts = &opts
	mmJQFilter.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmJQFilter
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) Inspect(f func(jqfilter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorFilterOption)) *mPatchCollectorMockJQFilter {
	if mmJQFilter.mock.inspectFuncJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.JQFilter")
	}

	mmJQFilter.mock.inspectFuncJQFilter = f

	return mmJQFilter
}

// Return sets up results that will be returned by EMPatchCollector.JQFilter
func (mmJQFilter *mPatchCollectorMockJQFilter) Return() *PatchCollectorMock {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	if mmJQFilter.defaultExpectation == nil {
		mmJQFilter.defaultExpectation = &PatchCollectorMockJQFilterExpectation{mock: mmJQFilter.mock}
	}

	mmJQFilter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmJQFilter.mock
}

// Set uses given function f to mock the EMPatchCollector.JQFilter method
func (mmJQFilter *mPatchCollectorMockJQFilter) Set(f func(jqfilter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorFilterOption)) *PatchCollectorMock {
	if mmJQFilter.defaultExpectation != nil {
		mmJQFilter.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.JQFilter method")
	}

	if len(mmJQFilter.expectations) > 0 {
		mmJQFilter.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.JQFilter method")
	}

	mmJQFilter.mock.funcJQFilter = f
	mmJQFilter.mock.funcJQFilterOrigin = minimock.CallerInfo(1)
	return mmJQFilter.mock
}

// When sets expectation for the EMPatchCollector.JQFilter which will trigger the result defined by the following
// Then helper
func (mmJQFilter *mPatchCollectorMockJQFilter) When(jqfilter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorFilterOption) *PatchCollectorMockJQFilterExpectation {
	if mmJQFilter.mock.funcJQFilter != nil {
		mmJQFilter.mock.t.Fatalf("PatchCollectorMock.JQFilter mock is already set by Set")
	}

	expectation := &PatchCollectorMockJQFilterExpectation{
		mock:               mmJQFilter.mock,
		params:             &PatchCollectorMockJQFilterParams{jqfilter, apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockJQFilterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmJQFilter.expectations = append(mmJQFilter.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.JQFilter return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockJQFilterExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.JQFilter should be invoked
func (mmJQFilter *mPatchCollectorMockJQFilter) Times(n uint64) *mPatchCollectorMockJQFilter {
	if n == 0 {
		mmJQFilter.mock.t.Fatalf("Times of PatchCollectorMock.JQFilter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmJQFilter.expectedInvocations, n)
	mmJQFilter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmJQFilter
}

func (mmJQFilter *mPatchCollectorMockJQFilter) invocationsDone() bool {
	if len(mmJQFilter.expectations) == 0 && mmJQFilter.defaultExpectation == nil && mmJQFilter.mock.funcJQFilter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmJQFilter.mock.afterJQFilterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmJQFilter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// JQFilter implements mm_pkg.EMPatchCollector
func (mmJQFilter *PatchCollectorMock) JQFilter(jqfilter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorFilterOption) {
	mm_atomic.AddUint64(&mmJQFilter.beforeJQFilterCounter, 1)
	defer mm_atomic.AddUint64(&mmJQFilter.afterJQFilterCounter, 1)

	mmJQFilter.t.Helper()

	if mmJQFilter.inspectFuncJQFilter != nil {
		mmJQFilter.inspectFuncJQFilter(jqfilter, apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockJQFilterParams{jqfilter, apiVersion, kind, namespace, name, opts}

	// Record call args
	mmJQFilter.JQFilterMock.mutex.Lock()
	mmJQFilter.JQFilterMock.callArgs = append(mmJQFilter.JQFilterMock.callArgs, &mm_params)
	mmJQFilter.JQFilterMock.mutex.Unlock()

	for _, e := range mmJQFilter.JQFilterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmJQFilter.JQFilterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJQFilter.JQFilterMock.defaultExpectation.Counter, 1)
		mm_want := mmJQFilter.JQFilterMock.defaultExpectation.params
		mm_want_ptrs := mmJQFilter.JQFilterMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockJQFilterParams{jqfilter, apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.jqfilter != nil && !minimock.Equal(*mm_want_ptrs.jqfilter, mm_got.jqfilter) {
				mmJQFilter.t.Errorf("PatchCollectorMock.JQFilter got unexpected parameter jqfilter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQFilter.JQFilterMock.defaultExpectation.expectationOrigins.originJqfilter, *mm_want_ptrs.jqfilter, mm_got.jqfilter, minimock.Diff(*mm_want_ptrs.jqfilter, mm_got.jqfilter))
			}

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmJQFilter.t.Errorf("PatchCollectorMock.JQFilter got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQFilter.JQFilterMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmJQFilter.t.Errorf("PatchCollectorMock.JQFilter got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQFilter.JQFilterMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmJQFilter.t.Errorf("PatchCollectorMock.JQFilter got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQFilter.JQFilterMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmJQFilter.t.Errorf("PatchCollectorMock.JQFilter got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQFilter.JQFilterMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmJQFilter.t.Errorf("PatchCollectorMock.JQFilter got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQFilter.JQFilterMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJQFilter.t.Errorf("PatchCollectorMock.JQFilter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmJQFilter.JQFilterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmJQFilter.funcJQFilter != nil {
		mmJQFilter.funcJQFilter(jqfilter, apiVersion, kind, namespace, name, opts...)
		return
	}
	mmJQFilter.t.Fatalf("Unexpected call to PatchCollectorMock.JQFilter. %v %v %v %v %v %v", jqfilter, apiVersion, kind, namespace, name, opts)

}

// JQFilterAfterCounter returns a count of finished PatchCollectorMock.JQFilter invocations
func (mmJQFilter *PatchCollectorMock) JQFilterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJQFilter.afterJQFilterCounter)
}

// JQFilterBeforeCounter returns a count of PatchCollectorMock.JQFilter invocations
func (mmJQFilter *PatchCollectorMock) JQFilterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJQFilter.beforeJQFilterCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.JQFilter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJQFilter *mPatchCollectorMockJQFilter) Calls() []*PatchCollectorMockJQFilterParams {
	mmJQFilter.mutex.RLock()

	argCopy := make([]*PatchCollectorMockJQFilterParams, len(mmJQFilter.callArgs))
	copy(argCopy, mmJQFilter.callArgs)

	mmJQFilter.mutex.RUnlock()

	return argCopy
}

// MinimockJQFilterDone returns true if the count of the JQFilter invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockJQFilterDone() bool {
	if m.JQFilterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.JQFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.JQFilterMock.invocationsDone()
}

// MinimockJQFilterInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockJQFilterInspect() {
	for _, e := range m.JQFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.JQFilter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterJQFilterCounter := mm_atomic.LoadUint64(&m.afterJQFilterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.JQFilterMock.defaultExpectation != nil && afterJQFilterCounter < 1 {
		if m.JQFilterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.JQFilter at\n%s", m.JQFilterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.JQFilter at\n%s with params: %#v", m.JQFilterMock.defaultExpectation.expectationOrigins.origin, *m.JQFilterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJQFilter != nil && afterJQFilterCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.JQFilter at\n%s", m.funcJQFilterOrigin)
	}

	if !m.JQFilterMock.invocationsDone() && afterJQFilterCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.JQFilter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.JQFilterMock.expectedInvocations), m.JQFilterMock.expectedInvocationsOrigin, afterJQFilterCounter)
	}
}

type mPatchCollectorMockJSONPatch struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockJSONPatchExpectation
	expectations       []*PatchCollectorMockJSONPatchExpectation

	callArgs []*PatchCollectorMockJSONPatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockJSONPatchExpectation specifies expectation struct of the EMPatchCollector.JSONPatch
type PatchCollectorMockJSONPatchExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockJSONPatchParams
	paramPtrs          *PatchCollectorMockJSONPatchParamPtrs
	expectationOrigins PatchCollectorMockJSONPatchExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockJSONPatchParams contains parameters of the EMPatchCollector.JSONPatch
type PatchCollectorMockJSONPatchParams struct {
	jsonPatch  any
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorOption
}

// PatchCollectorMockJSONPatchParamPtrs contains pointers to parameters of the EMPatchCollector.JSONPatch
type PatchCollectorMockJSONPatchParamPtrs struct {
	jsonPatch  *any
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorOption
}

// PatchCollectorMockJSONPatchOrigins contains origins of expectations of the EMPatchCollector.JSONPatch
type PatchCollectorMockJSONPatchExpectationOrigins struct {
	origin           string
	originJsonPatch  string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Optional() *mPatchCollectorMockJSONPatch {
	mmJSONPatch.optional = true
	return mmJSONPatch
}

// Expect sets up expected params for EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Expect(jsonPatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.paramPtrs != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by ExpectParams functions")
	}

	mmJSONPatch.defaultExpectation.params = &PatchCollectorMockJSONPatchParams{jsonPatch, apiVersion, kind, namespace, name, opts}
	mmJSONPatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmJSONPatch.expectations {
		if minimock.Equal(e.params, mmJSONPatch.defaultExpectation.params) {
			mmJSONPatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJSONPatch.defaultExpectation.params)
		}
	}

	return mmJSONPatch
}

// ExpectJsonPatchParam1 sets up expected param jsonPatch for EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectJsonPatchParam1(jsonPatch any) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.jsonPatch = &jsonPatch
	mmJSONPatch.defaultExpectation.expectationOrigins.originJsonPatch = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectApiVersionParam2 sets up expected param apiVersion for EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectApiVersionParam2(apiVersion string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmJSONPatch.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectKindParam3 sets up expected param kind for EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectKindParam3(kind string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.kind = &kind
	mmJSONPatch.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectNamespaceParam4 sets up expected param namespace for EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectNamespaceParam4(namespace string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.namespace = &namespace
	mmJSONPatch.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectNameParam5 sets up expected param name for EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectNameParam5(name string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.name = &name
	mmJSONPatch.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectOptsParam6 sets up expected param opts for EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectOptsParam6(opts ...mm_pkg.PatchCollectorOption) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.opts = &opts
	mmJSONPatch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmJSONPatch
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Inspect(f func(jsonPatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.inspectFuncJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.JSONPatch")
	}

	mmJSONPatch.mock.inspectFuncJSONPatch = f

	return mmJSONPatch
}

// Return sets up results that will be returned by EMPatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Return() *PatchCollectorMock {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{mock: mmJSONPatch.mock}
	}

	mmJSONPatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmJSONPatch.mock
}

// Set uses given function f to mock the EMPatchCollector.JSONPatch method
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Set(f func(jsonPatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)) *PatchCollectorMock {
	if mmJSONPatch.defaultExpectation != nil {
		mmJSONPatch.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.JSONPatch method")
	}

	if len(mmJSONPatch.expectations) > 0 {
		mmJSONPatch.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.JSONPatch method")
	}

	mmJSONPatch.mock.funcJSONPatch = f
	mmJSONPatch.mock.funcJSONPatchOrigin = minimock.CallerInfo(1)
	return mmJSONPatch.mock
}

// When sets expectation for the EMPatchCollector.JSONPatch which will trigger the result defined by the following
// Then helper
func (mmJSONPatch *mPatchCollectorMockJSONPatch) When(jsonPatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption) *PatchCollectorMockJSONPatchExpectation {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	expectation := &PatchCollectorMockJSONPatchExpectation{
		mock:               mmJSONPatch.mock,
		params:             &PatchCollectorMockJSONPatchParams{jsonPatch, apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockJSONPatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmJSONPatch.expectations = append(mmJSONPatch.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.JSONPatch return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockJSONPatchExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.JSONPatch should be invoked
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Times(n uint64) *mPatchCollectorMockJSONPatch {
	if n == 0 {
		mmJSONPatch.mock.t.Fatalf("Times of PatchCollectorMock.JSONPatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmJSONPatch.expectedInvocations, n)
	mmJSONPatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmJSONPatch
}

func (mmJSONPatch *mPatchCollectorMockJSONPatch) invocationsDone() bool {
	if len(mmJSONPatch.expectations) == 0 && mmJSONPatch.defaultExpectation == nil && mmJSONPatch.mock.funcJSONPatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmJSONPatch.mock.afterJSONPatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmJSONPatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// JSONPatch implements mm_pkg.EMPatchCollector
func (mmJSONPatch *PatchCollectorMock) JSONPatch(jsonPatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption) {
	mm_atomic.AddUint64(&mmJSONPatch.beforeJSONPatchCounter, 1)
	defer mm_atomic.AddUint64(&mmJSONPatch.afterJSONPatchCounter, 1)

	mmJSONPatch.t.Helper()

	if mmJSONPatch.inspectFuncJSONPatch != nil {
		mmJSONPatch.inspectFuncJSONPatch(jsonPatch, apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockJSONPatchParams{jsonPatch, apiVersion, kind, namespace, name, opts}

	// Record call args
	mmJSONPatch.JSONPatchMock.mutex.Lock()
	mmJSONPatch.JSONPatchMock.callArgs = append(mmJSONPatch.JSONPatchMock.callArgs, &mm_params)
	mmJSONPatch.JSONPatchMock.mutex.Unlock()

	for _, e := range mmJSONPatch.JSONPatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmJSONPatch.JSONPatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJSONPatch.JSONPatchMock.defaultExpectation.Counter, 1)
		mm_want := mmJSONPatch.JSONPatchMock.defaultExpectation.params
		mm_want_ptrs := mmJSONPatch.JSONPatchMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockJSONPatchParams{jsonPatch, apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.jsonPatch != nil && !minimock.Equal(*mm_want_ptrs.jsonPatch, mm_got.jsonPatch) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter jsonPatch, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originJsonPatch, *mm_want_ptrs.jsonPatch, mm_got.jsonPatch, minimock.Diff(*mm_want_ptrs.jsonPatch, mm_got.jsonPatch))
			}

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmJSONPatch.funcJSONPatch != nil {
		mmJSONPatch.funcJSONPatch(jsonPatch, apiVersion, kind, namespace, name, opts...)
		return
	}
	mmJSONPatch.t.Fatalf("Unexpected call to PatchCollectorMock.JSONPatch. %v %v %v %v %v %v", jsonPatch, apiVersion, kind, namespace, name, opts)

}

// JSONPatchAfterCounter returns a count of finished PatchCollectorMock.JSONPatch invocations
func (mmJSONPatch *PatchCollectorMock) JSONPatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJSONPatch.afterJSONPatchCounter)
}

// JSONPatchBeforeCounter returns a count of PatchCollectorMock.JSONPatch invocations
func (mmJSONPatch *PatchCollectorMock) JSONPatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJSONPatch.beforeJSONPatchCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.JSONPatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Calls() []*PatchCollectorMockJSONPatchParams {
	mmJSONPatch.mutex.RLock()

	argCopy := make([]*PatchCollectorMockJSONPatchParams, len(mmJSONPatch.callArgs))
	copy(argCopy, mmJSONPatch.callArgs)

	mmJSONPatch.mutex.RUnlock()

	return argCopy
}

// MinimockJSONPatchDone returns true if the count of the JSONPatch invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockJSONPatchDone() bool {
	if m.JSONPatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.JSONPatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.JSONPatchMock.invocationsDone()
}

// MinimockJSONPatchInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockJSONPatchInspect() {
	for _, e := range m.JSONPatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterJSONPatchCounter := mm_atomic.LoadUint64(&m.afterJSONPatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.JSONPatchMock.defaultExpectation != nil && afterJSONPatchCounter < 1 {
		if m.JSONPatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s", m.JSONPatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s with params: %#v", m.JSONPatchMock.defaultExpectation.expectationOrigins.origin, *m.JSONPatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJSONPatch != nil && afterJSONPatchCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s", m.funcJSONPatchOrigin)
	}

	if !m.JSONPatchMock.invocationsDone() && afterJSONPatchCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.JSONPatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.JSONPatchMock.expectedInvocations), m.JSONPatchMock.expectedInvocationsOrigin, afterJSONPatchCounter)
	}
}

type mPatchCollectorMockMergePatch struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockMergePatchExpectation
	expectations       []*PatchCollectorMockMergePatchExpectation

	callArgs []*PatchCollectorMockMergePatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockMergePatchExpectation specifies expectation struct of the EMPatchCollector.MergePatch
type PatchCollectorMockMergePatchExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockMergePatchParams
	paramPtrs          *PatchCollectorMockMergePatchParamPtrs
	expectationOrigins PatchCollectorMockMergePatchExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockMergePatchParams contains parameters of the EMPatchCollector.MergePatch
type PatchCollectorMockMergePatchParams struct {
	mergePatch any
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorOption
}

// PatchCollectorMockMergePatchParamPtrs contains pointers to parameters of the EMPatchCollector.MergePatch
type PatchCollectorMockMergePatchParamPtrs struct {
	mergePatch *any
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorOption
}

// PatchCollectorMockMergePatchOrigins contains origins of expectations of the EMPatchCollector.MergePatch
type PatchCollectorMockMergePatchExpectationOrigins struct {
	origin           string
	originMergePatch string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMergePatch *mPatchCollectorMockMergePatch) Optional() *mPatchCollectorMockMergePatch {
	mmMergePatch.optional = true
	return mmMergePatch
}

// Expect sets up expected params for EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) Expect(mergePatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.paramPtrs != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by ExpectParams functions")
	}

	mmMergePatch.defaultExpectation.params = &PatchCollectorMockMergePatchParams{mergePatch, apiVersion, kind, namespace, name, opts}
	mmMergePatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMergePatch.expectations {
		if minimock.Equal(e.params, mmMergePatch.defaultExpectation.params) {
			mmMergePatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMergePatch.defaultExpectation.params)
		}
	}

	return mmMergePatch
}

// ExpectMergePatchParam1 sets up expected param mergePatch for EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectMergePatchParam1(mergePatch any) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.mergePatch = &mergePatch
	mmMergePatch.defaultExpectation.expectationOrigins.originMergePatch = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectApiVersionParam2 sets up expected param apiVersion for EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectApiVersionParam2(apiVersion string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmMergePatch.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectKindParam3 sets up expected param kind for EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectKindParam3(kind string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.kind = &kind
	mmMergePatch.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectNamespaceParam4 sets up expected param namespace for EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectNamespaceParam4(namespace string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.namespace = &namespace
	mmMergePatch.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectNameParam5 sets up expected param name for EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectNameParam5(name string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.name = &name
	mmMergePatch.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectOptsParam6 sets up expected param opts for EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectOptsParam6(opts ...mm_pkg.PatchCollectorOption) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.opts = &opts
	mmMergePatch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmMergePatch
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) Inspect(f func(mergePatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.inspectFuncMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.MergePatch")
	}

	mmMergePatch.mock.inspectFuncMergePatch = f

	return mmMergePatch
}

// Return sets up results that will be returned by EMPatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) Return() *PatchCollectorMock {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{mock: mmMergePatch.mock}
	}

	mmMergePatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMergePatch.mock
}

// Set uses given function f to mock the EMPatchCollector.MergePatch method
func (mmMergePatch *mPatchCollectorMockMergePatch) Set(f func(mergePatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption)) *PatchCollectorMock {
	if mmMergePatch.defaultExpectation != nil {
		mmMergePatch.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.MergePatch method")
	}

	if len(mmMergePatch.expectations) > 0 {
		mmMergePatch.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.MergePatch method")
	}

	mmMergePatch.mock.funcMergePatch = f
	mmMergePatch.mock.funcMergePatchOrigin = minimock.CallerInfo(1)
	return mmMergePatch.mock
}

// When sets expectation for the EMPatchCollector.MergePatch which will trigger the result defined by the following
// Then helper
func (mmMergePatch *mPatchCollectorMockMergePatch) When(mergePatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption) *PatchCollectorMockMergePatchExpectation {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	expectation := &PatchCollectorMockMergePatchExpectation{
		mock:               mmMergePatch.mock,
		params:             &PatchCollectorMockMergePatchParams{mergePatch, apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockMergePatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMergePatch.expectations = append(mmMergePatch.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.MergePatch return parameters for the expectation previously defined by the When method

func (e *PatchCollectorMockMergePatchExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times EMPatchCollector.MergePatch should be invoked
func (mmMergePatch *mPatchCollectorMockMergePatch) Times(n uint64) *mPatchCollectorMockMergePatch {
	if n == 0 {
		mmMergePatch.mock.t.Fatalf("Times of PatchCollectorMock.MergePatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMergePatch.expectedInvocations, n)
	mmMergePatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMergePatch
}

func (mmMergePatch *mPatchCollectorMockMergePatch) invocationsDone() bool {
	if len(mmMergePatch.expectations) == 0 && mmMergePatch.defaultExpectation == nil && mmMergePatch.mock.funcMergePatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMergePatch.mock.afterMergePatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMergePatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MergePatch implements mm_pkg.EMPatchCollector
func (mmMergePatch *PatchCollectorMock) MergePatch(mergePatch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorOption) {
	mm_atomic.AddUint64(&mmMergePatch.beforeMergePatchCounter, 1)
	defer mm_atomic.AddUint64(&mmMergePatch.afterMergePatchCounter, 1)

	mmMergePatch.t.Helper()

	if mmMergePatch.inspectFuncMergePatch != nil {
		mmMergePatch.inspectFuncMergePatch(mergePatch, apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockMergePatchParams{mergePatch, apiVersion, kind, namespace, name, opts}

	// Record call args
	mmMergePatch.MergePatchMock.mutex.Lock()
	mmMergePatch.MergePatchMock.callArgs = append(mmMergePatch.MergePatchMock.callArgs, &mm_params)
	mmMergePatch.MergePatchMock.mutex.Unlock()

	for _, e := range mmMergePatch.MergePatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmMergePatch.MergePatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMergePatch.MergePatchMock.defaultExpectation.Counter, 1)
		mm_want := mmMergePatch.MergePatchMock.defaultExpectation.params
		mm_want_ptrs := mmMergePatch.MergePatchMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockMergePatchParams{mergePatch, apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.mergePatch != nil && !minimock.Equal(*mm_want_ptrs.mergePatch, mm_got.mergePatch) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter mergePatch, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originMergePatch, *mm_want_ptrs.mergePatch, mm_got.mergePatch, minimock.Diff(*mm_want_ptrs.mergePatch, mm_got.mergePatch))
			}

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmMergePatch.funcMergePatch != nil {
		mmMergePatch.funcMergePatch(mergePatch, apiVersion, kind, namespace, name, opts...)
		return
	}
	mmMergePatch.t.Fatalf("Unexpected call to PatchCollectorMock.MergePatch. %v %v %v %v %v %v", mergePatch, apiVersion, kind, namespace, name, opts)

}

// MergePatchAfterCounter returns a count of finished PatchCollectorMock.MergePatch invocations
func (mmMergePatch *PatchCollectorMock) MergePatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMergePatch.afterMergePatchCounter)
}

// MergePatchBeforeCounter returns a count of PatchCollectorMock.MergePatch invocations
func (mmMergePatch *PatchCollectorMock) MergePatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMergePatch.beforeMergePatchCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.MergePatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMergePatch *mPatchCollectorMockMergePatch) Calls() []*PatchCollectorMockMergePatchParams {
	mmMergePatch.mutex.RLock()

	argCopy := make([]*PatchCollectorMockMergePatchParams, len(mmMergePatch.callArgs))
	copy(argCopy, mmMergePatch.callArgs)

	mmMergePatch.mutex.RUnlock()

	return argCopy
}

// MinimockMergePatchDone returns true if the count of the MergePatch invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockMergePatchDone() bool {
	if m.MergePatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MergePatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MergePatchMock.invocationsDone()
}

// MinimockMergePatchInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockMergePatchInspect() {
	for _, e := range m.MergePatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMergePatchCounter := mm_atomic.LoadUint64(&m.afterMergePatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MergePatchMock.defaultExpectation != nil && afterMergePatchCounter < 1 {
		if m.MergePatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s", m.MergePatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s with params: %#v", m.MergePatchMock.defaultExpectation.expectationOrigins.origin, *m.MergePatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMergePatch != nil && afterMergePatchCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s", m.funcMergePatchOrigin)
	}

	if !m.MergePatchMock.invocationsDone() && afterMergePatchCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.MergePatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MergePatchMock.expectedInvocations), m.MergePatchMock.expectedInvocationsOrigin, afterMergePatchCounter)
	}
}

type mPatchCollectorMockOperations struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockOperationsExpectation
	expectations       []*PatchCollectorMockOperationsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockOperationsExpectation specifies expectation struct of the EMPatchCollector.Operations
type PatchCollectorMockOperationsExpectation struct {
	mock *PatchCollectorMock

	results      *PatchCollectorMockOperationsResults
	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockOperationsResults contains results of the EMPatchCollector.Operations
type PatchCollectorMockOperationsResults struct {
	pa1 []mm_pkg.PatchCollectorOperation
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOperations *mPatchCollectorMockOperations) Optional() *mPatchCollectorMockOperations {
	mmOperations.optional = true
	return mmOperations
}

// Expect sets up expected params for EMPatchCollector.Operations
func (mmOperations *mPatchCollectorMockOperations) Expect() *mPatchCollectorMockOperations {
	if mmOperations.mock.funcOperations != nil {
		mmOperations.mock.t.Fatalf("PatchCollectorMock.Operations mock is already set by Set")
	}

	if mmOperations.defaultExpectation == nil {
		mmOperations.defaultExpectation = &PatchCollectorMockOperationsExpectation{}
	}

	return mmOperations
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.Operations
func (mmOperations *mPatchCollectorMockOperations) Inspect(f func()) *mPatchCollectorMockOperations {
	if mmOperations.mock.inspectFuncOperations != nil {
		mmOperations.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.Operations")
	}

	mmOperations.mock.inspectFuncOperations = f

	return mmOperations
}

// Return sets up results that will be returned by EMPatchCollector.Operations
func (mmOperations *mPatchCollectorMockOperations) Return(pa1 []mm_pkg.PatchCollectorOperation) *PatchCollectorMock {
	if mmOperations.mock.funcOperations != nil {
		mmOperations.mock.t.Fatalf("PatchCollectorMock.Operations mock is already set by Set")
	}

	if mmOperations.defaultExpectation == nil {
		mmOperations.defaultExpectation = &PatchCollectorMockOperationsExpectation{mock: mmOperations.mock}
	}
	mmOperations.defaultExpectation.results = &PatchCollectorMockOperationsResults{pa1}
	mmOperations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOperations.mock
}

// Set uses given function f to mock the EMPatchCollector.Operations method
func (mmOperations *mPatchCollectorMockOperations) Set(f func() (pa1 []mm_pkg.PatchCollectorOperation)) *PatchCollectorMock {
	if mmOperations.defaultExpectation != nil {
		mmOperations.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.Operations method")
	}

	if len(mmOperations.expectations) > 0 {
		mmOperations.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.Operations method")
	}

	mmOperations.mock.funcOperations = f
	mmOperations.mock.funcOperationsOrigin = minimock.CallerInfo(1)
	return mmOperations.mock
}

// Times sets number of times EMPatchCollector.Operations should be invoked
func (mmOperations *mPatchCollectorMockOperations) Times(n uint64) *mPatchCollectorMockOperations {
	if n == 0 {
		mmOperations.mock.t.Fatalf("Times of PatchCollectorMock.Operations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOperations.expectedInvocations, n)
	mmOperations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOperations
}

func (mmOperations *mPatchCollectorMockOperations) invocationsDone() bool {
	if len(mmOperations.expectations) == 0 && mmOperations.defaultExpectation == nil && mmOperations.mock.funcOperations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOperations.mock.afterOperationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOperations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Operations implements mm_pkg.EMPatchCollector
func (mmOperations *PatchCollectorMock) Operations() (pa1 []mm_pkg.PatchCollectorOperation) {
	mm_atomic.AddUint64(&mmOperations.beforeOperationsCounter, 1)
	defer mm_atomic.AddUint64(&mmOperations.afterOperationsCounter, 1)

	mmOperations.t.Helper()

	if mmOperations.inspectFuncOperations != nil {
		mmOperations.inspectFuncOperations()
	}

	if mmOperations.OperationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOperations.OperationsMock.defaultExpectation.Counter, 1)

		mm_results := mmOperations.OperationsMock.defaultExpectation.results
		if mm_results == nil {
			mmOperations.t.Fatal("No results are set for the PatchCollectorMock.Operations")
		}
		return (*mm_results).pa1
	}
	if mmOperations.funcOperations != nil {
		return mmOperations.funcOperations()
	}
	mmOperations.t.Fatalf("Unexpected call to PatchCollectorMock.Operations.")
	return
}

// OperationsAfterCounter returns a count of finished PatchCollectorMock.Operations invocations
func (mmOperations *PatchCollectorMock) OperationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOperations.afterOperationsCounter)
}

// OperationsBeforeCounter returns a count of PatchCollectorMock.Operations invocations
func (mmOperations *PatchCollectorMock) OperationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOperations.beforeOperationsCounter)
}

// MinimockOperationsDone returns true if the count of the Operations invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockOperationsDone() bool {
	if m.OperationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OperationsMock.invocationsDone()
}

// MinimockOperationsInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockOperationsInspect() {
	for _, e := range m.OperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PatchCollectorMock.Operations")
		}
	}

	afterOperationsCounter := mm_atomic.LoadUint64(&m.afterOperationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OperationsMock.defaultExpectation != nil && afterOperationsCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.Operations at\n%s", m.OperationsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOperations != nil && afterOperationsCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.Operations at\n%s", m.funcOperationsOrigin)
	}

	if !m.OperationsMock.invocationsDone() && afterOperationsCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.Operations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OperationsMock.expectedInvocations), m.OperationsMock.expectedInvocationsOrigin, afterOperationsCounter)
	}
}

type mPatchCollectorMockWriteOutput struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockWriteOutputExpectation
	expectations       []*PatchCollectorMockWriteOutputExpectation

	callArgs []*PatchCollectorMockWriteOutputParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockWriteOutputExpectation specifies expectation struct of the EMPatchCollector.WriteOutput
type PatchCollectorMockWriteOutputExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockWriteOutputParams
	paramPtrs          *PatchCollectorMockWriteOutputParamPtrs
	expectationOrigins PatchCollectorMockWriteOutputExpectationOrigins
	results            *PatchCollectorMockWriteOutputResults
	returnOrigin       string
	Counter            uint64
}

// PatchCollectorMockWriteOutputParams contains parameters of the EMPatchCollector.WriteOutput
type PatchCollectorMockWriteOutputParams struct {
	writer io.Writer
}

// PatchCollectorMockWriteOutputParamPtrs contains pointers to parameters of the EMPatchCollector.WriteOutput
type PatchCollectorMockWriteOutputParamPtrs struct {
	writer *io.Writer
}

// PatchCollectorMockWriteOutputResults contains results of the EMPatchCollector.WriteOutput
type PatchCollectorMockWriteOutputResults struct {
	err error
}

// PatchCollectorMockWriteOutputOrigins contains origins of expectations of the EMPatchCollector.WriteOutput
type PatchCollectorMockWriteOutputExpectationOrigins struct {
	origin       string
	originWriter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Optional() *mPatchCollectorMockWriteOutput {
	mmWriteOutput.optional = true
	return mmWriteOutput
}

// Expect sets up expected params for EMPatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Expect(writer io.Writer) *mPatchCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.paramPtrs != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by ExpectParams functions")
	}

	mmWriteOutput.defaultExpectation.params = &PatchCollectorMockWriteOutputParams{writer}
	mmWriteOutput.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWriteOutput.expectations {
		if minimock.Equal(e.params, mmWriteOutput.defaultExpectation.params) {
			mmWriteOutput.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteOutput.defaultExpectation.params)
		}
	}

	return mmWriteOutput
}

// ExpectWriterParam1 sets up expected param writer for EMPatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) ExpectWriterParam1(writer io.Writer) *mPatchCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.params != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Expect")
	}

	if mmWriteOutput.defaultExpectation.paramPtrs == nil {
		mmWriteOutput.defaultExpectation.paramPtrs = &PatchCollectorMockWriteOutputParamPtrs{}
	}
	mmWriteOutput.defaultExpectation.paramPtrs.writer = &writer
	mmWriteOutput.defaultExpectation.expectationOrigins.originWriter = minimock.CallerInfo(1)

	return mmWriteOutput
}

// Inspect accepts an inspector function that has same arguments as the EMPatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Inspect(f func(writer io.Writer)) *mPatchCollectorMockWriteOutput {
	if mmWriteOutput.mock.inspectFuncWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.WriteOutput")
	}

	mmWriteOutput.mock.inspectFuncWriteOutput = f

	return mmWriteOutput
}

// Return sets up results that will be returned by EMPatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Return(err error) *PatchCollectorMock {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchCollectorMockWriteOutputExpectation{mock: mmWriteOutput.mock}
	}
	mmWriteOutput.defaultExpectation.results = &PatchCollectorMockWriteOutputResults{err}
	mmWriteOutput.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// Set uses given function f to mock the EMPatchCollector.WriteOutput method
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Set(f func(writer io.Writer) (err error)) *PatchCollectorMock {
	if mmWriteOutput.defaultExpectation != nil {
		mmWriteOutput.mock.t.Fatalf("Default expectation is already set for the EMPatchCollector.WriteOutput method")
	}

	if len(mmWriteOutput.expectations) > 0 {
		mmWriteOutput.mock.t.Fatalf("Some expectations are already set for the EMPatchCollector.WriteOutput method")
	}

	mmWriteOutput.mock.funcWriteOutput = f
	mmWriteOutput.mock.funcWriteOutputOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// When sets expectation for the EMPatchCollector.WriteOutput which will trigger the result defined by the following
// Then helper
func (mmWriteOutput *mPatchCollectorMockWriteOutput) When(writer io.Writer) *PatchCollectorMockWriteOutputExpectation {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	expectation := &PatchCollectorMockWriteOutputExpectation{
		mock:               mmWriteOutput.mock,
		params:             &PatchCollectorMockWriteOutputParams{writer},
		expectationOrigins: PatchCollectorMockWriteOutputExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWriteOutput.expectations = append(mmWriteOutput.expectations, expectation)
	return expectation
}

// Then sets up EMPatchCollector.WriteOutput return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockWriteOutputExpectation) Then(err error) *PatchCollectorMock {
	e.results = &PatchCollectorMockWriteOutputResults{err}
	return e.mock
}

// Times sets number of times EMPatchCollector.WriteOutput should be invoked
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Times(n uint64) *mPatchCollectorMockWriteOutput {
	if n == 0 {
		mmWriteOutput.mock.t.Fatalf("Times of PatchCollectorMock.WriteOutput mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteOutput.expectedInvocations, n)
	mmWriteOutput.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWriteOutput
}

func (mmWriteOutput *mPatchCollectorMockWriteOutput) invocationsDone() bool {
	if len(mmWriteOutput.expectations) == 0 && mmWriteOutput.defaultExpectation == nil && mmWriteOutput.mock.funcWriteOutput == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteOutput.mock.afterWriteOutputCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteOutput.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteOutput implements mm_pkg.EMPatchCollector
func (mmWriteOutput *PatchCollectorMock) WriteOutput(writer io.Writer) (err error) {
	mm_atomic.AddUint64(&mmWriteOutput.beforeWriteOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteOutput.afterWriteOutputCounter, 1)

	mmWriteOutput.t.Helper()

	if mmWriteOutput.inspectFuncWriteOutput != nil {
		mmWriteOutput.inspectFuncWriteOutput(writer)
	}

	mm_params := PatchCollectorMockWriteOutputParams{writer}

	// Record call args
	mmWriteOutput.WriteOutputMock.mutex.Lock()
	mmWriteOutput.WriteOutputMock.callArgs = append(mmWriteOutput.WriteOutputMock.callArgs, &mm_params)
	mmWriteOutput.WriteOutputMock.mutex.Unlock()

	for _, e := range mmWriteOutput.WriteOutputMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWriteOutput.WriteOutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteOutput.WriteOutputMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteOutput.WriteOutputMock.defaultExpectation.params
		mm_want_ptrs := mmWriteOutput.WriteOutputMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockWriteOutputParams{writer}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.writer != nil && !minimock.Equal(*mm_want_ptrs.writer, mm_got.writer) {
				mmWriteOutput.t.Errorf("PatchCollectorMock.WriteOutput got unexpected parameter writer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.originWriter, *mm_want_ptrs.writer, mm_got.writer, minimock.Diff(*mm_want_ptrs.writer, mm_got.writer))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteOutput.t.Errorf("PatchCollectorMock.WriteOutput got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteOutput.WriteOutputMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteOutput.t.Fatal("No results are set for the PatchCollectorMock.WriteOutput")
		}
		return (*mm_results).err
	}
	if mmWriteOutput.funcWriteOutput != nil {
		return mmWriteOutput.funcWriteOutput(writer)
	}
	mmWriteOutput.t.Fatalf("Unexpected call to PatchCollectorMock.WriteOutput. %v", writer)
	return
}

// WriteOutputAfterCounter returns a count of finished PatchCollectorMock.WriteOutput invocations
func (mmWriteOutput *PatchCollectorMock) WriteOutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.afterWriteOutputCounter)
}

// WriteOutputBeforeCounter returns a count of PatchCollectorMock.WriteOutput invocations
func (mmWriteOutput *PatchCollectorMock) WriteOutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.beforeWriteOutputCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.WriteOutput.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Calls() []*PatchCollectorMockWriteOutputParams {
	mmWriteOutput.mutex.RLock()

	argCopy := make([]*PatchCollectorMockWriteOutputParams, len(mmWriteOutput.callArgs))
	copy(argCopy, mmWriteOutput.callArgs)

	mmWriteOutput.mutex.RUnlock()

	return argCopy
}

// MinimockWriteOutputDone returns true if the count of the WriteOutput invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockWriteOutputDone() bool {
	if m.WriteOutputMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteOutputMock.invocationsDone()
}

// MinimockWriteOutputInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockWriteOutputInspect() {
	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWriteOutputCounter := mm_atomic.LoadUint64(&m.afterWriteOutputCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteOutputMock.defaultExpectation != nil && afterWriteOutputCounter < 1 {
		if m.WriteOutputMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s", m.WriteOutputMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s with params: %#v", m.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *m.WriteOutputMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteOutput != nil && afterWriteOutputCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s", m.funcWriteOutputOrigin)
	}

	if !m.WriteOutputMock.invocationsDone() && afterWriteOutputCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.WriteOutput at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteOutputMock.expectedInvocations), m.WriteOutputMock.expectedInvocationsOrigin, afterWriteOutputCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PatchCollectorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockCreateIfNotExistsInspect()

			m.MinimockCreateOrUpdateInspect()

			m.MinimockDeleteInspect()

			m.MinimockDeleteInBackgroundInspect()

			m.MinimockDeleteNonCascadingInspect()

			m.MinimockJQFilterInspect()

			m.MinimockJSONPatchInspect()

			m.MinimockMergePatchInspect()

			m.MinimockOperationsInspect()

			m.MinimockWriteOutputInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PatchCollectorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PatchCollectorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockCreateIfNotExistsDone() &&
		m.MinimockCreateOrUpdateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteInBackgroundDone() &&
		m.MinimockDeleteNonCascadingDone() &&
		m.MinimockJQFilterDone() &&
		m.MinimockJSONPatchDone() &&
		m.MinimockMergePatchDone() &&
		m.MinimockOperationsDone() &&
		m.MinimockWriteOutputDone()
}
