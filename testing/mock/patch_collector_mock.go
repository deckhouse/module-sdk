// Code generated by http://github.com/gojuno/minimock ((devel)). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.PatchCollector -o patch_collector_mock.go -n PatchCollectorMock -p mock

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/module-sdk/pkg"
	"github.com/gojuno/minimock/v3"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// PatchCollectorMock implements mm_pkg.PatchCollector
type PatchCollectorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(data *unstructured.Unstructured)
	funcCreateOrigin    string
	inspectFuncCreate   func(data *unstructured.Unstructured)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mPatchCollectorMockCreate

	funcCreateIfNotExists          func(data *unstructured.Unstructured)
	funcCreateIfNotExistsOrigin    string
	inspectFuncCreateIfNotExists   func(data *unstructured.Unstructured)
	afterCreateIfNotExistsCounter  uint64
	beforeCreateIfNotExistsCounter uint64
	CreateIfNotExistsMock          mPatchCollectorMockCreateIfNotExists

	funcCreateOrUpdate          func(data *unstructured.Unstructured)
	funcCreateOrUpdateOrigin    string
	inspectFuncCreateOrUpdate   func(data *unstructured.Unstructured)
	afterCreateOrUpdateCounter  uint64
	beforeCreateOrUpdateCounter uint64
	CreateOrUpdateMock          mPatchCollectorMockCreateOrUpdate

	funcDelete          func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	funcDeleteOrigin    string
	inspectFuncDelete   func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mPatchCollectorMockDelete

	funcDeleteInBackground          func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	funcDeleteInBackgroundOrigin    string
	inspectFuncDeleteInBackground   func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	afterDeleteInBackgroundCounter  uint64
	beforeDeleteInBackgroundCounter uint64
	DeleteInBackgroundMock          mPatchCollectorMockDeleteInBackground

	funcDeleteNonCascading          func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	funcDeleteNonCascadingOrigin    string
	inspectFuncDeleteNonCascading   func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)
	afterDeleteNonCascadingCounter  uint64
	beforeDeleteNonCascadingCounter uint64
	DeleteNonCascadingMock          mPatchCollectorMockDeleteNonCascading

	funcJQPatch          func(filter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)
	funcJQPatchOrigin    string
	inspectFuncJQPatch   func(filter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)
	afterJQPatchCounter  uint64
	beforeJQPatchCounter uint64
	JQPatchMock          mPatchCollectorMockJQPatch

	funcJSONPatch          func(patch []any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)
	funcJSONPatchOrigin    string
	inspectFuncJSONPatch   func(patch []any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)
	afterJSONPatchCounter  uint64
	beforeJSONPatchCounter uint64
	JSONPatchMock          mPatchCollectorMockJSONPatch

	funcMergePatch          func(patch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)
	funcMergePatchOrigin    string
	inspectFuncMergePatch   func(patch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)
	afterMergePatchCounter  uint64
	beforeMergePatchCounter uint64
	MergePatchMock          mPatchCollectorMockMergePatch

	funcWriteOutput          func(writer io.Writer) (err error)
	funcWriteOutputOrigin    string
	inspectFuncWriteOutput   func(writer io.Writer)
	afterWriteOutputCounter  uint64
	beforeWriteOutputCounter uint64
	WriteOutputMock          mPatchCollectorMockWriteOutput
}

// NewPatchCollectorMock returns a mock for mm_pkg.PatchCollector
func NewPatchCollectorMock(t minimock.Tester) *PatchCollectorMock {
	m := &PatchCollectorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mPatchCollectorMockCreate{mock: m}
	m.CreateMock.callArgs = []*PatchCollectorMockCreateParams{}

	m.CreateIfNotExistsMock = mPatchCollectorMockCreateIfNotExists{mock: m}
	m.CreateIfNotExistsMock.callArgs = []*PatchCollectorMockCreateIfNotExistsParams{}

	m.CreateOrUpdateMock = mPatchCollectorMockCreateOrUpdate{mock: m}
	m.CreateOrUpdateMock.callArgs = []*PatchCollectorMockCreateOrUpdateParams{}

	m.DeleteMock = mPatchCollectorMockDelete{mock: m}
	m.DeleteMock.callArgs = []*PatchCollectorMockDeleteParams{}

	m.DeleteInBackgroundMock = mPatchCollectorMockDeleteInBackground{mock: m}
	m.DeleteInBackgroundMock.callArgs = []*PatchCollectorMockDeleteInBackgroundParams{}

	m.DeleteNonCascadingMock = mPatchCollectorMockDeleteNonCascading{mock: m}
	m.DeleteNonCascadingMock.callArgs = []*PatchCollectorMockDeleteNonCascadingParams{}

	m.JQPatchMock = mPatchCollectorMockJQPatch{mock: m}
	m.JQPatchMock.callArgs = []*PatchCollectorMockJQPatchParams{}

	m.JSONPatchMock = mPatchCollectorMockJSONPatch{mock: m}
	m.JSONPatchMock.callArgs = []*PatchCollectorMockJSONPatchParams{}

	m.MergePatchMock = mPatchCollectorMockMergePatch{mock: m}
	m.MergePatchMock.callArgs = []*PatchCollectorMockMergePatchParams{}

	m.WriteOutputMock = mPatchCollectorMockWriteOutput{mock: m}
	m.WriteOutputMock.callArgs = []*PatchCollectorMockWriteOutputParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPatchCollectorMockCreate struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockCreateExpectation
	expectations       []*PatchCollectorMockCreateExpectation

	callArgs []*PatchCollectorMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockCreateExpectation specifies expectation struct of the PatchCollector.Create
type PatchCollectorMockCreateExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockCreateParams
	paramPtrs          *PatchCollectorMockCreateParamPtrs
	expectationOrigins PatchCollectorMockCreateExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockCreateParams contains parameters of the PatchCollector.Create
type PatchCollectorMockCreateParams struct {
	data *unstructured.Unstructured
}

// PatchCollectorMockCreateParamPtrs contains pointers to parameters of the PatchCollector.Create
type PatchCollectorMockCreateParamPtrs struct {
	data **unstructured.Unstructured
}

// PatchCollectorMockCreateOrigins contains origins of expectations of the PatchCollector.Create
type PatchCollectorMockCreateExpectationOrigins struct {
	origin     string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mPatchCollectorMockCreate) Optional() *mPatchCollectorMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for PatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) Expect(data *unstructured.Unstructured) *mPatchCollectorMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PatchCollectorMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &PatchCollectorMockCreateParams{data}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectDataParam1 sets up expected param data for PatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) ExpectDataParam1(data *unstructured.Unstructured) *mPatchCollectorMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PatchCollectorMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PatchCollectorMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.data = &data
	mmCreate.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) Inspect(f func(data *unstructured.Unstructured)) *mPatchCollectorMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by PatchCollector.Create
func (mmCreate *mPatchCollectorMockCreate) Return() *PatchCollectorMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PatchCollectorMockCreateExpectation{mock: mmCreate.mock}
	}

	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the PatchCollector.Create method
func (mmCreate *mPatchCollectorMockCreate) Set(f func(data *unstructured.Unstructured)) *PatchCollectorMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the PatchCollector.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the PatchCollector.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the PatchCollector.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mPatchCollectorMockCreate) When(data *unstructured.Unstructured) *PatchCollectorMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PatchCollectorMock.Create mock is already set by Set")
	}

	expectation := &PatchCollectorMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &PatchCollectorMockCreateParams{data},
		expectationOrigins: PatchCollectorMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.Create return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockCreateExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.Create should be invoked
func (mmCreate *mPatchCollectorMockCreate) Times(n uint64) *mPatchCollectorMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of PatchCollectorMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mPatchCollectorMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_pkg.PatchCollector
func (mmCreate *PatchCollectorMock) Create(data *unstructured.Unstructured) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(data)
	}

	mm_params := PatchCollectorMockCreateParams{data}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockCreateParams{data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmCreate.t.Errorf("PatchCollectorMock.Create got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("PatchCollectorMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCreate.funcCreate != nil {
		mmCreate.funcCreate(data)
		return
	}
	mmCreate.t.Fatalf("Unexpected call to PatchCollectorMock.Create. %v", data)

}

// CreateAfterCounter returns a count of finished PatchCollectorMock.Create invocations
func (mmCreate *PatchCollectorMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of PatchCollectorMock.Create invocations
func (mmCreate *PatchCollectorMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mPatchCollectorMockCreate) Calls() []*PatchCollectorMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*PatchCollectorMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mPatchCollectorMockCreateIfNotExists struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockCreateIfNotExistsExpectation
	expectations       []*PatchCollectorMockCreateIfNotExistsExpectation

	callArgs []*PatchCollectorMockCreateIfNotExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockCreateIfNotExistsExpectation specifies expectation struct of the PatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockCreateIfNotExistsParams
	paramPtrs          *PatchCollectorMockCreateIfNotExistsParamPtrs
	expectationOrigins PatchCollectorMockCreateIfNotExistsExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockCreateIfNotExistsParams contains parameters of the PatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsParams struct {
	data *unstructured.Unstructured
}

// PatchCollectorMockCreateIfNotExistsParamPtrs contains pointers to parameters of the PatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsParamPtrs struct {
	data **unstructured.Unstructured
}

// PatchCollectorMockCreateIfNotExistsOrigins contains origins of expectations of the PatchCollector.CreateIfNotExists
type PatchCollectorMockCreateIfNotExistsExpectationOrigins struct {
	origin     string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Optional() *mPatchCollectorMockCreateIfNotExists {
	mmCreateIfNotExists.optional = true
	return mmCreateIfNotExists
}

// Expect sets up expected params for PatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Expect(data *unstructured.Unstructured) *mPatchCollectorMockCreateIfNotExists {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	if mmCreateIfNotExists.defaultExpectation == nil {
		mmCreateIfNotExists.defaultExpectation = &PatchCollectorMockCreateIfNotExistsExpectation{}
	}

	if mmCreateIfNotExists.defaultExpectation.paramPtrs != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by ExpectParams functions")
	}

	mmCreateIfNotExists.defaultExpectation.params = &PatchCollectorMockCreateIfNotExistsParams{data}
	mmCreateIfNotExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateIfNotExists.expectations {
		if minimock.Equal(e.params, mmCreateIfNotExists.defaultExpectation.params) {
			mmCreateIfNotExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateIfNotExists.defaultExpectation.params)
		}
	}

	return mmCreateIfNotExists
}

// ExpectDataParam1 sets up expected param data for PatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) ExpectDataParam1(data *unstructured.Unstructured) *mPatchCollectorMockCreateIfNotExists {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	if mmCreateIfNotExists.defaultExpectation == nil {
		mmCreateIfNotExists.defaultExpectation = &PatchCollectorMockCreateIfNotExistsExpectation{}
	}

	if mmCreateIfNotExists.defaultExpectation.params != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Expect")
	}

	if mmCreateIfNotExists.defaultExpectation.paramPtrs == nil {
		mmCreateIfNotExists.defaultExpectation.paramPtrs = &PatchCollectorMockCreateIfNotExistsParamPtrs{}
	}
	mmCreateIfNotExists.defaultExpectation.paramPtrs.data = &data
	mmCreateIfNotExists.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmCreateIfNotExists
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Inspect(f func(data *unstructured.Unstructured)) *mPatchCollectorMockCreateIfNotExists {
	if mmCreateIfNotExists.mock.inspectFuncCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.CreateIfNotExists")
	}

	mmCreateIfNotExists.mock.inspectFuncCreateIfNotExists = f

	return mmCreateIfNotExists
}

// Return sets up results that will be returned by PatchCollector.CreateIfNotExists
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Return() *PatchCollectorMock {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	if mmCreateIfNotExists.defaultExpectation == nil {
		mmCreateIfNotExists.defaultExpectation = &PatchCollectorMockCreateIfNotExistsExpectation{mock: mmCreateIfNotExists.mock}
	}

	mmCreateIfNotExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateIfNotExists.mock
}

// Set uses given function f to mock the PatchCollector.CreateIfNotExists method
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Set(f func(data *unstructured.Unstructured)) *PatchCollectorMock {
	if mmCreateIfNotExists.defaultExpectation != nil {
		mmCreateIfNotExists.mock.t.Fatalf("Default expectation is already set for the PatchCollector.CreateIfNotExists method")
	}

	if len(mmCreateIfNotExists.expectations) > 0 {
		mmCreateIfNotExists.mock.t.Fatalf("Some expectations are already set for the PatchCollector.CreateIfNotExists method")
	}

	mmCreateIfNotExists.mock.funcCreateIfNotExists = f
	mmCreateIfNotExists.mock.funcCreateIfNotExistsOrigin = minimock.CallerInfo(1)
	return mmCreateIfNotExists.mock
}

// When sets expectation for the PatchCollector.CreateIfNotExists which will trigger the result defined by the following
// Then helper
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) When(data *unstructured.Unstructured) *PatchCollectorMockCreateIfNotExistsExpectation {
	if mmCreateIfNotExists.mock.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.mock.t.Fatalf("PatchCollectorMock.CreateIfNotExists mock is already set by Set")
	}

	expectation := &PatchCollectorMockCreateIfNotExistsExpectation{
		mock:               mmCreateIfNotExists.mock,
		params:             &PatchCollectorMockCreateIfNotExistsParams{data},
		expectationOrigins: PatchCollectorMockCreateIfNotExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateIfNotExists.expectations = append(mmCreateIfNotExists.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.CreateIfNotExists return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockCreateIfNotExistsExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.CreateIfNotExists should be invoked
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Times(n uint64) *mPatchCollectorMockCreateIfNotExists {
	if n == 0 {
		mmCreateIfNotExists.mock.t.Fatalf("Times of PatchCollectorMock.CreateIfNotExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateIfNotExists.expectedInvocations, n)
	mmCreateIfNotExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateIfNotExists
}

func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) invocationsDone() bool {
	if len(mmCreateIfNotExists.expectations) == 0 && mmCreateIfNotExists.defaultExpectation == nil && mmCreateIfNotExists.mock.funcCreateIfNotExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateIfNotExists.mock.afterCreateIfNotExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateIfNotExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateIfNotExists implements mm_pkg.PatchCollector
func (mmCreateIfNotExists *PatchCollectorMock) CreateIfNotExists(data *unstructured.Unstructured) {
	mm_atomic.AddUint64(&mmCreateIfNotExists.beforeCreateIfNotExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateIfNotExists.afterCreateIfNotExistsCounter, 1)

	mmCreateIfNotExists.t.Helper()

	if mmCreateIfNotExists.inspectFuncCreateIfNotExists != nil {
		mmCreateIfNotExists.inspectFuncCreateIfNotExists(data)
	}

	mm_params := PatchCollectorMockCreateIfNotExistsParams{data}

	// Record call args
	mmCreateIfNotExists.CreateIfNotExistsMock.mutex.Lock()
	mmCreateIfNotExists.CreateIfNotExistsMock.callArgs = append(mmCreateIfNotExists.CreateIfNotExistsMock.callArgs, &mm_params)
	mmCreateIfNotExists.CreateIfNotExistsMock.mutex.Unlock()

	for _, e := range mmCreateIfNotExists.CreateIfNotExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockCreateIfNotExistsParams{data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmCreateIfNotExists.t.Errorf("PatchCollectorMock.CreateIfNotExists got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateIfNotExists.t.Errorf("PatchCollectorMock.CreateIfNotExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateIfNotExists.CreateIfNotExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCreateIfNotExists.funcCreateIfNotExists != nil {
		mmCreateIfNotExists.funcCreateIfNotExists(data)
		return
	}
	mmCreateIfNotExists.t.Fatalf("Unexpected call to PatchCollectorMock.CreateIfNotExists. %v", data)

}

// CreateIfNotExistsAfterCounter returns a count of finished PatchCollectorMock.CreateIfNotExists invocations
func (mmCreateIfNotExists *PatchCollectorMock) CreateIfNotExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateIfNotExists.afterCreateIfNotExistsCounter)
}

// CreateIfNotExistsBeforeCounter returns a count of PatchCollectorMock.CreateIfNotExists invocations
func (mmCreateIfNotExists *PatchCollectorMock) CreateIfNotExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateIfNotExists.beforeCreateIfNotExistsCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.CreateIfNotExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateIfNotExists *mPatchCollectorMockCreateIfNotExists) Calls() []*PatchCollectorMockCreateIfNotExistsParams {
	mmCreateIfNotExists.mutex.RLock()

	argCopy := make([]*PatchCollectorMockCreateIfNotExistsParams, len(mmCreateIfNotExists.callArgs))
	copy(argCopy, mmCreateIfNotExists.callArgs)

	mmCreateIfNotExists.mutex.RUnlock()

	return argCopy
}

// MinimockCreateIfNotExistsDone returns true if the count of the CreateIfNotExists invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockCreateIfNotExistsDone() bool {
	if m.CreateIfNotExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateIfNotExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateIfNotExistsMock.invocationsDone()
}

// MinimockCreateIfNotExistsInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockCreateIfNotExistsInspect() {
	for _, e := range m.CreateIfNotExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateIfNotExistsCounter := mm_atomic.LoadUint64(&m.afterCreateIfNotExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateIfNotExistsMock.defaultExpectation != nil && afterCreateIfNotExistsCounter < 1 {
		if m.CreateIfNotExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s", m.CreateIfNotExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s with params: %#v", m.CreateIfNotExistsMock.defaultExpectation.expectationOrigins.origin, *m.CreateIfNotExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateIfNotExists != nil && afterCreateIfNotExistsCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.CreateIfNotExists at\n%s", m.funcCreateIfNotExistsOrigin)
	}

	if !m.CreateIfNotExistsMock.invocationsDone() && afterCreateIfNotExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.CreateIfNotExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateIfNotExistsMock.expectedInvocations), m.CreateIfNotExistsMock.expectedInvocationsOrigin, afterCreateIfNotExistsCounter)
	}
}

type mPatchCollectorMockCreateOrUpdate struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockCreateOrUpdateExpectation
	expectations       []*PatchCollectorMockCreateOrUpdateExpectation

	callArgs []*PatchCollectorMockCreateOrUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockCreateOrUpdateExpectation specifies expectation struct of the PatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockCreateOrUpdateParams
	paramPtrs          *PatchCollectorMockCreateOrUpdateParamPtrs
	expectationOrigins PatchCollectorMockCreateOrUpdateExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockCreateOrUpdateParams contains parameters of the PatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateParams struct {
	data *unstructured.Unstructured
}

// PatchCollectorMockCreateOrUpdateParamPtrs contains pointers to parameters of the PatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateParamPtrs struct {
	data **unstructured.Unstructured
}

// PatchCollectorMockCreateOrUpdateOrigins contains origins of expectations of the PatchCollector.CreateOrUpdate
type PatchCollectorMockCreateOrUpdateExpectationOrigins struct {
	origin     string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Optional() *mPatchCollectorMockCreateOrUpdate {
	mmCreateOrUpdate.optional = true
	return mmCreateOrUpdate
}

// Expect sets up expected params for PatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Expect(data *unstructured.Unstructured) *mPatchCollectorMockCreateOrUpdate {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	if mmCreateOrUpdate.defaultExpectation == nil {
		mmCreateOrUpdate.defaultExpectation = &PatchCollectorMockCreateOrUpdateExpectation{}
	}

	if mmCreateOrUpdate.defaultExpectation.paramPtrs != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by ExpectParams functions")
	}

	mmCreateOrUpdate.defaultExpectation.params = &PatchCollectorMockCreateOrUpdateParams{data}
	mmCreateOrUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrUpdate.expectations {
		if minimock.Equal(e.params, mmCreateOrUpdate.defaultExpectation.params) {
			mmCreateOrUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrUpdate.defaultExpectation.params)
		}
	}

	return mmCreateOrUpdate
}

// ExpectDataParam1 sets up expected param data for PatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) ExpectDataParam1(data *unstructured.Unstructured) *mPatchCollectorMockCreateOrUpdate {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	if mmCreateOrUpdate.defaultExpectation == nil {
		mmCreateOrUpdate.defaultExpectation = &PatchCollectorMockCreateOrUpdateExpectation{}
	}

	if mmCreateOrUpdate.defaultExpectation.params != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Expect")
	}

	if mmCreateOrUpdate.defaultExpectation.paramPtrs == nil {
		mmCreateOrUpdate.defaultExpectation.paramPtrs = &PatchCollectorMockCreateOrUpdateParamPtrs{}
	}
	mmCreateOrUpdate.defaultExpectation.paramPtrs.data = &data
	mmCreateOrUpdate.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmCreateOrUpdate
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Inspect(f func(data *unstructured.Unstructured)) *mPatchCollectorMockCreateOrUpdate {
	if mmCreateOrUpdate.mock.inspectFuncCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.CreateOrUpdate")
	}

	mmCreateOrUpdate.mock.inspectFuncCreateOrUpdate = f

	return mmCreateOrUpdate
}

// Return sets up results that will be returned by PatchCollector.CreateOrUpdate
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Return() *PatchCollectorMock {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	if mmCreateOrUpdate.defaultExpectation == nil {
		mmCreateOrUpdate.defaultExpectation = &PatchCollectorMockCreateOrUpdateExpectation{mock: mmCreateOrUpdate.mock}
	}

	mmCreateOrUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrUpdate.mock
}

// Set uses given function f to mock the PatchCollector.CreateOrUpdate method
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Set(f func(data *unstructured.Unstructured)) *PatchCollectorMock {
	if mmCreateOrUpdate.defaultExpectation != nil {
		mmCreateOrUpdate.mock.t.Fatalf("Default expectation is already set for the PatchCollector.CreateOrUpdate method")
	}

	if len(mmCreateOrUpdate.expectations) > 0 {
		mmCreateOrUpdate.mock.t.Fatalf("Some expectations are already set for the PatchCollector.CreateOrUpdate method")
	}

	mmCreateOrUpdate.mock.funcCreateOrUpdate = f
	mmCreateOrUpdate.mock.funcCreateOrUpdateOrigin = minimock.CallerInfo(1)
	return mmCreateOrUpdate.mock
}

// When sets expectation for the PatchCollector.CreateOrUpdate which will trigger the result defined by the following
// Then helper
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) When(data *unstructured.Unstructured) *PatchCollectorMockCreateOrUpdateExpectation {
	if mmCreateOrUpdate.mock.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.mock.t.Fatalf("PatchCollectorMock.CreateOrUpdate mock is already set by Set")
	}

	expectation := &PatchCollectorMockCreateOrUpdateExpectation{
		mock:               mmCreateOrUpdate.mock,
		params:             &PatchCollectorMockCreateOrUpdateParams{data},
		expectationOrigins: PatchCollectorMockCreateOrUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrUpdate.expectations = append(mmCreateOrUpdate.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.CreateOrUpdate return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockCreateOrUpdateExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.CreateOrUpdate should be invoked
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Times(n uint64) *mPatchCollectorMockCreateOrUpdate {
	if n == 0 {
		mmCreateOrUpdate.mock.t.Fatalf("Times of PatchCollectorMock.CreateOrUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrUpdate.expectedInvocations, n)
	mmCreateOrUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrUpdate
}

func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) invocationsDone() bool {
	if len(mmCreateOrUpdate.expectations) == 0 && mmCreateOrUpdate.defaultExpectation == nil && mmCreateOrUpdate.mock.funcCreateOrUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrUpdate.mock.afterCreateOrUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrUpdate implements mm_pkg.PatchCollector
func (mmCreateOrUpdate *PatchCollectorMock) CreateOrUpdate(data *unstructured.Unstructured) {
	mm_atomic.AddUint64(&mmCreateOrUpdate.beforeCreateOrUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrUpdate.afterCreateOrUpdateCounter, 1)

	mmCreateOrUpdate.t.Helper()

	if mmCreateOrUpdate.inspectFuncCreateOrUpdate != nil {
		mmCreateOrUpdate.inspectFuncCreateOrUpdate(data)
	}

	mm_params := PatchCollectorMockCreateOrUpdateParams{data}

	// Record call args
	mmCreateOrUpdate.CreateOrUpdateMock.mutex.Lock()
	mmCreateOrUpdate.CreateOrUpdateMock.callArgs = append(mmCreateOrUpdate.CreateOrUpdateMock.callArgs, &mm_params)
	mmCreateOrUpdate.CreateOrUpdateMock.mutex.Unlock()

	for _, e := range mmCreateOrUpdate.CreateOrUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockCreateOrUpdateParams{data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmCreateOrUpdate.t.Errorf("PatchCollectorMock.CreateOrUpdate got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrUpdate.t.Errorf("PatchCollectorMock.CreateOrUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrUpdate.CreateOrUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCreateOrUpdate.funcCreateOrUpdate != nil {
		mmCreateOrUpdate.funcCreateOrUpdate(data)
		return
	}
	mmCreateOrUpdate.t.Fatalf("Unexpected call to PatchCollectorMock.CreateOrUpdate. %v", data)

}

// CreateOrUpdateAfterCounter returns a count of finished PatchCollectorMock.CreateOrUpdate invocations
func (mmCreateOrUpdate *PatchCollectorMock) CreateOrUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrUpdate.afterCreateOrUpdateCounter)
}

// CreateOrUpdateBeforeCounter returns a count of PatchCollectorMock.CreateOrUpdate invocations
func (mmCreateOrUpdate *PatchCollectorMock) CreateOrUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrUpdate.beforeCreateOrUpdateCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.CreateOrUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrUpdate *mPatchCollectorMockCreateOrUpdate) Calls() []*PatchCollectorMockCreateOrUpdateParams {
	mmCreateOrUpdate.mutex.RLock()

	argCopy := make([]*PatchCollectorMockCreateOrUpdateParams, len(mmCreateOrUpdate.callArgs))
	copy(argCopy, mmCreateOrUpdate.callArgs)

	mmCreateOrUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrUpdateDone returns true if the count of the CreateOrUpdate invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockCreateOrUpdateDone() bool {
	if m.CreateOrUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrUpdateMock.invocationsDone()
}

// MinimockCreateOrUpdateInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockCreateOrUpdateInspect() {
	for _, e := range m.CreateOrUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrUpdateCounter := mm_atomic.LoadUint64(&m.afterCreateOrUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrUpdateMock.defaultExpectation != nil && afterCreateOrUpdateCounter < 1 {
		if m.CreateOrUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s", m.CreateOrUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s with params: %#v", m.CreateOrUpdateMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrUpdate != nil && afterCreateOrUpdateCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.CreateOrUpdate at\n%s", m.funcCreateOrUpdateOrigin)
	}

	if !m.CreateOrUpdateMock.invocationsDone() && afterCreateOrUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.CreateOrUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrUpdateMock.expectedInvocations), m.CreateOrUpdateMock.expectedInvocationsOrigin, afterCreateOrUpdateCounter)
	}
}

type mPatchCollectorMockDelete struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockDeleteExpectation
	expectations       []*PatchCollectorMockDeleteExpectation

	callArgs []*PatchCollectorMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockDeleteExpectation specifies expectation struct of the PatchCollector.Delete
type PatchCollectorMockDeleteExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockDeleteParams
	paramPtrs          *PatchCollectorMockDeleteParamPtrs
	expectationOrigins PatchCollectorMockDeleteExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockDeleteParams contains parameters of the PatchCollector.Delete
type PatchCollectorMockDeleteParams struct {
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteParamPtrs contains pointers to parameters of the PatchCollector.Delete
type PatchCollectorMockDeleteParamPtrs struct {
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteOrigins contains origins of expectations of the PatchCollector.Delete
type PatchCollectorMockDeleteExpectationOrigins struct {
	origin           string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mPatchCollectorMockDelete) Optional() *mPatchCollectorMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) Expect(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectApiVersionParam1 sets up expected param apiVersion for PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectApiVersionParam1(apiVersion string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmDelete.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectKindParam2 sets up expected param kind for PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectKindParam2(kind string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.kind = &kind
	mmDelete.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectNamespaceParam3 sets up expected param namespace for PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectNamespaceParam3(namespace string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.namespace = &namespace
	mmDelete.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectNameParam4 sets up expected param name for PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectNameParam4(name string) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.name = &name
	mmDelete.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectOptsParam5 sets up expected param opts for PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) ExpectOptsParam5(opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.opts = &opts
	mmDelete.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) Inspect(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *mPatchCollectorMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by PatchCollector.Delete
func (mmDelete *mPatchCollectorMockDelete) Return() *PatchCollectorMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PatchCollectorMockDeleteExpectation{mock: mmDelete.mock}
	}

	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the PatchCollector.Delete method
func (mmDelete *mPatchCollectorMockDelete) Set(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *PatchCollectorMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the PatchCollector.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the PatchCollector.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the PatchCollector.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mPatchCollectorMockDelete) When(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *PatchCollectorMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PatchCollectorMock.Delete mock is already set by Set")
	}

	expectation := &PatchCollectorMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.Delete return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockDeleteExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.Delete should be invoked
func (mmDelete *mPatchCollectorMockDelete) Times(n uint64) *mPatchCollectorMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of PatchCollectorMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mPatchCollectorMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_pkg.PatchCollector
func (mmDelete *PatchCollectorMock) Delete(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockDeleteParams{apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("PatchCollectorMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDelete.funcDelete != nil {
		mmDelete.funcDelete(apiVersion, kind, namespace, name, opts...)
		return
	}
	mmDelete.t.Fatalf("Unexpected call to PatchCollectorMock.Delete. %v %v %v %v %v", apiVersion, kind, namespace, name, opts)

}

// DeleteAfterCounter returns a count of finished PatchCollectorMock.Delete invocations
func (mmDelete *PatchCollectorMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of PatchCollectorMock.Delete invocations
func (mmDelete *PatchCollectorMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mPatchCollectorMockDelete) Calls() []*PatchCollectorMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*PatchCollectorMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mPatchCollectorMockDeleteInBackground struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockDeleteInBackgroundExpectation
	expectations       []*PatchCollectorMockDeleteInBackgroundExpectation

	callArgs []*PatchCollectorMockDeleteInBackgroundParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockDeleteInBackgroundExpectation specifies expectation struct of the PatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockDeleteInBackgroundParams
	paramPtrs          *PatchCollectorMockDeleteInBackgroundParamPtrs
	expectationOrigins PatchCollectorMockDeleteInBackgroundExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockDeleteInBackgroundParams contains parameters of the PatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundParams struct {
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteInBackgroundParamPtrs contains pointers to parameters of the PatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundParamPtrs struct {
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteInBackgroundOrigins contains origins of expectations of the PatchCollector.DeleteInBackground
type PatchCollectorMockDeleteInBackgroundExpectationOrigins struct {
	origin           string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Optional() *mPatchCollectorMockDeleteInBackground {
	mmDeleteInBackground.optional = true
	return mmDeleteInBackground
}

// Expect sets up expected params for PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Expect(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by ExpectParams functions")
	}

	mmDeleteInBackground.defaultExpectation.params = &PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts}
	mmDeleteInBackground.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteInBackground.expectations {
		if minimock.Equal(e.params, mmDeleteInBackground.defaultExpectation.params) {
			mmDeleteInBackground.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteInBackground.defaultExpectation.params)
		}
	}

	return mmDeleteInBackground
}

// ExpectApiVersionParam1 sets up expected param apiVersion for PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectApiVersionParam1(apiVersion string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectKindParam2 sets up expected param kind for PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectKindParam2(kind string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.kind = &kind
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectNamespaceParam3 sets up expected param namespace for PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectNamespaceParam3(namespace string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.namespace = &namespace
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectNameParam4 sets up expected param name for PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectNameParam4(name string) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.name = &name
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// ExpectOptsParam5 sets up expected param opts for PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) ExpectOptsParam5(opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{}
	}

	if mmDeleteInBackground.defaultExpectation.params != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Expect")
	}

	if mmDeleteInBackground.defaultExpectation.paramPtrs == nil {
		mmDeleteInBackground.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteInBackgroundParamPtrs{}
	}
	mmDeleteInBackground.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteInBackground.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteInBackground
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Inspect(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *mPatchCollectorMockDeleteInBackground {
	if mmDeleteInBackground.mock.inspectFuncDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.DeleteInBackground")
	}

	mmDeleteInBackground.mock.inspectFuncDeleteInBackground = f

	return mmDeleteInBackground
}

// Return sets up results that will be returned by PatchCollector.DeleteInBackground
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Return() *PatchCollectorMock {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	if mmDeleteInBackground.defaultExpectation == nil {
		mmDeleteInBackground.defaultExpectation = &PatchCollectorMockDeleteInBackgroundExpectation{mock: mmDeleteInBackground.mock}
	}

	mmDeleteInBackground.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteInBackground.mock
}

// Set uses given function f to mock the PatchCollector.DeleteInBackground method
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Set(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *PatchCollectorMock {
	if mmDeleteInBackground.defaultExpectation != nil {
		mmDeleteInBackground.mock.t.Fatalf("Default expectation is already set for the PatchCollector.DeleteInBackground method")
	}

	if len(mmDeleteInBackground.expectations) > 0 {
		mmDeleteInBackground.mock.t.Fatalf("Some expectations are already set for the PatchCollector.DeleteInBackground method")
	}

	mmDeleteInBackground.mock.funcDeleteInBackground = f
	mmDeleteInBackground.mock.funcDeleteInBackgroundOrigin = minimock.CallerInfo(1)
	return mmDeleteInBackground.mock
}

// When sets expectation for the PatchCollector.DeleteInBackground which will trigger the result defined by the following
// Then helper
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) When(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *PatchCollectorMockDeleteInBackgroundExpectation {
	if mmDeleteInBackground.mock.funcDeleteInBackground != nil {
		mmDeleteInBackground.mock.t.Fatalf("PatchCollectorMock.DeleteInBackground mock is already set by Set")
	}

	expectation := &PatchCollectorMockDeleteInBackgroundExpectation{
		mock:               mmDeleteInBackground.mock,
		params:             &PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockDeleteInBackgroundExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteInBackground.expectations = append(mmDeleteInBackground.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.DeleteInBackground return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockDeleteInBackgroundExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.DeleteInBackground should be invoked
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Times(n uint64) *mPatchCollectorMockDeleteInBackground {
	if n == 0 {
		mmDeleteInBackground.mock.t.Fatalf("Times of PatchCollectorMock.DeleteInBackground mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteInBackground.expectedInvocations, n)
	mmDeleteInBackground.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteInBackground
}

func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) invocationsDone() bool {
	if len(mmDeleteInBackground.expectations) == 0 && mmDeleteInBackground.defaultExpectation == nil && mmDeleteInBackground.mock.funcDeleteInBackground == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteInBackground.mock.afterDeleteInBackgroundCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteInBackground.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteInBackground implements mm_pkg.PatchCollector
func (mmDeleteInBackground *PatchCollectorMock) DeleteInBackground(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) {
	mm_atomic.AddUint64(&mmDeleteInBackground.beforeDeleteInBackgroundCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteInBackground.afterDeleteInBackgroundCounter, 1)

	mmDeleteInBackground.t.Helper()

	if mmDeleteInBackground.inspectFuncDeleteInBackground != nil {
		mmDeleteInBackground.inspectFuncDeleteInBackground(apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts}

	// Record call args
	mmDeleteInBackground.DeleteInBackgroundMock.mutex.Lock()
	mmDeleteInBackground.DeleteInBackgroundMock.callArgs = append(mmDeleteInBackground.DeleteInBackgroundMock.callArgs, &mm_params)
	mmDeleteInBackground.DeleteInBackgroundMock.mutex.Unlock()

	for _, e := range mmDeleteInBackground.DeleteInBackgroundMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockDeleteInBackgroundParams{apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteInBackground.t.Errorf("PatchCollectorMock.DeleteInBackground got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteInBackground.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteInBackground.funcDeleteInBackground != nil {
		mmDeleteInBackground.funcDeleteInBackground(apiVersion, kind, namespace, name, opts...)
		return
	}
	mmDeleteInBackground.t.Fatalf("Unexpected call to PatchCollectorMock.DeleteInBackground. %v %v %v %v %v", apiVersion, kind, namespace, name, opts)

}

// DeleteInBackgroundAfterCounter returns a count of finished PatchCollectorMock.DeleteInBackground invocations
func (mmDeleteInBackground *PatchCollectorMock) DeleteInBackgroundAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteInBackground.afterDeleteInBackgroundCounter)
}

// DeleteInBackgroundBeforeCounter returns a count of PatchCollectorMock.DeleteInBackground invocations
func (mmDeleteInBackground *PatchCollectorMock) DeleteInBackgroundBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteInBackground.beforeDeleteInBackgroundCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.DeleteInBackground.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteInBackground *mPatchCollectorMockDeleteInBackground) Calls() []*PatchCollectorMockDeleteInBackgroundParams {
	mmDeleteInBackground.mutex.RLock()

	argCopy := make([]*PatchCollectorMockDeleteInBackgroundParams, len(mmDeleteInBackground.callArgs))
	copy(argCopy, mmDeleteInBackground.callArgs)

	mmDeleteInBackground.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteInBackgroundDone returns true if the count of the DeleteInBackground invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockDeleteInBackgroundDone() bool {
	if m.DeleteInBackgroundMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteInBackgroundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteInBackgroundMock.invocationsDone()
}

// MinimockDeleteInBackgroundInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockDeleteInBackgroundInspect() {
	for _, e := range m.DeleteInBackgroundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteInBackgroundCounter := mm_atomic.LoadUint64(&m.afterDeleteInBackgroundCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteInBackgroundMock.defaultExpectation != nil && afterDeleteInBackgroundCounter < 1 {
		if m.DeleteInBackgroundMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s", m.DeleteInBackgroundMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s with params: %#v", m.DeleteInBackgroundMock.defaultExpectation.expectationOrigins.origin, *m.DeleteInBackgroundMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteInBackground != nil && afterDeleteInBackgroundCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.DeleteInBackground at\n%s", m.funcDeleteInBackgroundOrigin)
	}

	if !m.DeleteInBackgroundMock.invocationsDone() && afterDeleteInBackgroundCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.DeleteInBackground at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteInBackgroundMock.expectedInvocations), m.DeleteInBackgroundMock.expectedInvocationsOrigin, afterDeleteInBackgroundCounter)
	}
}

type mPatchCollectorMockDeleteNonCascading struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockDeleteNonCascadingExpectation
	expectations       []*PatchCollectorMockDeleteNonCascadingExpectation

	callArgs []*PatchCollectorMockDeleteNonCascadingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockDeleteNonCascadingExpectation specifies expectation struct of the PatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockDeleteNonCascadingParams
	paramPtrs          *PatchCollectorMockDeleteNonCascadingParamPtrs
	expectationOrigins PatchCollectorMockDeleteNonCascadingExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockDeleteNonCascadingParams contains parameters of the PatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingParams struct {
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteNonCascadingParamPtrs contains pointers to parameters of the PatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingParamPtrs struct {
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorDeleteOption
}

// PatchCollectorMockDeleteNonCascadingOrigins contains origins of expectations of the PatchCollector.DeleteNonCascading
type PatchCollectorMockDeleteNonCascadingExpectationOrigins struct {
	origin           string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Optional() *mPatchCollectorMockDeleteNonCascading {
	mmDeleteNonCascading.optional = true
	return mmDeleteNonCascading
}

// Expect sets up expected params for PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Expect(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by ExpectParams functions")
	}

	mmDeleteNonCascading.defaultExpectation.params = &PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts}
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNonCascading.expectations {
		if minimock.Equal(e.params, mmDeleteNonCascading.defaultExpectation.params) {
			mmDeleteNonCascading.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNonCascading.defaultExpectation.params)
		}
	}

	return mmDeleteNonCascading
}

// ExpectApiVersionParam1 sets up expected param apiVersion for PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectApiVersionParam1(apiVersion string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectKindParam2 sets up expected param kind for PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectKindParam2(kind string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.kind = &kind
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectNamespaceParam3 sets up expected param namespace for PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectNamespaceParam3(namespace string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.namespace = &namespace
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectNameParam4 sets up expected param name for PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectNameParam4(name string) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.name = &name
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// ExpectOptsParam5 sets up expected param opts for PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) ExpectOptsParam5(opts ...mm_pkg.PatchCollectorDeleteOption) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{}
	}

	if mmDeleteNonCascading.defaultExpectation.params != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Expect")
	}

	if mmDeleteNonCascading.defaultExpectation.paramPtrs == nil {
		mmDeleteNonCascading.defaultExpectation.paramPtrs = &PatchCollectorMockDeleteNonCascadingParamPtrs{}
	}
	mmDeleteNonCascading.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteNonCascading.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteNonCascading
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Inspect(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *mPatchCollectorMockDeleteNonCascading {
	if mmDeleteNonCascading.mock.inspectFuncDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.DeleteNonCascading")
	}

	mmDeleteNonCascading.mock.inspectFuncDeleteNonCascading = f

	return mmDeleteNonCascading
}

// Return sets up results that will be returned by PatchCollector.DeleteNonCascading
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Return() *PatchCollectorMock {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	if mmDeleteNonCascading.defaultExpectation == nil {
		mmDeleteNonCascading.defaultExpectation = &PatchCollectorMockDeleteNonCascadingExpectation{mock: mmDeleteNonCascading.mock}
	}

	mmDeleteNonCascading.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNonCascading.mock
}

// Set uses given function f to mock the PatchCollector.DeleteNonCascading method
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Set(f func(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption)) *PatchCollectorMock {
	if mmDeleteNonCascading.defaultExpectation != nil {
		mmDeleteNonCascading.mock.t.Fatalf("Default expectation is already set for the PatchCollector.DeleteNonCascading method")
	}

	if len(mmDeleteNonCascading.expectations) > 0 {
		mmDeleteNonCascading.mock.t.Fatalf("Some expectations are already set for the PatchCollector.DeleteNonCascading method")
	}

	mmDeleteNonCascading.mock.funcDeleteNonCascading = f
	mmDeleteNonCascading.mock.funcDeleteNonCascadingOrigin = minimock.CallerInfo(1)
	return mmDeleteNonCascading.mock
}

// When sets expectation for the PatchCollector.DeleteNonCascading which will trigger the result defined by the following
// Then helper
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) When(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) *PatchCollectorMockDeleteNonCascadingExpectation {
	if mmDeleteNonCascading.mock.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.mock.t.Fatalf("PatchCollectorMock.DeleteNonCascading mock is already set by Set")
	}

	expectation := &PatchCollectorMockDeleteNonCascadingExpectation{
		mock:               mmDeleteNonCascading.mock,
		params:             &PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockDeleteNonCascadingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNonCascading.expectations = append(mmDeleteNonCascading.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.DeleteNonCascading return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockDeleteNonCascadingExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.DeleteNonCascading should be invoked
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Times(n uint64) *mPatchCollectorMockDeleteNonCascading {
	if n == 0 {
		mmDeleteNonCascading.mock.t.Fatalf("Times of PatchCollectorMock.DeleteNonCascading mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNonCascading.expectedInvocations, n)
	mmDeleteNonCascading.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNonCascading
}

func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) invocationsDone() bool {
	if len(mmDeleteNonCascading.expectations) == 0 && mmDeleteNonCascading.defaultExpectation == nil && mmDeleteNonCascading.mock.funcDeleteNonCascading == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNonCascading.mock.afterDeleteNonCascadingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNonCascading.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNonCascading implements mm_pkg.PatchCollector
func (mmDeleteNonCascading *PatchCollectorMock) DeleteNonCascading(apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorDeleteOption) {
	mm_atomic.AddUint64(&mmDeleteNonCascading.beforeDeleteNonCascadingCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNonCascading.afterDeleteNonCascadingCounter, 1)

	mmDeleteNonCascading.t.Helper()

	if mmDeleteNonCascading.inspectFuncDeleteNonCascading != nil {
		mmDeleteNonCascading.inspectFuncDeleteNonCascading(apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts}

	// Record call args
	mmDeleteNonCascading.DeleteNonCascadingMock.mutex.Lock()
	mmDeleteNonCascading.DeleteNonCascadingMock.callArgs = append(mmDeleteNonCascading.DeleteNonCascadingMock.callArgs, &mm_params)
	mmDeleteNonCascading.DeleteNonCascadingMock.mutex.Unlock()

	for _, e := range mmDeleteNonCascading.DeleteNonCascadingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockDeleteNonCascadingParams{apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNonCascading.t.Errorf("PatchCollectorMock.DeleteNonCascading got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNonCascading.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteNonCascading.funcDeleteNonCascading != nil {
		mmDeleteNonCascading.funcDeleteNonCascading(apiVersion, kind, namespace, name, opts...)
		return
	}
	mmDeleteNonCascading.t.Fatalf("Unexpected call to PatchCollectorMock.DeleteNonCascading. %v %v %v %v %v", apiVersion, kind, namespace, name, opts)

}

// DeleteNonCascadingAfterCounter returns a count of finished PatchCollectorMock.DeleteNonCascading invocations
func (mmDeleteNonCascading *PatchCollectorMock) DeleteNonCascadingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNonCascading.afterDeleteNonCascadingCounter)
}

// DeleteNonCascadingBeforeCounter returns a count of PatchCollectorMock.DeleteNonCascading invocations
func (mmDeleteNonCascading *PatchCollectorMock) DeleteNonCascadingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNonCascading.beforeDeleteNonCascadingCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.DeleteNonCascading.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNonCascading *mPatchCollectorMockDeleteNonCascading) Calls() []*PatchCollectorMockDeleteNonCascadingParams {
	mmDeleteNonCascading.mutex.RLock()

	argCopy := make([]*PatchCollectorMockDeleteNonCascadingParams, len(mmDeleteNonCascading.callArgs))
	copy(argCopy, mmDeleteNonCascading.callArgs)

	mmDeleteNonCascading.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNonCascadingDone returns true if the count of the DeleteNonCascading invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockDeleteNonCascadingDone() bool {
	if m.DeleteNonCascadingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNonCascadingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNonCascadingMock.invocationsDone()
}

// MinimockDeleteNonCascadingInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockDeleteNonCascadingInspect() {
	for _, e := range m.DeleteNonCascadingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNonCascadingCounter := mm_atomic.LoadUint64(&m.afterDeleteNonCascadingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNonCascadingMock.defaultExpectation != nil && afterDeleteNonCascadingCounter < 1 {
		if m.DeleteNonCascadingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s", m.DeleteNonCascadingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s with params: %#v", m.DeleteNonCascadingMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNonCascadingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNonCascading != nil && afterDeleteNonCascadingCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.DeleteNonCascading at\n%s", m.funcDeleteNonCascadingOrigin)
	}

	if !m.DeleteNonCascadingMock.invocationsDone() && afterDeleteNonCascadingCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.DeleteNonCascading at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNonCascadingMock.expectedInvocations), m.DeleteNonCascadingMock.expectedInvocationsOrigin, afterDeleteNonCascadingCounter)
	}
}

type mPatchCollectorMockJQPatch struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockJQPatchExpectation
	expectations       []*PatchCollectorMockJQPatchExpectation

	callArgs []*PatchCollectorMockJQPatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockJQPatchExpectation specifies expectation struct of the PatchCollector.JQPatch
type PatchCollectorMockJQPatchExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockJQPatchParams
	paramPtrs          *PatchCollectorMockJQPatchParamPtrs
	expectationOrigins PatchCollectorMockJQPatchExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockJQPatchParams contains parameters of the PatchCollector.JQPatch
type PatchCollectorMockJQPatchParams struct {
	filter     string
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorPatchOption
}

// PatchCollectorMockJQPatchParamPtrs contains pointers to parameters of the PatchCollector.JQPatch
type PatchCollectorMockJQPatchParamPtrs struct {
	filter     *string
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorPatchOption
}

// PatchCollectorMockJQPatchOrigins contains origins of expectations of the PatchCollector.JQPatch
type PatchCollectorMockJQPatchExpectationOrigins struct {
	origin           string
	originFilter     string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmJQPatch *mPatchCollectorMockJQPatch) Optional() *mPatchCollectorMockJQPatch {
	mmJQPatch.optional = true
	return mmJQPatch
}

// Expect sets up expected params for PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) Expect(filter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{}
	}

	if mmJQPatch.defaultExpectation.paramPtrs != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by ExpectParams functions")
	}

	mmJQPatch.defaultExpectation.params = &PatchCollectorMockJQPatchParams{filter, apiVersion, kind, namespace, name, opts}
	mmJQPatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmJQPatch.expectations {
		if minimock.Equal(e.params, mmJQPatch.defaultExpectation.params) {
			mmJQPatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJQPatch.defaultExpectation.params)
		}
	}

	return mmJQPatch
}

// ExpectFilterParam1 sets up expected param filter for PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) ExpectFilterParam1(filter string) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{}
	}

	if mmJQPatch.defaultExpectation.params != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Expect")
	}

	if mmJQPatch.defaultExpectation.paramPtrs == nil {
		mmJQPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJQPatchParamPtrs{}
	}
	mmJQPatch.defaultExpectation.paramPtrs.filter = &filter
	mmJQPatch.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmJQPatch
}

// ExpectApiVersionParam2 sets up expected param apiVersion for PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) ExpectApiVersionParam2(apiVersion string) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{}
	}

	if mmJQPatch.defaultExpectation.params != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Expect")
	}

	if mmJQPatch.defaultExpectation.paramPtrs == nil {
		mmJQPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJQPatchParamPtrs{}
	}
	mmJQPatch.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmJQPatch.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmJQPatch
}

// ExpectKindParam3 sets up expected param kind for PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) ExpectKindParam3(kind string) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{}
	}

	if mmJQPatch.defaultExpectation.params != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Expect")
	}

	if mmJQPatch.defaultExpectation.paramPtrs == nil {
		mmJQPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJQPatchParamPtrs{}
	}
	mmJQPatch.defaultExpectation.paramPtrs.kind = &kind
	mmJQPatch.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmJQPatch
}

// ExpectNamespaceParam4 sets up expected param namespace for PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) ExpectNamespaceParam4(namespace string) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{}
	}

	if mmJQPatch.defaultExpectation.params != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Expect")
	}

	if mmJQPatch.defaultExpectation.paramPtrs == nil {
		mmJQPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJQPatchParamPtrs{}
	}
	mmJQPatch.defaultExpectation.paramPtrs.namespace = &namespace
	mmJQPatch.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmJQPatch
}

// ExpectNameParam5 sets up expected param name for PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) ExpectNameParam5(name string) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{}
	}

	if mmJQPatch.defaultExpectation.params != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Expect")
	}

	if mmJQPatch.defaultExpectation.paramPtrs == nil {
		mmJQPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJQPatchParamPtrs{}
	}
	mmJQPatch.defaultExpectation.paramPtrs.name = &name
	mmJQPatch.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmJQPatch
}

// ExpectOptsParam6 sets up expected param opts for PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) ExpectOptsParam6(opts ...mm_pkg.PatchCollectorPatchOption) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{}
	}

	if mmJQPatch.defaultExpectation.params != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Expect")
	}

	if mmJQPatch.defaultExpectation.paramPtrs == nil {
		mmJQPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJQPatchParamPtrs{}
	}
	mmJQPatch.defaultExpectation.paramPtrs.opts = &opts
	mmJQPatch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmJQPatch
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) Inspect(f func(filter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)) *mPatchCollectorMockJQPatch {
	if mmJQPatch.mock.inspectFuncJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.JQPatch")
	}

	mmJQPatch.mock.inspectFuncJQPatch = f

	return mmJQPatch
}

// Return sets up results that will be returned by PatchCollector.JQPatch
func (mmJQPatch *mPatchCollectorMockJQPatch) Return() *PatchCollectorMock {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	if mmJQPatch.defaultExpectation == nil {
		mmJQPatch.defaultExpectation = &PatchCollectorMockJQPatchExpectation{mock: mmJQPatch.mock}
	}

	mmJQPatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmJQPatch.mock
}

// Set uses given function f to mock the PatchCollector.JQPatch method
func (mmJQPatch *mPatchCollectorMockJQPatch) Set(f func(filter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)) *PatchCollectorMock {
	if mmJQPatch.defaultExpectation != nil {
		mmJQPatch.mock.t.Fatalf("Default expectation is already set for the PatchCollector.JQPatch method")
	}

	if len(mmJQPatch.expectations) > 0 {
		mmJQPatch.mock.t.Fatalf("Some expectations are already set for the PatchCollector.JQPatch method")
	}

	mmJQPatch.mock.funcJQPatch = f
	mmJQPatch.mock.funcJQPatchOrigin = minimock.CallerInfo(1)
	return mmJQPatch.mock
}

// When sets expectation for the PatchCollector.JQPatch which will trigger the result defined by the following
// Then helper
func (mmJQPatch *mPatchCollectorMockJQPatch) When(filter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) *PatchCollectorMockJQPatchExpectation {
	if mmJQPatch.mock.funcJQPatch != nil {
		mmJQPatch.mock.t.Fatalf("PatchCollectorMock.JQPatch mock is already set by Set")
	}

	expectation := &PatchCollectorMockJQPatchExpectation{
		mock:               mmJQPatch.mock,
		params:             &PatchCollectorMockJQPatchParams{filter, apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockJQPatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmJQPatch.expectations = append(mmJQPatch.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.JQPatch return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockJQPatchExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.JQPatch should be invoked
func (mmJQPatch *mPatchCollectorMockJQPatch) Times(n uint64) *mPatchCollectorMockJQPatch {
	if n == 0 {
		mmJQPatch.mock.t.Fatalf("Times of PatchCollectorMock.JQPatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmJQPatch.expectedInvocations, n)
	mmJQPatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmJQPatch
}

func (mmJQPatch *mPatchCollectorMockJQPatch) invocationsDone() bool {
	if len(mmJQPatch.expectations) == 0 && mmJQPatch.defaultExpectation == nil && mmJQPatch.mock.funcJQPatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmJQPatch.mock.afterJQPatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmJQPatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// JQPatch implements mm_pkg.PatchCollector
func (mmJQPatch *PatchCollectorMock) JQPatch(filter string, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) {
	mm_atomic.AddUint64(&mmJQPatch.beforeJQPatchCounter, 1)
	defer mm_atomic.AddUint64(&mmJQPatch.afterJQPatchCounter, 1)

	mmJQPatch.t.Helper()

	if mmJQPatch.inspectFuncJQPatch != nil {
		mmJQPatch.inspectFuncJQPatch(filter, apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockJQPatchParams{filter, apiVersion, kind, namespace, name, opts}

	// Record call args
	mmJQPatch.JQPatchMock.mutex.Lock()
	mmJQPatch.JQPatchMock.callArgs = append(mmJQPatch.JQPatchMock.callArgs, &mm_params)
	mmJQPatch.JQPatchMock.mutex.Unlock()

	for _, e := range mmJQPatch.JQPatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmJQPatch.JQPatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJQPatch.JQPatchMock.defaultExpectation.Counter, 1)
		mm_want := mmJQPatch.JQPatchMock.defaultExpectation.params
		mm_want_ptrs := mmJQPatch.JQPatchMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockJQPatchParams{filter, apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmJQPatch.t.Errorf("PatchCollectorMock.JQPatch got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQPatch.JQPatchMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmJQPatch.t.Errorf("PatchCollectorMock.JQPatch got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQPatch.JQPatchMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmJQPatch.t.Errorf("PatchCollectorMock.JQPatch got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQPatch.JQPatchMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmJQPatch.t.Errorf("PatchCollectorMock.JQPatch got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQPatch.JQPatchMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmJQPatch.t.Errorf("PatchCollectorMock.JQPatch got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQPatch.JQPatchMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmJQPatch.t.Errorf("PatchCollectorMock.JQPatch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJQPatch.JQPatchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJQPatch.t.Errorf("PatchCollectorMock.JQPatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmJQPatch.JQPatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmJQPatch.funcJQPatch != nil {
		mmJQPatch.funcJQPatch(filter, apiVersion, kind, namespace, name, opts...)
		return
	}
	mmJQPatch.t.Fatalf("Unexpected call to PatchCollectorMock.JQPatch. %v %v %v %v %v %v", filter, apiVersion, kind, namespace, name, opts)

}

// JQPatchAfterCounter returns a count of finished PatchCollectorMock.JQPatch invocations
func (mmJQPatch *PatchCollectorMock) JQPatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJQPatch.afterJQPatchCounter)
}

// JQPatchBeforeCounter returns a count of PatchCollectorMock.JQPatch invocations
func (mmJQPatch *PatchCollectorMock) JQPatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJQPatch.beforeJQPatchCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.JQPatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJQPatch *mPatchCollectorMockJQPatch) Calls() []*PatchCollectorMockJQPatchParams {
	mmJQPatch.mutex.RLock()

	argCopy := make([]*PatchCollectorMockJQPatchParams, len(mmJQPatch.callArgs))
	copy(argCopy, mmJQPatch.callArgs)

	mmJQPatch.mutex.RUnlock()

	return argCopy
}

// MinimockJQPatchDone returns true if the count of the JQPatch invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockJQPatchDone() bool {
	if m.JQPatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.JQPatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.JQPatchMock.invocationsDone()
}

// MinimockJQPatchInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockJQPatchInspect() {
	for _, e := range m.JQPatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.JQPatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterJQPatchCounter := mm_atomic.LoadUint64(&m.afterJQPatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.JQPatchMock.defaultExpectation != nil && afterJQPatchCounter < 1 {
		if m.JQPatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.JQPatch at\n%s", m.JQPatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.JQPatch at\n%s with params: %#v", m.JQPatchMock.defaultExpectation.expectationOrigins.origin, *m.JQPatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJQPatch != nil && afterJQPatchCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.JQPatch at\n%s", m.funcJQPatchOrigin)
	}

	if !m.JQPatchMock.invocationsDone() && afterJQPatchCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.JQPatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.JQPatchMock.expectedInvocations), m.JQPatchMock.expectedInvocationsOrigin, afterJQPatchCounter)
	}
}

type mPatchCollectorMockJSONPatch struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockJSONPatchExpectation
	expectations       []*PatchCollectorMockJSONPatchExpectation

	callArgs []*PatchCollectorMockJSONPatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockJSONPatchExpectation specifies expectation struct of the PatchCollector.JSONPatch
type PatchCollectorMockJSONPatchExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockJSONPatchParams
	paramPtrs          *PatchCollectorMockJSONPatchParamPtrs
	expectationOrigins PatchCollectorMockJSONPatchExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockJSONPatchParams contains parameters of the PatchCollector.JSONPatch
type PatchCollectorMockJSONPatchParams struct {
	patch      []any
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorPatchOption
}

// PatchCollectorMockJSONPatchParamPtrs contains pointers to parameters of the PatchCollector.JSONPatch
type PatchCollectorMockJSONPatchParamPtrs struct {
	patch      *[]any
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorPatchOption
}

// PatchCollectorMockJSONPatchOrigins contains origins of expectations of the PatchCollector.JSONPatch
type PatchCollectorMockJSONPatchExpectationOrigins struct {
	origin           string
	originPatch      string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Optional() *mPatchCollectorMockJSONPatch {
	mmJSONPatch.optional = true
	return mmJSONPatch
}

// Expect sets up expected params for PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Expect(patch []any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.paramPtrs != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by ExpectParams functions")
	}

	mmJSONPatch.defaultExpectation.params = &PatchCollectorMockJSONPatchParams{patch, apiVersion, kind, namespace, name, opts}
	mmJSONPatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmJSONPatch.expectations {
		if minimock.Equal(e.params, mmJSONPatch.defaultExpectation.params) {
			mmJSONPatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJSONPatch.defaultExpectation.params)
		}
	}

	return mmJSONPatch
}

// ExpectPatchParam1 sets up expected param patch for PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectPatchParam1(patch []any) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.patch = &patch
	mmJSONPatch.defaultExpectation.expectationOrigins.originPatch = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectApiVersionParam2 sets up expected param apiVersion for PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectApiVersionParam2(apiVersion string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmJSONPatch.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectKindParam3 sets up expected param kind for PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectKindParam3(kind string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.kind = &kind
	mmJSONPatch.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectNamespaceParam4 sets up expected param namespace for PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectNamespaceParam4(namespace string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.namespace = &namespace
	mmJSONPatch.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectNameParam5 sets up expected param name for PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectNameParam5(name string) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.name = &name
	mmJSONPatch.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmJSONPatch
}

// ExpectOptsParam6 sets up expected param opts for PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) ExpectOptsParam6(opts ...mm_pkg.PatchCollectorPatchOption) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{}
	}

	if mmJSONPatch.defaultExpectation.params != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Expect")
	}

	if mmJSONPatch.defaultExpectation.paramPtrs == nil {
		mmJSONPatch.defaultExpectation.paramPtrs = &PatchCollectorMockJSONPatchParamPtrs{}
	}
	mmJSONPatch.defaultExpectation.paramPtrs.opts = &opts
	mmJSONPatch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmJSONPatch
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Inspect(f func(patch []any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)) *mPatchCollectorMockJSONPatch {
	if mmJSONPatch.mock.inspectFuncJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.JSONPatch")
	}

	mmJSONPatch.mock.inspectFuncJSONPatch = f

	return mmJSONPatch
}

// Return sets up results that will be returned by PatchCollector.JSONPatch
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Return() *PatchCollectorMock {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	if mmJSONPatch.defaultExpectation == nil {
		mmJSONPatch.defaultExpectation = &PatchCollectorMockJSONPatchExpectation{mock: mmJSONPatch.mock}
	}

	mmJSONPatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmJSONPatch.mock
}

// Set uses given function f to mock the PatchCollector.JSONPatch method
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Set(f func(patch []any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)) *PatchCollectorMock {
	if mmJSONPatch.defaultExpectation != nil {
		mmJSONPatch.mock.t.Fatalf("Default expectation is already set for the PatchCollector.JSONPatch method")
	}

	if len(mmJSONPatch.expectations) > 0 {
		mmJSONPatch.mock.t.Fatalf("Some expectations are already set for the PatchCollector.JSONPatch method")
	}

	mmJSONPatch.mock.funcJSONPatch = f
	mmJSONPatch.mock.funcJSONPatchOrigin = minimock.CallerInfo(1)
	return mmJSONPatch.mock
}

// When sets expectation for the PatchCollector.JSONPatch which will trigger the result defined by the following
// Then helper
func (mmJSONPatch *mPatchCollectorMockJSONPatch) When(patch []any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) *PatchCollectorMockJSONPatchExpectation {
	if mmJSONPatch.mock.funcJSONPatch != nil {
		mmJSONPatch.mock.t.Fatalf("PatchCollectorMock.JSONPatch mock is already set by Set")
	}

	expectation := &PatchCollectorMockJSONPatchExpectation{
		mock:               mmJSONPatch.mock,
		params:             &PatchCollectorMockJSONPatchParams{patch, apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockJSONPatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmJSONPatch.expectations = append(mmJSONPatch.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.JSONPatch return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockJSONPatchExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.JSONPatch should be invoked
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Times(n uint64) *mPatchCollectorMockJSONPatch {
	if n == 0 {
		mmJSONPatch.mock.t.Fatalf("Times of PatchCollectorMock.JSONPatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmJSONPatch.expectedInvocations, n)
	mmJSONPatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmJSONPatch
}

func (mmJSONPatch *mPatchCollectorMockJSONPatch) invocationsDone() bool {
	if len(mmJSONPatch.expectations) == 0 && mmJSONPatch.defaultExpectation == nil && mmJSONPatch.mock.funcJSONPatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmJSONPatch.mock.afterJSONPatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmJSONPatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// JSONPatch implements mm_pkg.PatchCollector
func (mmJSONPatch *PatchCollectorMock) JSONPatch(patch []any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) {
	mm_atomic.AddUint64(&mmJSONPatch.beforeJSONPatchCounter, 1)
	defer mm_atomic.AddUint64(&mmJSONPatch.afterJSONPatchCounter, 1)

	mmJSONPatch.t.Helper()

	if mmJSONPatch.inspectFuncJSONPatch != nil {
		mmJSONPatch.inspectFuncJSONPatch(patch, apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockJSONPatchParams{patch, apiVersion, kind, namespace, name, opts}

	// Record call args
	mmJSONPatch.JSONPatchMock.mutex.Lock()
	mmJSONPatch.JSONPatchMock.callArgs = append(mmJSONPatch.JSONPatchMock.callArgs, &mm_params)
	mmJSONPatch.JSONPatchMock.mutex.Unlock()

	for _, e := range mmJSONPatch.JSONPatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmJSONPatch.JSONPatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJSONPatch.JSONPatchMock.defaultExpectation.Counter, 1)
		mm_want := mmJSONPatch.JSONPatchMock.defaultExpectation.params
		mm_want_ptrs := mmJSONPatch.JSONPatchMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockJSONPatchParams{patch, apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.patch != nil && !minimock.Equal(*mm_want_ptrs.patch, mm_got.patch) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter patch, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originPatch, *mm_want_ptrs.patch, mm_got.patch, minimock.Diff(*mm_want_ptrs.patch, mm_got.patch))
			}

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJSONPatch.t.Errorf("PatchCollectorMock.JSONPatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmJSONPatch.JSONPatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmJSONPatch.funcJSONPatch != nil {
		mmJSONPatch.funcJSONPatch(patch, apiVersion, kind, namespace, name, opts...)
		return
	}
	mmJSONPatch.t.Fatalf("Unexpected call to PatchCollectorMock.JSONPatch. %v %v %v %v %v %v", patch, apiVersion, kind, namespace, name, opts)

}

// JSONPatchAfterCounter returns a count of finished PatchCollectorMock.JSONPatch invocations
func (mmJSONPatch *PatchCollectorMock) JSONPatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJSONPatch.afterJSONPatchCounter)
}

// JSONPatchBeforeCounter returns a count of PatchCollectorMock.JSONPatch invocations
func (mmJSONPatch *PatchCollectorMock) JSONPatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJSONPatch.beforeJSONPatchCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.JSONPatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJSONPatch *mPatchCollectorMockJSONPatch) Calls() []*PatchCollectorMockJSONPatchParams {
	mmJSONPatch.mutex.RLock()

	argCopy := make([]*PatchCollectorMockJSONPatchParams, len(mmJSONPatch.callArgs))
	copy(argCopy, mmJSONPatch.callArgs)

	mmJSONPatch.mutex.RUnlock()

	return argCopy
}

// MinimockJSONPatchDone returns true if the count of the JSONPatch invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockJSONPatchDone() bool {
	if m.JSONPatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.JSONPatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.JSONPatchMock.invocationsDone()
}

// MinimockJSONPatchInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockJSONPatchInspect() {
	for _, e := range m.JSONPatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterJSONPatchCounter := mm_atomic.LoadUint64(&m.afterJSONPatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.JSONPatchMock.defaultExpectation != nil && afterJSONPatchCounter < 1 {
		if m.JSONPatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s", m.JSONPatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s with params: %#v", m.JSONPatchMock.defaultExpectation.expectationOrigins.origin, *m.JSONPatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJSONPatch != nil && afterJSONPatchCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.JSONPatch at\n%s", m.funcJSONPatchOrigin)
	}

	if !m.JSONPatchMock.invocationsDone() && afterJSONPatchCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.JSONPatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.JSONPatchMock.expectedInvocations), m.JSONPatchMock.expectedInvocationsOrigin, afterJSONPatchCounter)
	}
}

type mPatchCollectorMockMergePatch struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockMergePatchExpectation
	expectations       []*PatchCollectorMockMergePatchExpectation

	callArgs []*PatchCollectorMockMergePatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockMergePatchExpectation specifies expectation struct of the PatchCollector.MergePatch
type PatchCollectorMockMergePatchExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockMergePatchParams
	paramPtrs          *PatchCollectorMockMergePatchParamPtrs
	expectationOrigins PatchCollectorMockMergePatchExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchCollectorMockMergePatchParams contains parameters of the PatchCollector.MergePatch
type PatchCollectorMockMergePatchParams struct {
	patch      any
	apiVersion string
	kind       string
	namespace  string
	name       string
	opts       []mm_pkg.PatchCollectorPatchOption
}

// PatchCollectorMockMergePatchParamPtrs contains pointers to parameters of the PatchCollector.MergePatch
type PatchCollectorMockMergePatchParamPtrs struct {
	patch      *any
	apiVersion *string
	kind       *string
	namespace  *string
	name       *string
	opts       *[]mm_pkg.PatchCollectorPatchOption
}

// PatchCollectorMockMergePatchOrigins contains origins of expectations of the PatchCollector.MergePatch
type PatchCollectorMockMergePatchExpectationOrigins struct {
	origin           string
	originPatch      string
	originApiVersion string
	originKind       string
	originNamespace  string
	originName       string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMergePatch *mPatchCollectorMockMergePatch) Optional() *mPatchCollectorMockMergePatch {
	mmMergePatch.optional = true
	return mmMergePatch
}

// Expect sets up expected params for PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) Expect(patch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.paramPtrs != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by ExpectParams functions")
	}

	mmMergePatch.defaultExpectation.params = &PatchCollectorMockMergePatchParams{patch, apiVersion, kind, namespace, name, opts}
	mmMergePatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMergePatch.expectations {
		if minimock.Equal(e.params, mmMergePatch.defaultExpectation.params) {
			mmMergePatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMergePatch.defaultExpectation.params)
		}
	}

	return mmMergePatch
}

// ExpectPatchParam1 sets up expected param patch for PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectPatchParam1(patch any) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.patch = &patch
	mmMergePatch.defaultExpectation.expectationOrigins.originPatch = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectApiVersionParam2 sets up expected param apiVersion for PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectApiVersionParam2(apiVersion string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.apiVersion = &apiVersion
	mmMergePatch.defaultExpectation.expectationOrigins.originApiVersion = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectKindParam3 sets up expected param kind for PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectKindParam3(kind string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.kind = &kind
	mmMergePatch.defaultExpectation.expectationOrigins.originKind = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectNamespaceParam4 sets up expected param namespace for PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectNamespaceParam4(namespace string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.namespace = &namespace
	mmMergePatch.defaultExpectation.expectationOrigins.originNamespace = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectNameParam5 sets up expected param name for PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectNameParam5(name string) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.name = &name
	mmMergePatch.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmMergePatch
}

// ExpectOptsParam6 sets up expected param opts for PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) ExpectOptsParam6(opts ...mm_pkg.PatchCollectorPatchOption) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{}
	}

	if mmMergePatch.defaultExpectation.params != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Expect")
	}

	if mmMergePatch.defaultExpectation.paramPtrs == nil {
		mmMergePatch.defaultExpectation.paramPtrs = &PatchCollectorMockMergePatchParamPtrs{}
	}
	mmMergePatch.defaultExpectation.paramPtrs.opts = &opts
	mmMergePatch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmMergePatch
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) Inspect(f func(patch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)) *mPatchCollectorMockMergePatch {
	if mmMergePatch.mock.inspectFuncMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.MergePatch")
	}

	mmMergePatch.mock.inspectFuncMergePatch = f

	return mmMergePatch
}

// Return sets up results that will be returned by PatchCollector.MergePatch
func (mmMergePatch *mPatchCollectorMockMergePatch) Return() *PatchCollectorMock {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	if mmMergePatch.defaultExpectation == nil {
		mmMergePatch.defaultExpectation = &PatchCollectorMockMergePatchExpectation{mock: mmMergePatch.mock}
	}

	mmMergePatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMergePatch.mock
}

// Set uses given function f to mock the PatchCollector.MergePatch method
func (mmMergePatch *mPatchCollectorMockMergePatch) Set(f func(patch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption)) *PatchCollectorMock {
	if mmMergePatch.defaultExpectation != nil {
		mmMergePatch.mock.t.Fatalf("Default expectation is already set for the PatchCollector.MergePatch method")
	}

	if len(mmMergePatch.expectations) > 0 {
		mmMergePatch.mock.t.Fatalf("Some expectations are already set for the PatchCollector.MergePatch method")
	}

	mmMergePatch.mock.funcMergePatch = f
	mmMergePatch.mock.funcMergePatchOrigin = minimock.CallerInfo(1)
	return mmMergePatch.mock
}

// When sets expectation for the PatchCollector.MergePatch which will trigger the result defined by the following
// Then helper
func (mmMergePatch *mPatchCollectorMockMergePatch) When(patch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) *PatchCollectorMockMergePatchExpectation {
	if mmMergePatch.mock.funcMergePatch != nil {
		mmMergePatch.mock.t.Fatalf("PatchCollectorMock.MergePatch mock is already set by Set")
	}

	expectation := &PatchCollectorMockMergePatchExpectation{
		mock:               mmMergePatch.mock,
		params:             &PatchCollectorMockMergePatchParams{patch, apiVersion, kind, namespace, name, opts},
		expectationOrigins: PatchCollectorMockMergePatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMergePatch.expectations = append(mmMergePatch.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.MergePatch return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockMergePatchExpectation) Then() *PatchCollectorMock {
	return e.mock
}

// Times sets number of times PatchCollector.MergePatch should be invoked
func (mmMergePatch *mPatchCollectorMockMergePatch) Times(n uint64) *mPatchCollectorMockMergePatch {
	if n == 0 {
		mmMergePatch.mock.t.Fatalf("Times of PatchCollectorMock.MergePatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMergePatch.expectedInvocations, n)
	mmMergePatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMergePatch
}

func (mmMergePatch *mPatchCollectorMockMergePatch) invocationsDone() bool {
	if len(mmMergePatch.expectations) == 0 && mmMergePatch.defaultExpectation == nil && mmMergePatch.mock.funcMergePatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMergePatch.mock.afterMergePatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMergePatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MergePatch implements mm_pkg.PatchCollector
func (mmMergePatch *PatchCollectorMock) MergePatch(patch any, apiVersion string, kind string, namespace string, name string, opts ...mm_pkg.PatchCollectorPatchOption) {
	mm_atomic.AddUint64(&mmMergePatch.beforeMergePatchCounter, 1)
	defer mm_atomic.AddUint64(&mmMergePatch.afterMergePatchCounter, 1)

	mmMergePatch.t.Helper()

	if mmMergePatch.inspectFuncMergePatch != nil {
		mmMergePatch.inspectFuncMergePatch(patch, apiVersion, kind, namespace, name, opts...)
	}

	mm_params := PatchCollectorMockMergePatchParams{patch, apiVersion, kind, namespace, name, opts}

	// Record call args
	mmMergePatch.MergePatchMock.mutex.Lock()
	mmMergePatch.MergePatchMock.callArgs = append(mmMergePatch.MergePatchMock.callArgs, &mm_params)
	mmMergePatch.MergePatchMock.mutex.Unlock()

	for _, e := range mmMergePatch.MergePatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmMergePatch.MergePatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMergePatch.MergePatchMock.defaultExpectation.Counter, 1)
		mm_want := mmMergePatch.MergePatchMock.defaultExpectation.params
		mm_want_ptrs := mmMergePatch.MergePatchMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockMergePatchParams{patch, apiVersion, kind, namespace, name, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.patch != nil && !minimock.Equal(*mm_want_ptrs.patch, mm_got.patch) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter patch, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originPatch, *mm_want_ptrs.patch, mm_got.patch, minimock.Diff(*mm_want_ptrs.patch, mm_got.patch))
			}

			if mm_want_ptrs.apiVersion != nil && !minimock.Equal(*mm_want_ptrs.apiVersion, mm_got.apiVersion) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter apiVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originApiVersion, *mm_want_ptrs.apiVersion, mm_got.apiVersion, minimock.Diff(*mm_want_ptrs.apiVersion, mm_got.apiVersion))
			}

			if mm_want_ptrs.kind != nil && !minimock.Equal(*mm_want_ptrs.kind, mm_got.kind) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter kind, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originKind, *mm_want_ptrs.kind, mm_got.kind, minimock.Diff(*mm_want_ptrs.kind, mm_got.kind))
			}

			if mm_want_ptrs.namespace != nil && !minimock.Equal(*mm_want_ptrs.namespace, mm_got.namespace) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter namespace, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originNamespace, *mm_want_ptrs.namespace, mm_got.namespace, minimock.Diff(*mm_want_ptrs.namespace, mm_got.namespace))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMergePatch.t.Errorf("PatchCollectorMock.MergePatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMergePatch.MergePatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmMergePatch.funcMergePatch != nil {
		mmMergePatch.funcMergePatch(patch, apiVersion, kind, namespace, name, opts...)
		return
	}
	mmMergePatch.t.Fatalf("Unexpected call to PatchCollectorMock.MergePatch. %v %v %v %v %v %v", patch, apiVersion, kind, namespace, name, opts)

}

// MergePatchAfterCounter returns a count of finished PatchCollectorMock.MergePatch invocations
func (mmMergePatch *PatchCollectorMock) MergePatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMergePatch.afterMergePatchCounter)
}

// MergePatchBeforeCounter returns a count of PatchCollectorMock.MergePatch invocations
func (mmMergePatch *PatchCollectorMock) MergePatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMergePatch.beforeMergePatchCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.MergePatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMergePatch *mPatchCollectorMockMergePatch) Calls() []*PatchCollectorMockMergePatchParams {
	mmMergePatch.mutex.RLock()

	argCopy := make([]*PatchCollectorMockMergePatchParams, len(mmMergePatch.callArgs))
	copy(argCopy, mmMergePatch.callArgs)

	mmMergePatch.mutex.RUnlock()

	return argCopy
}

// MinimockMergePatchDone returns true if the count of the MergePatch invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockMergePatchDone() bool {
	if m.MergePatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MergePatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MergePatchMock.invocationsDone()
}

// MinimockMergePatchInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockMergePatchInspect() {
	for _, e := range m.MergePatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMergePatchCounter := mm_atomic.LoadUint64(&m.afterMergePatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MergePatchMock.defaultExpectation != nil && afterMergePatchCounter < 1 {
		if m.MergePatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s", m.MergePatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s with params: %#v", m.MergePatchMock.defaultExpectation.expectationOrigins.origin, *m.MergePatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMergePatch != nil && afterMergePatchCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.MergePatch at\n%s", m.funcMergePatchOrigin)
	}

	if !m.MergePatchMock.invocationsDone() && afterMergePatchCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.MergePatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MergePatchMock.expectedInvocations), m.MergePatchMock.expectedInvocationsOrigin, afterMergePatchCounter)
	}
}

type mPatchCollectorMockWriteOutput struct {
	optional           bool
	mock               *PatchCollectorMock
	defaultExpectation *PatchCollectorMockWriteOutputExpectation
	expectations       []*PatchCollectorMockWriteOutputExpectation

	callArgs []*PatchCollectorMockWriteOutputParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchCollectorMockWriteOutputExpectation specifies expectation struct of the PatchCollector.WriteOutput
type PatchCollectorMockWriteOutputExpectation struct {
	mock               *PatchCollectorMock
	params             *PatchCollectorMockWriteOutputParams
	paramPtrs          *PatchCollectorMockWriteOutputParamPtrs
	expectationOrigins PatchCollectorMockWriteOutputExpectationOrigins
	results            *PatchCollectorMockWriteOutputResults
	returnOrigin       string
	Counter            uint64
}

// PatchCollectorMockWriteOutputParams contains parameters of the PatchCollector.WriteOutput
type PatchCollectorMockWriteOutputParams struct {
	writer io.Writer
}

// PatchCollectorMockWriteOutputParamPtrs contains pointers to parameters of the PatchCollector.WriteOutput
type PatchCollectorMockWriteOutputParamPtrs struct {
	writer *io.Writer
}

// PatchCollectorMockWriteOutputResults contains results of the PatchCollector.WriteOutput
type PatchCollectorMockWriteOutputResults struct {
	err error
}

// PatchCollectorMockWriteOutputOrigins contains origins of expectations of the PatchCollector.WriteOutput
type PatchCollectorMockWriteOutputExpectationOrigins struct {
	origin       string
	originWriter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Optional() *mPatchCollectorMockWriteOutput {
	mmWriteOutput.optional = true
	return mmWriteOutput
}

// Expect sets up expected params for PatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Expect(writer io.Writer) *mPatchCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.paramPtrs != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by ExpectParams functions")
	}

	mmWriteOutput.defaultExpectation.params = &PatchCollectorMockWriteOutputParams{writer}
	mmWriteOutput.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWriteOutput.expectations {
		if minimock.Equal(e.params, mmWriteOutput.defaultExpectation.params) {
			mmWriteOutput.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteOutput.defaultExpectation.params)
		}
	}

	return mmWriteOutput
}

// ExpectWriterParam1 sets up expected param writer for PatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) ExpectWriterParam1(writer io.Writer) *mPatchCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.params != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Expect")
	}

	if mmWriteOutput.defaultExpectation.paramPtrs == nil {
		mmWriteOutput.defaultExpectation.paramPtrs = &PatchCollectorMockWriteOutputParamPtrs{}
	}
	mmWriteOutput.defaultExpectation.paramPtrs.writer = &writer
	mmWriteOutput.defaultExpectation.expectationOrigins.originWriter = minimock.CallerInfo(1)

	return mmWriteOutput
}

// Inspect accepts an inspector function that has same arguments as the PatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Inspect(f func(writer io.Writer)) *mPatchCollectorMockWriteOutput {
	if mmWriteOutput.mock.inspectFuncWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("Inspect function is already set for PatchCollectorMock.WriteOutput")
	}

	mmWriteOutput.mock.inspectFuncWriteOutput = f

	return mmWriteOutput
}

// Return sets up results that will be returned by PatchCollector.WriteOutput
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Return(err error) *PatchCollectorMock {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchCollectorMockWriteOutputExpectation{mock: mmWriteOutput.mock}
	}
	mmWriteOutput.defaultExpectation.results = &PatchCollectorMockWriteOutputResults{err}
	mmWriteOutput.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// Set uses given function f to mock the PatchCollector.WriteOutput method
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Set(f func(writer io.Writer) (err error)) *PatchCollectorMock {
	if mmWriteOutput.defaultExpectation != nil {
		mmWriteOutput.mock.t.Fatalf("Default expectation is already set for the PatchCollector.WriteOutput method")
	}

	if len(mmWriteOutput.expectations) > 0 {
		mmWriteOutput.mock.t.Fatalf("Some expectations are already set for the PatchCollector.WriteOutput method")
	}

	mmWriteOutput.mock.funcWriteOutput = f
	mmWriteOutput.mock.funcWriteOutputOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// When sets expectation for the PatchCollector.WriteOutput which will trigger the result defined by the following
// Then helper
func (mmWriteOutput *mPatchCollectorMockWriteOutput) When(writer io.Writer) *PatchCollectorMockWriteOutputExpectation {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchCollectorMock.WriteOutput mock is already set by Set")
	}

	expectation := &PatchCollectorMockWriteOutputExpectation{
		mock:               mmWriteOutput.mock,
		params:             &PatchCollectorMockWriteOutputParams{writer},
		expectationOrigins: PatchCollectorMockWriteOutputExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWriteOutput.expectations = append(mmWriteOutput.expectations, expectation)
	return expectation
}

// Then sets up PatchCollector.WriteOutput return parameters for the expectation previously defined by the When method
func (e *PatchCollectorMockWriteOutputExpectation) Then(err error) *PatchCollectorMock {
	e.results = &PatchCollectorMockWriteOutputResults{err}
	return e.mock
}

// Times sets number of times PatchCollector.WriteOutput should be invoked
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Times(n uint64) *mPatchCollectorMockWriteOutput {
	if n == 0 {
		mmWriteOutput.mock.t.Fatalf("Times of PatchCollectorMock.WriteOutput mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteOutput.expectedInvocations, n)
	mmWriteOutput.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWriteOutput
}

func (mmWriteOutput *mPatchCollectorMockWriteOutput) invocationsDone() bool {
	if len(mmWriteOutput.expectations) == 0 && mmWriteOutput.defaultExpectation == nil && mmWriteOutput.mock.funcWriteOutput == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteOutput.mock.afterWriteOutputCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteOutput.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteOutput implements mm_pkg.PatchCollector
func (mmWriteOutput *PatchCollectorMock) WriteOutput(writer io.Writer) (err error) {
	mm_atomic.AddUint64(&mmWriteOutput.beforeWriteOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteOutput.afterWriteOutputCounter, 1)

	mmWriteOutput.t.Helper()

	if mmWriteOutput.inspectFuncWriteOutput != nil {
		mmWriteOutput.inspectFuncWriteOutput(writer)
	}

	mm_params := PatchCollectorMockWriteOutputParams{writer}

	// Record call args
	mmWriteOutput.WriteOutputMock.mutex.Lock()
	mmWriteOutput.WriteOutputMock.callArgs = append(mmWriteOutput.WriteOutputMock.callArgs, &mm_params)
	mmWriteOutput.WriteOutputMock.mutex.Unlock()

	for _, e := range mmWriteOutput.WriteOutputMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWriteOutput.WriteOutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteOutput.WriteOutputMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteOutput.WriteOutputMock.defaultExpectation.params
		mm_want_ptrs := mmWriteOutput.WriteOutputMock.defaultExpectation.paramPtrs

		mm_got := PatchCollectorMockWriteOutputParams{writer}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.writer != nil && !minimock.Equal(*mm_want_ptrs.writer, mm_got.writer) {
				mmWriteOutput.t.Errorf("PatchCollectorMock.WriteOutput got unexpected parameter writer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.originWriter, *mm_want_ptrs.writer, mm_got.writer, minimock.Diff(*mm_want_ptrs.writer, mm_got.writer))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteOutput.t.Errorf("PatchCollectorMock.WriteOutput got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteOutput.WriteOutputMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteOutput.t.Fatal("No results are set for the PatchCollectorMock.WriteOutput")
		}
		return (*mm_results).err
	}
	if mmWriteOutput.funcWriteOutput != nil {
		return mmWriteOutput.funcWriteOutput(writer)
	}
	mmWriteOutput.t.Fatalf("Unexpected call to PatchCollectorMock.WriteOutput. %v", writer)
	return
}

// WriteOutputAfterCounter returns a count of finished PatchCollectorMock.WriteOutput invocations
func (mmWriteOutput *PatchCollectorMock) WriteOutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.afterWriteOutputCounter)
}

// WriteOutputBeforeCounter returns a count of PatchCollectorMock.WriteOutput invocations
func (mmWriteOutput *PatchCollectorMock) WriteOutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.beforeWriteOutputCounter)
}

// Calls returns a list of arguments used in each call to PatchCollectorMock.WriteOutput.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteOutput *mPatchCollectorMockWriteOutput) Calls() []*PatchCollectorMockWriteOutputParams {
	mmWriteOutput.mutex.RLock()

	argCopy := make([]*PatchCollectorMockWriteOutputParams, len(mmWriteOutput.callArgs))
	copy(argCopy, mmWriteOutput.callArgs)

	mmWriteOutput.mutex.RUnlock()

	return argCopy
}

// MinimockWriteOutputDone returns true if the count of the WriteOutput invocations corresponds
// the number of defined expectations
func (m *PatchCollectorMock) MinimockWriteOutputDone() bool {
	if m.WriteOutputMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteOutputMock.invocationsDone()
}

// MinimockWriteOutputInspect logs each unmet expectation
func (m *PatchCollectorMock) MinimockWriteOutputInspect() {
	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWriteOutputCounter := mm_atomic.LoadUint64(&m.afterWriteOutputCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteOutputMock.defaultExpectation != nil && afterWriteOutputCounter < 1 {
		if m.WriteOutputMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s", m.WriteOutputMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s with params: %#v", m.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *m.WriteOutputMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteOutput != nil && afterWriteOutputCounter < 1 {
		m.t.Errorf("Expected call to PatchCollectorMock.WriteOutput at\n%s", m.funcWriteOutputOrigin)
	}

	if !m.WriteOutputMock.invocationsDone() && afterWriteOutputCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchCollectorMock.WriteOutput at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteOutputMock.expectedInvocations), m.WriteOutputMock.expectedInvocationsOrigin, afterWriteOutputCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PatchCollectorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockCreateIfNotExistsInspect()

			m.MinimockCreateOrUpdateInspect()

			m.MinimockDeleteInspect()

			m.MinimockDeleteInBackgroundInspect()

			m.MinimockDeleteNonCascadingInspect()

			m.MinimockJQPatchInspect()

			m.MinimockJSONPatchInspect()

			m.MinimockMergePatchInspect()

			m.MinimockWriteOutputInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PatchCollectorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PatchCollectorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockCreateIfNotExistsDone() &&
		m.MinimockCreateOrUpdateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteInBackgroundDone() &&
		m.MinimockDeleteNonCascadingDone() &&
		m.MinimockJQPatchDone() &&
		m.MinimockJSONPatchDone() &&
		m.MinimockMergePatchDone() &&
		m.MinimockWriteOutputDone()
}
