// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.Snapshot -o snapshot_mock.go -n SnapshotMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SnapshotMock implements mm_pkg.Snapshot
type SnapshotMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcString          func() (s1 string)
	funcStringOrigin    string
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mSnapshotMockString

	funcUnmarshalTo          func(v any) (err error)
	funcUnmarshalToOrigin    string
	inspectFuncUnmarshalTo   func(v any)
	afterUnmarshalToCounter  uint64
	beforeUnmarshalToCounter uint64
	UnmarshalToMock          mSnapshotMockUnmarshalTo
}

// NewSnapshotMock returns a mock for mm_pkg.Snapshot
func NewSnapshotMock(t minimock.Tester) *SnapshotMock {
	m := &SnapshotMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.StringMock = mSnapshotMockString{mock: m}

	m.UnmarshalToMock = mSnapshotMockUnmarshalTo{mock: m}
	m.UnmarshalToMock.callArgs = []*SnapshotMockUnmarshalToParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSnapshotMockString struct {
	optional           bool
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockStringExpectation
	expectations       []*SnapshotMockStringExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SnapshotMockStringExpectation specifies expectation struct of the Snapshot.String
type SnapshotMockStringExpectation struct {
	mock *SnapshotMock

	results      *SnapshotMockStringResults
	returnOrigin string
	Counter      uint64
}

// SnapshotMockStringResults contains results of the Snapshot.String
type SnapshotMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mSnapshotMockString) Optional() *mSnapshotMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for Snapshot.String
func (mmString *mSnapshotMockString) Expect() *mSnapshotMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SnapshotMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SnapshotMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.String
func (mmString *mSnapshotMockString) Inspect(f func()) *mSnapshotMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for SnapshotMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by Snapshot.String
func (mmString *mSnapshotMockString) Return(s1 string) *SnapshotMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SnapshotMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SnapshotMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &SnapshotMockStringResults{s1}
	mmString.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmString.mock
}

// Set uses given function f to mock the Snapshot.String method
func (mmString *mSnapshotMockString) Set(f func() (s1 string)) *SnapshotMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the Snapshot.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the Snapshot.String method")
	}

	mmString.mock.funcString = f
	mmString.mock.funcStringOrigin = minimock.CallerInfo(1)
	return mmString.mock
}

// Times sets number of times Snapshot.String should be invoked
func (mmString *mSnapshotMockString) Times(n uint64) *mSnapshotMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of SnapshotMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	mmString.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmString
}

func (mmString *mSnapshotMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements mm_pkg.Snapshot
func (mmString *SnapshotMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	mmString.t.Helper()

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the SnapshotMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to SnapshotMock.String.")
	return
}

// StringAfterCounter returns a count of finished SnapshotMock.String invocations
func (mmString *SnapshotMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of SnapshotMock.String invocations
func (mmString *SnapshotMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *SnapshotMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Errorf("Expected call to SnapshotMock.String at\n%s", m.StringMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Errorf("Expected call to SnapshotMock.String at\n%s", m.funcStringOrigin)
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to SnapshotMock.String at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), m.StringMock.expectedInvocationsOrigin, afterStringCounter)
	}
}

type mSnapshotMockUnmarshalTo struct {
	optional           bool
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockUnmarshalToExpectation
	expectations       []*SnapshotMockUnmarshalToExpectation

	callArgs []*SnapshotMockUnmarshalToParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SnapshotMockUnmarshalToExpectation specifies expectation struct of the Snapshot.UnmarshalTo
type SnapshotMockUnmarshalToExpectation struct {
	mock               *SnapshotMock
	params             *SnapshotMockUnmarshalToParams
	paramPtrs          *SnapshotMockUnmarshalToParamPtrs
	expectationOrigins SnapshotMockUnmarshalToExpectationOrigins
	results            *SnapshotMockUnmarshalToResults
	returnOrigin       string
	Counter            uint64
}

// SnapshotMockUnmarshalToParams contains parameters of the Snapshot.UnmarshalTo
type SnapshotMockUnmarshalToParams struct {
	v any
}

// SnapshotMockUnmarshalToParamPtrs contains pointers to parameters of the Snapshot.UnmarshalTo
type SnapshotMockUnmarshalToParamPtrs struct {
	v *any
}

// SnapshotMockUnmarshalToResults contains results of the Snapshot.UnmarshalTo
type SnapshotMockUnmarshalToResults struct {
	err error
}

// SnapshotMockUnmarshalToOrigins contains origins of expectations of the Snapshot.UnmarshalTo
type SnapshotMockUnmarshalToExpectationOrigins struct {
	origin  string
	originV string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) Optional() *mSnapshotMockUnmarshalTo {
	mmUnmarshalTo.optional = true
	return mmUnmarshalTo
}

// Expect sets up expected params for Snapshot.UnmarshalTo
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) Expect(v any) *mSnapshotMockUnmarshalTo {
	if mmUnmarshalTo.mock.funcUnmarshalTo != nil {
		mmUnmarshalTo.mock.t.Fatalf("SnapshotMock.UnmarshalTo mock is already set by Set")
	}

	if mmUnmarshalTo.defaultExpectation == nil {
		mmUnmarshalTo.defaultExpectation = &SnapshotMockUnmarshalToExpectation{}
	}

	if mmUnmarshalTo.defaultExpectation.paramPtrs != nil {
		mmUnmarshalTo.mock.t.Fatalf("SnapshotMock.UnmarshalTo mock is already set by ExpectParams functions")
	}

	mmUnmarshalTo.defaultExpectation.params = &SnapshotMockUnmarshalToParams{v}
	mmUnmarshalTo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUnmarshalTo.expectations {
		if minimock.Equal(e.params, mmUnmarshalTo.defaultExpectation.params) {
			mmUnmarshalTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnmarshalTo.defaultExpectation.params)
		}
	}

	return mmUnmarshalTo
}

// ExpectVParam1 sets up expected param v for Snapshot.UnmarshalTo
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) ExpectVParam1(v any) *mSnapshotMockUnmarshalTo {
	if mmUnmarshalTo.mock.funcUnmarshalTo != nil {
		mmUnmarshalTo.mock.t.Fatalf("SnapshotMock.UnmarshalTo mock is already set by Set")
	}

	if mmUnmarshalTo.defaultExpectation == nil {
		mmUnmarshalTo.defaultExpectation = &SnapshotMockUnmarshalToExpectation{}
	}

	if mmUnmarshalTo.defaultExpectation.params != nil {
		mmUnmarshalTo.mock.t.Fatalf("SnapshotMock.UnmarshalTo mock is already set by Expect")
	}

	if mmUnmarshalTo.defaultExpectation.paramPtrs == nil {
		mmUnmarshalTo.defaultExpectation.paramPtrs = &SnapshotMockUnmarshalToParamPtrs{}
	}
	mmUnmarshalTo.defaultExpectation.paramPtrs.v = &v
	mmUnmarshalTo.defaultExpectation.expectationOrigins.originV = minimock.CallerInfo(1)

	return mmUnmarshalTo
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.UnmarshalTo
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) Inspect(f func(v any)) *mSnapshotMockUnmarshalTo {
	if mmUnmarshalTo.mock.inspectFuncUnmarshalTo != nil {
		mmUnmarshalTo.mock.t.Fatalf("Inspect function is already set for SnapshotMock.UnmarshalTo")
	}

	mmUnmarshalTo.mock.inspectFuncUnmarshalTo = f

	return mmUnmarshalTo
}

// Return sets up results that will be returned by Snapshot.UnmarshalTo
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) Return(err error) *SnapshotMock {
	if mmUnmarshalTo.mock.funcUnmarshalTo != nil {
		mmUnmarshalTo.mock.t.Fatalf("SnapshotMock.UnmarshalTo mock is already set by Set")
	}

	if mmUnmarshalTo.defaultExpectation == nil {
		mmUnmarshalTo.defaultExpectation = &SnapshotMockUnmarshalToExpectation{mock: mmUnmarshalTo.mock}
	}
	mmUnmarshalTo.defaultExpectation.results = &SnapshotMockUnmarshalToResults{err}
	mmUnmarshalTo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUnmarshalTo.mock
}

// Set uses given function f to mock the Snapshot.UnmarshalTo method
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) Set(f func(v any) (err error)) *SnapshotMock {
	if mmUnmarshalTo.defaultExpectation != nil {
		mmUnmarshalTo.mock.t.Fatalf("Default expectation is already set for the Snapshot.UnmarshalTo method")
	}

	if len(mmUnmarshalTo.expectations) > 0 {
		mmUnmarshalTo.mock.t.Fatalf("Some expectations are already set for the Snapshot.UnmarshalTo method")
	}

	mmUnmarshalTo.mock.funcUnmarshalTo = f
	mmUnmarshalTo.mock.funcUnmarshalToOrigin = minimock.CallerInfo(1)
	return mmUnmarshalTo.mock
}

// When sets expectation for the Snapshot.UnmarshalTo which will trigger the result defined by the following
// Then helper
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) When(v any) *SnapshotMockUnmarshalToExpectation {
	if mmUnmarshalTo.mock.funcUnmarshalTo != nil {
		mmUnmarshalTo.mock.t.Fatalf("SnapshotMock.UnmarshalTo mock is already set by Set")
	}

	expectation := &SnapshotMockUnmarshalToExpectation{
		mock:               mmUnmarshalTo.mock,
		params:             &SnapshotMockUnmarshalToParams{v},
		expectationOrigins: SnapshotMockUnmarshalToExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUnmarshalTo.expectations = append(mmUnmarshalTo.expectations, expectation)
	return expectation
}

// Then sets up Snapshot.UnmarshalTo return parameters for the expectation previously defined by the When method
func (e *SnapshotMockUnmarshalToExpectation) Then(err error) *SnapshotMock {
	e.results = &SnapshotMockUnmarshalToResults{err}
	return e.mock
}

// Times sets number of times Snapshot.UnmarshalTo should be invoked
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) Times(n uint64) *mSnapshotMockUnmarshalTo {
	if n == 0 {
		mmUnmarshalTo.mock.t.Fatalf("Times of SnapshotMock.UnmarshalTo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUnmarshalTo.expectedInvocations, n)
	mmUnmarshalTo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUnmarshalTo
}

func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) invocationsDone() bool {
	if len(mmUnmarshalTo.expectations) == 0 && mmUnmarshalTo.defaultExpectation == nil && mmUnmarshalTo.mock.funcUnmarshalTo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUnmarshalTo.mock.afterUnmarshalToCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUnmarshalTo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UnmarshalTo implements mm_pkg.Snapshot
func (mmUnmarshalTo *SnapshotMock) UnmarshalTo(v any) (err error) {
	mm_atomic.AddUint64(&mmUnmarshalTo.beforeUnmarshalToCounter, 1)
	defer mm_atomic.AddUint64(&mmUnmarshalTo.afterUnmarshalToCounter, 1)

	mmUnmarshalTo.t.Helper()

	if mmUnmarshalTo.inspectFuncUnmarshalTo != nil {
		mmUnmarshalTo.inspectFuncUnmarshalTo(v)
	}

	mm_params := SnapshotMockUnmarshalToParams{v}

	// Record call args
	mmUnmarshalTo.UnmarshalToMock.mutex.Lock()
	mmUnmarshalTo.UnmarshalToMock.callArgs = append(mmUnmarshalTo.UnmarshalToMock.callArgs, &mm_params)
	mmUnmarshalTo.UnmarshalToMock.mutex.Unlock()

	for _, e := range mmUnmarshalTo.UnmarshalToMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnmarshalTo.UnmarshalToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnmarshalTo.UnmarshalToMock.defaultExpectation.Counter, 1)
		mm_want := mmUnmarshalTo.UnmarshalToMock.defaultExpectation.params
		mm_want_ptrs := mmUnmarshalTo.UnmarshalToMock.defaultExpectation.paramPtrs

		mm_got := SnapshotMockUnmarshalToParams{v}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.v != nil && !minimock.Equal(*mm_want_ptrs.v, mm_got.v) {
				mmUnmarshalTo.t.Errorf("SnapshotMock.UnmarshalTo got unexpected parameter v, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUnmarshalTo.UnmarshalToMock.defaultExpectation.expectationOrigins.originV, *mm_want_ptrs.v, mm_got.v, minimock.Diff(*mm_want_ptrs.v, mm_got.v))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnmarshalTo.t.Errorf("SnapshotMock.UnmarshalTo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUnmarshalTo.UnmarshalToMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnmarshalTo.UnmarshalToMock.defaultExpectation.results
		if mm_results == nil {
			mmUnmarshalTo.t.Fatal("No results are set for the SnapshotMock.UnmarshalTo")
		}
		return (*mm_results).err
	}
	if mmUnmarshalTo.funcUnmarshalTo != nil {
		return mmUnmarshalTo.funcUnmarshalTo(v)
	}
	mmUnmarshalTo.t.Fatalf("Unexpected call to SnapshotMock.UnmarshalTo. %v", v)
	return
}

// UnmarshalToAfterCounter returns a count of finished SnapshotMock.UnmarshalTo invocations
func (mmUnmarshalTo *SnapshotMock) UnmarshalToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnmarshalTo.afterUnmarshalToCounter)
}

// UnmarshalToBeforeCounter returns a count of SnapshotMock.UnmarshalTo invocations
func (mmUnmarshalTo *SnapshotMock) UnmarshalToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnmarshalTo.beforeUnmarshalToCounter)
}

// Calls returns a list of arguments used in each call to SnapshotMock.UnmarshalTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnmarshalTo *mSnapshotMockUnmarshalTo) Calls() []*SnapshotMockUnmarshalToParams {
	mmUnmarshalTo.mutex.RLock()

	argCopy := make([]*SnapshotMockUnmarshalToParams, len(mmUnmarshalTo.callArgs))
	copy(argCopy, mmUnmarshalTo.callArgs)

	mmUnmarshalTo.mutex.RUnlock()

	return argCopy
}

// MinimockUnmarshalToDone returns true if the count of the UnmarshalTo invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockUnmarshalToDone() bool {
	if m.UnmarshalToMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UnmarshalToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UnmarshalToMock.invocationsDone()
}

// MinimockUnmarshalToInspect logs each unmet expectation
func (m *SnapshotMock) MinimockUnmarshalToInspect() {
	for _, e := range m.UnmarshalToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SnapshotMock.UnmarshalTo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUnmarshalToCounter := mm_atomic.LoadUint64(&m.afterUnmarshalToCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UnmarshalToMock.defaultExpectation != nil && afterUnmarshalToCounter < 1 {
		if m.UnmarshalToMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SnapshotMock.UnmarshalTo at\n%s", m.UnmarshalToMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SnapshotMock.UnmarshalTo at\n%s with params: %#v", m.UnmarshalToMock.defaultExpectation.expectationOrigins.origin, *m.UnmarshalToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnmarshalTo != nil && afterUnmarshalToCounter < 1 {
		m.t.Errorf("Expected call to SnapshotMock.UnmarshalTo at\n%s", m.funcUnmarshalToOrigin)
	}

	if !m.UnmarshalToMock.invocationsDone() && afterUnmarshalToCounter > 0 {
		m.t.Errorf("Expected %d calls to SnapshotMock.UnmarshalTo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UnmarshalToMock.expectedInvocations), m.UnmarshalToMock.expectedInvocationsOrigin, afterUnmarshalToCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SnapshotMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockStringInspect()

			m.MinimockUnmarshalToInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SnapshotMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SnapshotMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockStringDone() &&
		m.MinimockUnmarshalToDone()
}
