// Code generated by http://github.com/gojuno/minimock ((devel)). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.Snapshot -o snapshot_mock.go -n SnapshotMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SnapshotMock implements mm_pkg.Snapshot
type SnapshotMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcString          func() (s1 string)
	funcStringOrigin    string
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mSnapshotMockString

	funcUnmarhalTo          func(v any) (err error)
	funcUnmarhalToOrigin    string
	inspectFuncUnmarhalTo   func(v any)
	afterUnmarhalToCounter  uint64
	beforeUnmarhalToCounter uint64
	UnmarhalToMock          mSnapshotMockUnmarhalTo
}

// NewSnapshotMock returns a mock for mm_pkg.Snapshot
func NewSnapshotMock(t minimock.Tester) *SnapshotMock {
	m := &SnapshotMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.StringMock = mSnapshotMockString{mock: m}

	m.UnmarhalToMock = mSnapshotMockUnmarhalTo{mock: m}
	m.UnmarhalToMock.callArgs = []*SnapshotMockUnmarhalToParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSnapshotMockString struct {
	optional           bool
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockStringExpectation
	expectations       []*SnapshotMockStringExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SnapshotMockStringExpectation specifies expectation struct of the Snapshot.String
type SnapshotMockStringExpectation struct {
	mock *SnapshotMock

	results      *SnapshotMockStringResults
	returnOrigin string
	Counter      uint64
}

// SnapshotMockStringResults contains results of the Snapshot.String
type SnapshotMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mSnapshotMockString) Optional() *mSnapshotMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for Snapshot.String
func (mmString *mSnapshotMockString) Expect() *mSnapshotMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SnapshotMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SnapshotMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.String
func (mmString *mSnapshotMockString) Inspect(f func()) *mSnapshotMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for SnapshotMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by Snapshot.String
func (mmString *mSnapshotMockString) Return(s1 string) *SnapshotMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SnapshotMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SnapshotMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &SnapshotMockStringResults{s1}
	mmString.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmString.mock
}

// Set uses given function f to mock the Snapshot.String method
func (mmString *mSnapshotMockString) Set(f func() (s1 string)) *SnapshotMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the Snapshot.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the Snapshot.String method")
	}

	mmString.mock.funcString = f
	mmString.mock.funcStringOrigin = minimock.CallerInfo(1)
	return mmString.mock
}

// Times sets number of times Snapshot.String should be invoked
func (mmString *mSnapshotMockString) Times(n uint64) *mSnapshotMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of SnapshotMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	mmString.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmString
}

func (mmString *mSnapshotMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements mm_pkg.Snapshot
func (mmString *SnapshotMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	mmString.t.Helper()

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the SnapshotMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to SnapshotMock.String.")
	return
}

// StringAfterCounter returns a count of finished SnapshotMock.String invocations
func (mmString *SnapshotMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of SnapshotMock.String invocations
func (mmString *SnapshotMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *SnapshotMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Errorf("Expected call to SnapshotMock.String at\n%s", m.StringMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Errorf("Expected call to SnapshotMock.String at\n%s", m.funcStringOrigin)
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to SnapshotMock.String at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), m.StringMock.expectedInvocationsOrigin, afterStringCounter)
	}
}

type mSnapshotMockUnmarhalTo struct {
	optional           bool
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockUnmarhalToExpectation
	expectations       []*SnapshotMockUnmarhalToExpectation

	callArgs []*SnapshotMockUnmarhalToParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SnapshotMockUnmarhalToExpectation specifies expectation struct of the Snapshot.UnmarhalTo
type SnapshotMockUnmarhalToExpectation struct {
	mock               *SnapshotMock
	params             *SnapshotMockUnmarhalToParams
	paramPtrs          *SnapshotMockUnmarhalToParamPtrs
	expectationOrigins SnapshotMockUnmarhalToExpectationOrigins
	results            *SnapshotMockUnmarhalToResults
	returnOrigin       string
	Counter            uint64
}

// SnapshotMockUnmarhalToParams contains parameters of the Snapshot.UnmarhalTo
type SnapshotMockUnmarhalToParams struct {
	v any
}

// SnapshotMockUnmarhalToParamPtrs contains pointers to parameters of the Snapshot.UnmarhalTo
type SnapshotMockUnmarhalToParamPtrs struct {
	v *any
}

// SnapshotMockUnmarhalToResults contains results of the Snapshot.UnmarhalTo
type SnapshotMockUnmarhalToResults struct {
	err error
}

// SnapshotMockUnmarhalToOrigins contains origins of expectations of the Snapshot.UnmarhalTo
type SnapshotMockUnmarhalToExpectationOrigins struct {
	origin  string
	originV string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) Optional() *mSnapshotMockUnmarhalTo {
	mmUnmarhalTo.optional = true
	return mmUnmarhalTo
}

// Expect sets up expected params for Snapshot.UnmarhalTo
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) Expect(v any) *mSnapshotMockUnmarhalTo {
	if mmUnmarhalTo.mock.funcUnmarhalTo != nil {
		mmUnmarhalTo.mock.t.Fatalf("SnapshotMock.UnmarhalTo mock is already set by Set")
	}

	if mmUnmarhalTo.defaultExpectation == nil {
		mmUnmarhalTo.defaultExpectation = &SnapshotMockUnmarhalToExpectation{}
	}

	if mmUnmarhalTo.defaultExpectation.paramPtrs != nil {
		mmUnmarhalTo.mock.t.Fatalf("SnapshotMock.UnmarhalTo mock is already set by ExpectParams functions")
	}

	mmUnmarhalTo.defaultExpectation.params = &SnapshotMockUnmarhalToParams{v}
	mmUnmarhalTo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUnmarhalTo.expectations {
		if minimock.Equal(e.params, mmUnmarhalTo.defaultExpectation.params) {
			mmUnmarhalTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnmarhalTo.defaultExpectation.params)
		}
	}

	return mmUnmarhalTo
}

// ExpectVParam1 sets up expected param v for Snapshot.UnmarhalTo
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) ExpectVParam1(v any) *mSnapshotMockUnmarhalTo {
	if mmUnmarhalTo.mock.funcUnmarhalTo != nil {
		mmUnmarhalTo.mock.t.Fatalf("SnapshotMock.UnmarhalTo mock is already set by Set")
	}

	if mmUnmarhalTo.defaultExpectation == nil {
		mmUnmarhalTo.defaultExpectation = &SnapshotMockUnmarhalToExpectation{}
	}

	if mmUnmarhalTo.defaultExpectation.params != nil {
		mmUnmarhalTo.mock.t.Fatalf("SnapshotMock.UnmarhalTo mock is already set by Expect")
	}

	if mmUnmarhalTo.defaultExpectation.paramPtrs == nil {
		mmUnmarhalTo.defaultExpectation.paramPtrs = &SnapshotMockUnmarhalToParamPtrs{}
	}
	mmUnmarhalTo.defaultExpectation.paramPtrs.v = &v
	mmUnmarhalTo.defaultExpectation.expectationOrigins.originV = minimock.CallerInfo(1)

	return mmUnmarhalTo
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.UnmarhalTo
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) Inspect(f func(v any)) *mSnapshotMockUnmarhalTo {
	if mmUnmarhalTo.mock.inspectFuncUnmarhalTo != nil {
		mmUnmarhalTo.mock.t.Fatalf("Inspect function is already set for SnapshotMock.UnmarhalTo")
	}

	mmUnmarhalTo.mock.inspectFuncUnmarhalTo = f

	return mmUnmarhalTo
}

// Return sets up results that will be returned by Snapshot.UnmarhalTo
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) Return(err error) *SnapshotMock {
	if mmUnmarhalTo.mock.funcUnmarhalTo != nil {
		mmUnmarhalTo.mock.t.Fatalf("SnapshotMock.UnmarhalTo mock is already set by Set")
	}

	if mmUnmarhalTo.defaultExpectation == nil {
		mmUnmarhalTo.defaultExpectation = &SnapshotMockUnmarhalToExpectation{mock: mmUnmarhalTo.mock}
	}
	mmUnmarhalTo.defaultExpectation.results = &SnapshotMockUnmarhalToResults{err}
	mmUnmarhalTo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUnmarhalTo.mock
}

// Set uses given function f to mock the Snapshot.UnmarhalTo method
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) Set(f func(v any) (err error)) *SnapshotMock {
	if mmUnmarhalTo.defaultExpectation != nil {
		mmUnmarhalTo.mock.t.Fatalf("Default expectation is already set for the Snapshot.UnmarhalTo method")
	}

	if len(mmUnmarhalTo.expectations) > 0 {
		mmUnmarhalTo.mock.t.Fatalf("Some expectations are already set for the Snapshot.UnmarhalTo method")
	}

	mmUnmarhalTo.mock.funcUnmarhalTo = f
	mmUnmarhalTo.mock.funcUnmarhalToOrigin = minimock.CallerInfo(1)
	return mmUnmarhalTo.mock
}

// When sets expectation for the Snapshot.UnmarhalTo which will trigger the result defined by the following
// Then helper
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) When(v any) *SnapshotMockUnmarhalToExpectation {
	if mmUnmarhalTo.mock.funcUnmarhalTo != nil {
		mmUnmarhalTo.mock.t.Fatalf("SnapshotMock.UnmarhalTo mock is already set by Set")
	}

	expectation := &SnapshotMockUnmarhalToExpectation{
		mock:               mmUnmarhalTo.mock,
		params:             &SnapshotMockUnmarhalToParams{v},
		expectationOrigins: SnapshotMockUnmarhalToExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUnmarhalTo.expectations = append(mmUnmarhalTo.expectations, expectation)
	return expectation
}

// Then sets up Snapshot.UnmarhalTo return parameters for the expectation previously defined by the When method
func (e *SnapshotMockUnmarhalToExpectation) Then(err error) *SnapshotMock {
	e.results = &SnapshotMockUnmarhalToResults{err}
	return e.mock
}

// Times sets number of times Snapshot.UnmarhalTo should be invoked
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) Times(n uint64) *mSnapshotMockUnmarhalTo {
	if n == 0 {
		mmUnmarhalTo.mock.t.Fatalf("Times of SnapshotMock.UnmarhalTo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUnmarhalTo.expectedInvocations, n)
	mmUnmarhalTo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUnmarhalTo
}

func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) invocationsDone() bool {
	if len(mmUnmarhalTo.expectations) == 0 && mmUnmarhalTo.defaultExpectation == nil && mmUnmarhalTo.mock.funcUnmarhalTo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUnmarhalTo.mock.afterUnmarhalToCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUnmarhalTo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UnmarhalTo implements mm_pkg.Snapshot
func (mmUnmarhalTo *SnapshotMock) UnmarhalTo(v any) (err error) {
	mm_atomic.AddUint64(&mmUnmarhalTo.beforeUnmarhalToCounter, 1)
	defer mm_atomic.AddUint64(&mmUnmarhalTo.afterUnmarhalToCounter, 1)

	mmUnmarhalTo.t.Helper()

	if mmUnmarhalTo.inspectFuncUnmarhalTo != nil {
		mmUnmarhalTo.inspectFuncUnmarhalTo(v)
	}

	mm_params := SnapshotMockUnmarhalToParams{v}

	// Record call args
	mmUnmarhalTo.UnmarhalToMock.mutex.Lock()
	mmUnmarhalTo.UnmarhalToMock.callArgs = append(mmUnmarhalTo.UnmarhalToMock.callArgs, &mm_params)
	mmUnmarhalTo.UnmarhalToMock.mutex.Unlock()

	for _, e := range mmUnmarhalTo.UnmarhalToMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnmarhalTo.UnmarhalToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnmarhalTo.UnmarhalToMock.defaultExpectation.Counter, 1)
		mm_want := mmUnmarhalTo.UnmarhalToMock.defaultExpectation.params
		mm_want_ptrs := mmUnmarhalTo.UnmarhalToMock.defaultExpectation.paramPtrs

		mm_got := SnapshotMockUnmarhalToParams{v}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.v != nil && !minimock.Equal(*mm_want_ptrs.v, mm_got.v) {
				mmUnmarhalTo.t.Errorf("SnapshotMock.UnmarhalTo got unexpected parameter v, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUnmarhalTo.UnmarhalToMock.defaultExpectation.expectationOrigins.originV, *mm_want_ptrs.v, mm_got.v, minimock.Diff(*mm_want_ptrs.v, mm_got.v))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnmarhalTo.t.Errorf("SnapshotMock.UnmarhalTo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUnmarhalTo.UnmarhalToMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnmarhalTo.UnmarhalToMock.defaultExpectation.results
		if mm_results == nil {
			mmUnmarhalTo.t.Fatal("No results are set for the SnapshotMock.UnmarhalTo")
		}
		return (*mm_results).err
	}
	if mmUnmarhalTo.funcUnmarhalTo != nil {
		return mmUnmarhalTo.funcUnmarhalTo(v)
	}
	mmUnmarhalTo.t.Fatalf("Unexpected call to SnapshotMock.UnmarhalTo. %v", v)
	return
}

// UnmarhalToAfterCounter returns a count of finished SnapshotMock.UnmarhalTo invocations
func (mmUnmarhalTo *SnapshotMock) UnmarhalToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnmarhalTo.afterUnmarhalToCounter)
}

// UnmarhalToBeforeCounter returns a count of SnapshotMock.UnmarhalTo invocations
func (mmUnmarhalTo *SnapshotMock) UnmarhalToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnmarhalTo.beforeUnmarhalToCounter)
}

// Calls returns a list of arguments used in each call to SnapshotMock.UnmarhalTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnmarhalTo *mSnapshotMockUnmarhalTo) Calls() []*SnapshotMockUnmarhalToParams {
	mmUnmarhalTo.mutex.RLock()

	argCopy := make([]*SnapshotMockUnmarhalToParams, len(mmUnmarhalTo.callArgs))
	copy(argCopy, mmUnmarhalTo.callArgs)

	mmUnmarhalTo.mutex.RUnlock()

	return argCopy
}

// MinimockUnmarhalToDone returns true if the count of the UnmarhalTo invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockUnmarhalToDone() bool {
	if m.UnmarhalToMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UnmarhalToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UnmarhalToMock.invocationsDone()
}

// MinimockUnmarhalToInspect logs each unmet expectation
func (m *SnapshotMock) MinimockUnmarhalToInspect() {
	for _, e := range m.UnmarhalToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SnapshotMock.UnmarhalTo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUnmarhalToCounter := mm_atomic.LoadUint64(&m.afterUnmarhalToCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UnmarhalToMock.defaultExpectation != nil && afterUnmarhalToCounter < 1 {
		if m.UnmarhalToMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SnapshotMock.UnmarhalTo at\n%s", m.UnmarhalToMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SnapshotMock.UnmarhalTo at\n%s with params: %#v", m.UnmarhalToMock.defaultExpectation.expectationOrigins.origin, *m.UnmarhalToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnmarhalTo != nil && afterUnmarhalToCounter < 1 {
		m.t.Errorf("Expected call to SnapshotMock.UnmarhalTo at\n%s", m.funcUnmarhalToOrigin)
	}

	if !m.UnmarhalToMock.invocationsDone() && afterUnmarhalToCounter > 0 {
		m.t.Errorf("Expected %d calls to SnapshotMock.UnmarhalTo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UnmarhalToMock.expectedInvocations), m.UnmarhalToMock.expectedInvocationsOrigin, afterUnmarhalToCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SnapshotMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockStringInspect()

			m.MinimockUnmarhalToInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SnapshotMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SnapshotMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockStringDone() &&
		m.MinimockUnmarhalToDone()
}
