// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.RegistryClient -o registry_client_mock.go -n RegistryClientMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
)

// RegistryClientMock implements mm_pkg.RegistryClient
type RegistryClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDigest          func(ctx context.Context, tag string) (s1 string, err error)
	funcDigestOrigin    string
	inspectFuncDigest   func(ctx context.Context, tag string)
	afterDigestCounter  uint64
	beforeDigestCounter uint64
	DigestMock          mRegistryClientMockDigest

	funcImage          func(ctx context.Context, tag string) (i1 v1.Image, err error)
	funcImageOrigin    string
	inspectFuncImage   func(ctx context.Context, tag string)
	afterImageCounter  uint64
	beforeImageCounter uint64
	ImageMock          mRegistryClientMockImage

	funcListTags          func(ctx context.Context) (sa1 []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mRegistryClientMockListTags
}

// NewRegistryClientMock returns a mock for mm_pkg.RegistryClient
func NewRegistryClientMock(t minimock.Tester) *RegistryClientMock {
	m := &RegistryClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DigestMock = mRegistryClientMockDigest{mock: m}
	m.DigestMock.callArgs = []*RegistryClientMockDigestParams{}

	m.ImageMock = mRegistryClientMockImage{mock: m}
	m.ImageMock.callArgs = []*RegistryClientMockImageParams{}

	m.ListTagsMock = mRegistryClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*RegistryClientMockListTagsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryClientMockDigest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockDigestExpectation
	expectations       []*RegistryClientMockDigestExpectation

	callArgs []*RegistryClientMockDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockDigestExpectation specifies expectation struct of the RegistryClient.Digest
type RegistryClientMockDigestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockDigestParams
	paramPtrs          *RegistryClientMockDigestParamPtrs
	expectationOrigins RegistryClientMockDigestExpectationOrigins
	results            *RegistryClientMockDigestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockDigestParams contains parameters of the RegistryClient.Digest
type RegistryClientMockDigestParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockDigestParamPtrs contains pointers to parameters of the RegistryClient.Digest
type RegistryClientMockDigestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockDigestResults contains results of the RegistryClient.Digest
type RegistryClientMockDigestResults struct {
	s1  string
	err error
}

// RegistryClientMockDigestOrigins contains origins of expectations of the RegistryClient.Digest
type RegistryClientMockDigestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDigest *mRegistryClientMockDigest) Optional() *mRegistryClientMockDigest {
	mmDigest.optional = true
	return mmDigest
}

// Expect sets up expected params for RegistryClient.Digest
func (mmDigest *mRegistryClientMockDigest) Expect(ctx context.Context, tag string) *mRegistryClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &RegistryClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.paramPtrs != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by ExpectParams functions")
	}

	mmDigest.defaultExpectation.params = &RegistryClientMockDigestParams{ctx, tag}
	mmDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDigest.expectations {
		if minimock.Equal(e.params, mmDigest.defaultExpectation.params) {
			mmDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigest.defaultExpectation.params)
		}
	}

	return mmDigest
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.Digest
func (mmDigest *mRegistryClientMockDigest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &RegistryClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.params != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by Expect")
	}

	if mmDigest.defaultExpectation.paramPtrs == nil {
		mmDigest.defaultExpectation.paramPtrs = &RegistryClientMockDigestParamPtrs{}
	}
	mmDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDigest
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.Digest
func (mmDigest *mRegistryClientMockDigest) ExpectTagParam2(tag string) *mRegistryClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &RegistryClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.params != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by Expect")
	}

	if mmDigest.defaultExpectation.paramPtrs == nil {
		mmDigest.defaultExpectation.paramPtrs = &RegistryClientMockDigestParamPtrs{}
	}
	mmDigest.defaultExpectation.paramPtrs.tag = &tag
	mmDigest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmDigest
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.Digest
func (mmDigest *mRegistryClientMockDigest) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockDigest {
	if mmDigest.mock.inspectFuncDigest != nil {
		mmDigest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.Digest")
	}

	mmDigest.mock.inspectFuncDigest = f

	return mmDigest
}

// Return sets up results that will be returned by RegistryClient.Digest
func (mmDigest *mRegistryClientMockDigest) Return(s1 string, err error) *RegistryClientMock {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &RegistryClientMockDigestExpectation{mock: mmDigest.mock}
	}
	mmDigest.defaultExpectation.results = &RegistryClientMockDigestResults{s1, err}
	mmDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// Set uses given function f to mock the RegistryClient.Digest method
func (mmDigest *mRegistryClientMockDigest) Set(f func(ctx context.Context, tag string) (s1 string, err error)) *RegistryClientMock {
	if mmDigest.defaultExpectation != nil {
		mmDigest.mock.t.Fatalf("Default expectation is already set for the RegistryClient.Digest method")
	}

	if len(mmDigest.expectations) > 0 {
		mmDigest.mock.t.Fatalf("Some expectations are already set for the RegistryClient.Digest method")
	}

	mmDigest.mock.funcDigest = f
	mmDigest.mock.funcDigestOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// When sets expectation for the RegistryClient.Digest which will trigger the result defined by the following
// Then helper
func (mmDigest *mRegistryClientMockDigest) When(ctx context.Context, tag string) *RegistryClientMockDigestExpectation {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("RegistryClientMock.Digest mock is already set by Set")
	}

	expectation := &RegistryClientMockDigestExpectation{
		mock:               mmDigest.mock,
		params:             &RegistryClientMockDigestParams{ctx, tag},
		expectationOrigins: RegistryClientMockDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDigest.expectations = append(mmDigest.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.Digest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockDigestExpectation) Then(s1 string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockDigestResults{s1, err}
	return e.mock
}

// Times sets number of times RegistryClient.Digest should be invoked
func (mmDigest *mRegistryClientMockDigest) Times(n uint64) *mRegistryClientMockDigest {
	if n == 0 {
		mmDigest.mock.t.Fatalf("Times of RegistryClientMock.Digest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDigest.expectedInvocations, n)
	mmDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDigest
}

func (mmDigest *mRegistryClientMockDigest) invocationsDone() bool {
	if len(mmDigest.expectations) == 0 && mmDigest.defaultExpectation == nil && mmDigest.mock.funcDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDigest.mock.afterDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Digest implements mm_pkg.RegistryClient
func (mmDigest *RegistryClientMock) Digest(ctx context.Context, tag string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmDigest.beforeDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmDigest.afterDigestCounter, 1)

	mmDigest.t.Helper()

	if mmDigest.inspectFuncDigest != nil {
		mmDigest.inspectFuncDigest(ctx, tag)
	}

	mm_params := RegistryClientMockDigestParams{ctx, tag}

	// Record call args
	mmDigest.DigestMock.mutex.Lock()
	mmDigest.DigestMock.callArgs = append(mmDigest.DigestMock.callArgs, &mm_params)
	mmDigest.DigestMock.mutex.Unlock()

	for _, e := range mmDigest.DigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmDigest.DigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigest.DigestMock.defaultExpectation.Counter, 1)
		mm_want := mmDigest.DigestMock.defaultExpectation.params
		mm_want_ptrs := mmDigest.DigestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockDigestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDigest.t.Errorf("RegistryClientMock.Digest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDigest.DigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmDigest.t.Errorf("RegistryClientMock.Digest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDigest.DigestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigest.t.Errorf("RegistryClientMock.Digest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDigest.DigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigest.DigestMock.defaultExpectation.results
		if mm_results == nil {
			mmDigest.t.Fatal("No results are set for the RegistryClientMock.Digest")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmDigest.funcDigest != nil {
		return mmDigest.funcDigest(ctx, tag)
	}
	mmDigest.t.Fatalf("Unexpected call to RegistryClientMock.Digest. %v %v", ctx, tag)
	return
}

// DigestAfterCounter returns a count of finished RegistryClientMock.Digest invocations
func (mmDigest *RegistryClientMock) DigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.afterDigestCounter)
}

// DigestBeforeCounter returns a count of RegistryClientMock.Digest invocations
func (mmDigest *RegistryClientMock) DigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.beforeDigestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.Digest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigest *mRegistryClientMockDigest) Calls() []*RegistryClientMockDigestParams {
	mmDigest.mutex.RLock()

	argCopy := make([]*RegistryClientMockDigestParams, len(mmDigest.callArgs))
	copy(argCopy, mmDigest.callArgs)

	mmDigest.mutex.RUnlock()

	return argCopy
}

// MinimockDigestDone returns true if the count of the Digest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockDigestDone() bool {
	if m.DigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DigestMock.invocationsDone()
}

// MinimockDigestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockDigestInspect() {
	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.Digest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDigestCounter := mm_atomic.LoadUint64(&m.afterDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DigestMock.defaultExpectation != nil && afterDigestCounter < 1 {
		if m.DigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.Digest at\n%s", m.DigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.Digest at\n%s with params: %#v", m.DigestMock.defaultExpectation.expectationOrigins.origin, *m.DigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigest != nil && afterDigestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.Digest at\n%s", m.funcDigestOrigin)
	}

	if !m.DigestMock.invocationsDone() && afterDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.Digest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DigestMock.expectedInvocations), m.DigestMock.expectedInvocationsOrigin, afterDigestCounter)
	}
}

type mRegistryClientMockImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockImageExpectation
	expectations       []*RegistryClientMockImageExpectation

	callArgs []*RegistryClientMockImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockImageExpectation specifies expectation struct of the RegistryClient.Image
type RegistryClientMockImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockImageParams
	paramPtrs          *RegistryClientMockImageParamPtrs
	expectationOrigins RegistryClientMockImageExpectationOrigins
	results            *RegistryClientMockImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockImageParams contains parameters of the RegistryClient.Image
type RegistryClientMockImageParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockImageParamPtrs contains pointers to parameters of the RegistryClient.Image
type RegistryClientMockImageParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockImageResults contains results of the RegistryClient.Image
type RegistryClientMockImageResults struct {
	i1  v1.Image
	err error
}

// RegistryClientMockImageOrigins contains origins of expectations of the RegistryClient.Image
type RegistryClientMockImageExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImage *mRegistryClientMockImage) Optional() *mRegistryClientMockImage {
	mmImage.optional = true
	return mmImage
}

// Expect sets up expected params for RegistryClient.Image
func (mmImage *mRegistryClientMockImage) Expect(ctx context.Context, tag string) *mRegistryClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &RegistryClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.paramPtrs != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by ExpectParams functions")
	}

	mmImage.defaultExpectation.params = &RegistryClientMockImageParams{ctx, tag}
	mmImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImage.expectations {
		if minimock.Equal(e.params, mmImage.defaultExpectation.params) {
			mmImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImage.defaultExpectation.params)
		}
	}

	return mmImage
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.Image
func (mmImage *mRegistryClientMockImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &RegistryClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &RegistryClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImage
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.Image
func (mmImage *mRegistryClientMockImage) ExpectTagParam2(tag string) *mRegistryClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &RegistryClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &RegistryClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.tag = &tag
	mmImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmImage
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.Image
func (mmImage *mRegistryClientMockImage) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockImage {
	if mmImage.mock.inspectFuncImage != nil {
		mmImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.Image")
	}

	mmImage.mock.inspectFuncImage = f

	return mmImage
}

// Return sets up results that will be returned by RegistryClient.Image
func (mmImage *mRegistryClientMockImage) Return(i1 v1.Image, err error) *RegistryClientMock {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &RegistryClientMockImageExpectation{mock: mmImage.mock}
	}
	mmImage.defaultExpectation.results = &RegistryClientMockImageResults{i1, err}
	mmImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// Set uses given function f to mock the RegistryClient.Image method
func (mmImage *mRegistryClientMockImage) Set(f func(ctx context.Context, tag string) (i1 v1.Image, err error)) *RegistryClientMock {
	if mmImage.defaultExpectation != nil {
		mmImage.mock.t.Fatalf("Default expectation is already set for the RegistryClient.Image method")
	}

	if len(mmImage.expectations) > 0 {
		mmImage.mock.t.Fatalf("Some expectations are already set for the RegistryClient.Image method")
	}

	mmImage.mock.funcImage = f
	mmImage.mock.funcImageOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// When sets expectation for the RegistryClient.Image which will trigger the result defined by the following
// Then helper
func (mmImage *mRegistryClientMockImage) When(ctx context.Context, tag string) *RegistryClientMockImageExpectation {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("RegistryClientMock.Image mock is already set by Set")
	}

	expectation := &RegistryClientMockImageExpectation{
		mock:               mmImage.mock,
		params:             &RegistryClientMockImageParams{ctx, tag},
		expectationOrigins: RegistryClientMockImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImage.expectations = append(mmImage.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.Image return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockImageExpectation) Then(i1 v1.Image, err error) *RegistryClientMock {
	e.results = &RegistryClientMockImageResults{i1, err}
	return e.mock
}

// Times sets number of times RegistryClient.Image should be invoked
func (mmImage *mRegistryClientMockImage) Times(n uint64) *mRegistryClientMockImage {
	if n == 0 {
		mmImage.mock.t.Fatalf("Times of RegistryClientMock.Image mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImage.expectedInvocations, n)
	mmImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImage
}

func (mmImage *mRegistryClientMockImage) invocationsDone() bool {
	if len(mmImage.expectations) == 0 && mmImage.defaultExpectation == nil && mmImage.mock.funcImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImage.mock.afterImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Image implements mm_pkg.RegistryClient
func (mmImage *RegistryClientMock) Image(ctx context.Context, tag string) (i1 v1.Image, err error) {
	mm_atomic.AddUint64(&mmImage.beforeImageCounter, 1)
	defer mm_atomic.AddUint64(&mmImage.afterImageCounter, 1)

	mmImage.t.Helper()

	if mmImage.inspectFuncImage != nil {
		mmImage.inspectFuncImage(ctx, tag)
	}

	mm_params := RegistryClientMockImageParams{ctx, tag}

	// Record call args
	mmImage.ImageMock.mutex.Lock()
	mmImage.ImageMock.callArgs = append(mmImage.ImageMock.callArgs, &mm_params)
	mmImage.ImageMock.mutex.Unlock()

	for _, e := range mmImage.ImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmImage.ImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImage.ImageMock.defaultExpectation.Counter, 1)
		mm_want := mmImage.ImageMock.defaultExpectation.params
		mm_want_ptrs := mmImage.ImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockImageParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImage.t.Errorf("RegistryClientMock.Image got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmImage.t.Errorf("RegistryClientMock.Image got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImage.t.Errorf("RegistryClientMock.Image got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImage.ImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImage.ImageMock.defaultExpectation.results
		if mm_results == nil {
			mmImage.t.Fatal("No results are set for the RegistryClientMock.Image")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmImage.funcImage != nil {
		return mmImage.funcImage(ctx, tag)
	}
	mmImage.t.Fatalf("Unexpected call to RegistryClientMock.Image. %v %v", ctx, tag)
	return
}

// ImageAfterCounter returns a count of finished RegistryClientMock.Image invocations
func (mmImage *RegistryClientMock) ImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.afterImageCounter)
}

// ImageBeforeCounter returns a count of RegistryClientMock.Image invocations
func (mmImage *RegistryClientMock) ImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.beforeImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.Image.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImage *mRegistryClientMockImage) Calls() []*RegistryClientMockImageParams {
	mmImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockImageParams, len(mmImage.callArgs))
	copy(argCopy, mmImage.callArgs)

	mmImage.mutex.RUnlock()

	return argCopy
}

// MinimockImageDone returns true if the count of the Image invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockImageDone() bool {
	if m.ImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImageMock.invocationsDone()
}

// MinimockImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockImageInspect() {
	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.Image at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImageCounter := mm_atomic.LoadUint64(&m.afterImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImageMock.defaultExpectation != nil && afterImageCounter < 1 {
		if m.ImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.Image at\n%s", m.ImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.Image at\n%s with params: %#v", m.ImageMock.defaultExpectation.expectationOrigins.origin, *m.ImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImage != nil && afterImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.Image at\n%s", m.funcImageOrigin)
	}

	if !m.ImageMock.invocationsDone() && afterImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.Image at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImageMock.expectedInvocations), m.ImageMock.expectedInvocationsOrigin, afterImageCounter)
	}
}

type mRegistryClientMockListTags struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListTagsExpectation
	expectations       []*RegistryClientMockListTagsExpectation

	callArgs []*RegistryClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListTagsExpectation specifies expectation struct of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListTagsParams
	paramPtrs          *RegistryClientMockListTagsParamPtrs
	expectationOrigins RegistryClientMockListTagsExpectationOrigins
	results            *RegistryClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListTagsParams contains parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParams struct {
	ctx context.Context
}

// RegistryClientMockListTagsParamPtrs contains pointers to parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParamPtrs struct {
	ctx *context.Context
}

// RegistryClientMockListTagsResults contains results of the RegistryClient.ListTags
type RegistryClientMockListTagsResults struct {
	sa1 []string
	err error
}

// RegistryClientMockListTagsOrigins contains origins of expectations of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mRegistryClientMockListTags) Optional() *mRegistryClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Expect(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &RegistryClientMockListTagsParams{ctx}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Inspect(f func(ctx context.Context)) *mRegistryClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Return(sa1 []string, err error) *RegistryClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &RegistryClientMockListTagsResults{sa1, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the RegistryClient.ListTags method
func (mmListTags *mRegistryClientMockListTags) Set(f func(ctx context.Context) (sa1 []string, err error)) *RegistryClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the RegistryClient.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mRegistryClientMockListTags) When(ctx context.Context) *RegistryClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	expectation := &RegistryClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &RegistryClientMockListTagsParams{ctx},
		expectationOrigins: RegistryClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ListTags return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListTagsExpectation) Then(sa1 []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListTagsResults{sa1, err}
	return e.mock
}

// Times sets number of times RegistryClient.ListTags should be invoked
func (mmListTags *mRegistryClientMockListTags) Times(n uint64) *mRegistryClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of RegistryClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mRegistryClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements mm_pkg.RegistryClient
func (mmListTags *RegistryClientMock) ListTags(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx)
	}

	mm_params := RegistryClientMockListTagsParams{ctx}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListTagsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the RegistryClientMock.ListTags")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx)
	}
	mmListTags.t.Fatalf("Unexpected call to RegistryClientMock.ListTags. %v", ctx)
	return
}

// ListTagsAfterCounter returns a count of finished RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mRegistryClientMockListTags) Calls() []*RegistryClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*RegistryClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDigestInspect()

			m.MinimockImageInspect()

			m.MinimockListTagsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDigestDone() &&
		m.MinimockImageDone() &&
		m.MinimockListTagsDone()
}
