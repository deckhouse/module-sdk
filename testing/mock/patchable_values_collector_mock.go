// Code generated by http://github.com/gojuno/minimock ((devel)). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.PatchableValuesCollector -o patchable_values_collector_mock.go -n PatchableValuesCollectorMock -p mock

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/deckhouse/module-sdk/pkg/utils"
	"github.com/gojuno/minimock/v3"
	"github.com/tidwall/gjson"
)

// PatchableValuesCollectorMock implements mm_pkg.PatchableValuesCollector
type PatchableValuesCollectorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcArrayCount          func(path string) (i1 int, err error)
	funcArrayCountOrigin    string
	inspectFuncArrayCount   func(path string)
	afterArrayCountCounter  uint64
	beforeArrayCountCounter uint64
	ArrayCountMock          mPatchableValuesCollectorMockArrayCount

	funcExists          func(path string) (b1 bool)
	funcExistsOrigin    string
	inspectFuncExists   func(path string)
	afterExistsCounter  uint64
	beforeExistsCounter uint64
	ExistsMock          mPatchableValuesCollectorMockExists

	funcGet          func(path string) (r1 gjson.Result)
	funcGetOrigin    string
	inspectFuncGet   func(path string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mPatchableValuesCollectorMockGet

	funcGetOk          func(path string) (r1 gjson.Result, b1 bool)
	funcGetOkOrigin    string
	inspectFuncGetOk   func(path string)
	afterGetOkCounter  uint64
	beforeGetOkCounter uint64
	GetOkMock          mPatchableValuesCollectorMockGetOk

	funcGetPatches          func() (vpa1 []*utils.ValuesPatchOperation)
	funcGetPatchesOrigin    string
	inspectFuncGetPatches   func()
	afterGetPatchesCounter  uint64
	beforeGetPatchesCounter uint64
	GetPatchesMock          mPatchableValuesCollectorMockGetPatches

	funcGetRaw          func(path string) (a1 any)
	funcGetRawOrigin    string
	inspectFuncGetRaw   func(path string)
	afterGetRawCounter  uint64
	beforeGetRawCounter uint64
	GetRawMock          mPatchableValuesCollectorMockGetRaw

	funcRemove          func(path string)
	funcRemoveOrigin    string
	inspectFuncRemove   func(path string)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mPatchableValuesCollectorMockRemove

	funcSet          func(path string, value any)
	funcSetOrigin    string
	inspectFuncSet   func(path string, value any)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mPatchableValuesCollectorMockSet

	funcWriteOutput          func(writer io.Writer) (err error)
	funcWriteOutputOrigin    string
	inspectFuncWriteOutput   func(writer io.Writer)
	afterWriteOutputCounter  uint64
	beforeWriteOutputCounter uint64
	WriteOutputMock          mPatchableValuesCollectorMockWriteOutput
}

// NewPatchableValuesCollectorMock returns a mock for mm_pkg.PatchableValuesCollector
func NewPatchableValuesCollectorMock(t minimock.Tester) *PatchableValuesCollectorMock {
	m := &PatchableValuesCollectorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArrayCountMock = mPatchableValuesCollectorMockArrayCount{mock: m}
	m.ArrayCountMock.callArgs = []*PatchableValuesCollectorMockArrayCountParams{}

	m.ExistsMock = mPatchableValuesCollectorMockExists{mock: m}
	m.ExistsMock.callArgs = []*PatchableValuesCollectorMockExistsParams{}

	m.GetMock = mPatchableValuesCollectorMockGet{mock: m}
	m.GetMock.callArgs = []*PatchableValuesCollectorMockGetParams{}

	m.GetOkMock = mPatchableValuesCollectorMockGetOk{mock: m}
	m.GetOkMock.callArgs = []*PatchableValuesCollectorMockGetOkParams{}

	m.GetPatchesMock = mPatchableValuesCollectorMockGetPatches{mock: m}

	m.GetRawMock = mPatchableValuesCollectorMockGetRaw{mock: m}
	m.GetRawMock.callArgs = []*PatchableValuesCollectorMockGetRawParams{}

	m.RemoveMock = mPatchableValuesCollectorMockRemove{mock: m}
	m.RemoveMock.callArgs = []*PatchableValuesCollectorMockRemoveParams{}

	m.SetMock = mPatchableValuesCollectorMockSet{mock: m}
	m.SetMock.callArgs = []*PatchableValuesCollectorMockSetParams{}

	m.WriteOutputMock = mPatchableValuesCollectorMockWriteOutput{mock: m}
	m.WriteOutputMock.callArgs = []*PatchableValuesCollectorMockWriteOutputParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPatchableValuesCollectorMockArrayCount struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockArrayCountExpectation
	expectations       []*PatchableValuesCollectorMockArrayCountExpectation

	callArgs []*PatchableValuesCollectorMockArrayCountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockArrayCountExpectation specifies expectation struct of the PatchableValuesCollector.ArrayCount
type PatchableValuesCollectorMockArrayCountExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockArrayCountParams
	paramPtrs          *PatchableValuesCollectorMockArrayCountParamPtrs
	expectationOrigins PatchableValuesCollectorMockArrayCountExpectationOrigins
	results            *PatchableValuesCollectorMockArrayCountResults
	returnOrigin       string
	Counter            uint64
}

// PatchableValuesCollectorMockArrayCountParams contains parameters of the PatchableValuesCollector.ArrayCount
type PatchableValuesCollectorMockArrayCountParams struct {
	path string
}

// PatchableValuesCollectorMockArrayCountParamPtrs contains pointers to parameters of the PatchableValuesCollector.ArrayCount
type PatchableValuesCollectorMockArrayCountParamPtrs struct {
	path *string
}

// PatchableValuesCollectorMockArrayCountResults contains results of the PatchableValuesCollector.ArrayCount
type PatchableValuesCollectorMockArrayCountResults struct {
	i1  int
	err error
}

// PatchableValuesCollectorMockArrayCountOrigins contains origins of expectations of the PatchableValuesCollector.ArrayCount
type PatchableValuesCollectorMockArrayCountExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) Optional() *mPatchableValuesCollectorMockArrayCount {
	mmArrayCount.optional = true
	return mmArrayCount
}

// Expect sets up expected params for PatchableValuesCollector.ArrayCount
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) Expect(path string) *mPatchableValuesCollectorMockArrayCount {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("PatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	if mmArrayCount.defaultExpectation == nil {
		mmArrayCount.defaultExpectation = &PatchableValuesCollectorMockArrayCountExpectation{}
	}

	if mmArrayCount.defaultExpectation.paramPtrs != nil {
		mmArrayCount.mock.t.Fatalf("PatchableValuesCollectorMock.ArrayCount mock is already set by ExpectParams functions")
	}

	mmArrayCount.defaultExpectation.params = &PatchableValuesCollectorMockArrayCountParams{path}
	mmArrayCount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmArrayCount.expectations {
		if minimock.Equal(e.params, mmArrayCount.defaultExpectation.params) {
			mmArrayCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmArrayCount.defaultExpectation.params)
		}
	}

	return mmArrayCount
}

// ExpectPathParam1 sets up expected param path for PatchableValuesCollector.ArrayCount
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) ExpectPathParam1(path string) *mPatchableValuesCollectorMockArrayCount {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("PatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	if mmArrayCount.defaultExpectation == nil {
		mmArrayCount.defaultExpectation = &PatchableValuesCollectorMockArrayCountExpectation{}
	}

	if mmArrayCount.defaultExpectation.params != nil {
		mmArrayCount.mock.t.Fatalf("PatchableValuesCollectorMock.ArrayCount mock is already set by Expect")
	}

	if mmArrayCount.defaultExpectation.paramPtrs == nil {
		mmArrayCount.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockArrayCountParamPtrs{}
	}
	mmArrayCount.defaultExpectation.paramPtrs.path = &path
	mmArrayCount.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmArrayCount
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.ArrayCount
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) Inspect(f func(path string)) *mPatchableValuesCollectorMockArrayCount {
	if mmArrayCount.mock.inspectFuncArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.ArrayCount")
	}

	mmArrayCount.mock.inspectFuncArrayCount = f

	return mmArrayCount
}

// Return sets up results that will be returned by PatchableValuesCollector.ArrayCount
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) Return(i1 int, err error) *PatchableValuesCollectorMock {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("PatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	if mmArrayCount.defaultExpectation == nil {
		mmArrayCount.defaultExpectation = &PatchableValuesCollectorMockArrayCountExpectation{mock: mmArrayCount.mock}
	}
	mmArrayCount.defaultExpectation.results = &PatchableValuesCollectorMockArrayCountResults{i1, err}
	mmArrayCount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmArrayCount.mock
}

// Set uses given function f to mock the PatchableValuesCollector.ArrayCount method
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) Set(f func(path string) (i1 int, err error)) *PatchableValuesCollectorMock {
	if mmArrayCount.defaultExpectation != nil {
		mmArrayCount.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.ArrayCount method")
	}

	if len(mmArrayCount.expectations) > 0 {
		mmArrayCount.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.ArrayCount method")
	}

	mmArrayCount.mock.funcArrayCount = f
	mmArrayCount.mock.funcArrayCountOrigin = minimock.CallerInfo(1)
	return mmArrayCount.mock
}

// When sets expectation for the PatchableValuesCollector.ArrayCount which will trigger the result defined by the following
// Then helper
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) When(path string) *PatchableValuesCollectorMockArrayCountExpectation {
	if mmArrayCount.mock.funcArrayCount != nil {
		mmArrayCount.mock.t.Fatalf("PatchableValuesCollectorMock.ArrayCount mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockArrayCountExpectation{
		mock:               mmArrayCount.mock,
		params:             &PatchableValuesCollectorMockArrayCountParams{path},
		expectationOrigins: PatchableValuesCollectorMockArrayCountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmArrayCount.expectations = append(mmArrayCount.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.ArrayCount return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockArrayCountExpectation) Then(i1 int, err error) *PatchableValuesCollectorMock {
	e.results = &PatchableValuesCollectorMockArrayCountResults{i1, err}
	return e.mock
}

// Times sets number of times PatchableValuesCollector.ArrayCount should be invoked
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) Times(n uint64) *mPatchableValuesCollectorMockArrayCount {
	if n == 0 {
		mmArrayCount.mock.t.Fatalf("Times of PatchableValuesCollectorMock.ArrayCount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmArrayCount.expectedInvocations, n)
	mmArrayCount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmArrayCount
}

func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) invocationsDone() bool {
	if len(mmArrayCount.expectations) == 0 && mmArrayCount.defaultExpectation == nil && mmArrayCount.mock.funcArrayCount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmArrayCount.mock.afterArrayCountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmArrayCount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ArrayCount implements mm_pkg.PatchableValuesCollector
func (mmArrayCount *PatchableValuesCollectorMock) ArrayCount(path string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmArrayCount.beforeArrayCountCounter, 1)
	defer mm_atomic.AddUint64(&mmArrayCount.afterArrayCountCounter, 1)

	mmArrayCount.t.Helper()

	if mmArrayCount.inspectFuncArrayCount != nil {
		mmArrayCount.inspectFuncArrayCount(path)
	}

	mm_params := PatchableValuesCollectorMockArrayCountParams{path}

	// Record call args
	mmArrayCount.ArrayCountMock.mutex.Lock()
	mmArrayCount.ArrayCountMock.callArgs = append(mmArrayCount.ArrayCountMock.callArgs, &mm_params)
	mmArrayCount.ArrayCountMock.mutex.Unlock()

	for _, e := range mmArrayCount.ArrayCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmArrayCount.ArrayCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArrayCount.ArrayCountMock.defaultExpectation.Counter, 1)
		mm_want := mmArrayCount.ArrayCountMock.defaultExpectation.params
		mm_want_ptrs := mmArrayCount.ArrayCountMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockArrayCountParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmArrayCount.t.Errorf("PatchableValuesCollectorMock.ArrayCount got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmArrayCount.ArrayCountMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmArrayCount.t.Errorf("PatchableValuesCollectorMock.ArrayCount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmArrayCount.ArrayCountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmArrayCount.ArrayCountMock.defaultExpectation.results
		if mm_results == nil {
			mmArrayCount.t.Fatal("No results are set for the PatchableValuesCollectorMock.ArrayCount")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmArrayCount.funcArrayCount != nil {
		return mmArrayCount.funcArrayCount(path)
	}
	mmArrayCount.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.ArrayCount. %v", path)
	return
}

// ArrayCountAfterCounter returns a count of finished PatchableValuesCollectorMock.ArrayCount invocations
func (mmArrayCount *PatchableValuesCollectorMock) ArrayCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArrayCount.afterArrayCountCounter)
}

// ArrayCountBeforeCounter returns a count of PatchableValuesCollectorMock.ArrayCount invocations
func (mmArrayCount *PatchableValuesCollectorMock) ArrayCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArrayCount.beforeArrayCountCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.ArrayCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmArrayCount *mPatchableValuesCollectorMockArrayCount) Calls() []*PatchableValuesCollectorMockArrayCountParams {
	mmArrayCount.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockArrayCountParams, len(mmArrayCount.callArgs))
	copy(argCopy, mmArrayCount.callArgs)

	mmArrayCount.mutex.RUnlock()

	return argCopy
}

// MinimockArrayCountDone returns true if the count of the ArrayCount invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockArrayCountDone() bool {
	if m.ArrayCountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ArrayCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ArrayCountMock.invocationsDone()
}

// MinimockArrayCountInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockArrayCountInspect() {
	for _, e := range m.ArrayCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.ArrayCount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterArrayCountCounter := mm_atomic.LoadUint64(&m.afterArrayCountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ArrayCountMock.defaultExpectation != nil && afterArrayCountCounter < 1 {
		if m.ArrayCountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.ArrayCount at\n%s", m.ArrayCountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.ArrayCount at\n%s with params: %#v", m.ArrayCountMock.defaultExpectation.expectationOrigins.origin, *m.ArrayCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArrayCount != nil && afterArrayCountCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.ArrayCount at\n%s", m.funcArrayCountOrigin)
	}

	if !m.ArrayCountMock.invocationsDone() && afterArrayCountCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.ArrayCount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ArrayCountMock.expectedInvocations), m.ArrayCountMock.expectedInvocationsOrigin, afterArrayCountCounter)
	}
}

type mPatchableValuesCollectorMockExists struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockExistsExpectation
	expectations       []*PatchableValuesCollectorMockExistsExpectation

	callArgs []*PatchableValuesCollectorMockExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockExistsExpectation specifies expectation struct of the PatchableValuesCollector.Exists
type PatchableValuesCollectorMockExistsExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockExistsParams
	paramPtrs          *PatchableValuesCollectorMockExistsParamPtrs
	expectationOrigins PatchableValuesCollectorMockExistsExpectationOrigins
	results            *PatchableValuesCollectorMockExistsResults
	returnOrigin       string
	Counter            uint64
}

// PatchableValuesCollectorMockExistsParams contains parameters of the PatchableValuesCollector.Exists
type PatchableValuesCollectorMockExistsParams struct {
	path string
}

// PatchableValuesCollectorMockExistsParamPtrs contains pointers to parameters of the PatchableValuesCollector.Exists
type PatchableValuesCollectorMockExistsParamPtrs struct {
	path *string
}

// PatchableValuesCollectorMockExistsResults contains results of the PatchableValuesCollector.Exists
type PatchableValuesCollectorMockExistsResults struct {
	b1 bool
}

// PatchableValuesCollectorMockExistsOrigins contains origins of expectations of the PatchableValuesCollector.Exists
type PatchableValuesCollectorMockExistsExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExists *mPatchableValuesCollectorMockExists) Optional() *mPatchableValuesCollectorMockExists {
	mmExists.optional = true
	return mmExists
}

// Expect sets up expected params for PatchableValuesCollector.Exists
func (mmExists *mPatchableValuesCollectorMockExists) Expect(path string) *mPatchableValuesCollectorMockExists {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("PatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &PatchableValuesCollectorMockExistsExpectation{}
	}

	if mmExists.defaultExpectation.paramPtrs != nil {
		mmExists.mock.t.Fatalf("PatchableValuesCollectorMock.Exists mock is already set by ExpectParams functions")
	}

	mmExists.defaultExpectation.params = &PatchableValuesCollectorMockExistsParams{path}
	mmExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExists.expectations {
		if minimock.Equal(e.params, mmExists.defaultExpectation.params) {
			mmExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExists.defaultExpectation.params)
		}
	}

	return mmExists
}

// ExpectPathParam1 sets up expected param path for PatchableValuesCollector.Exists
func (mmExists *mPatchableValuesCollectorMockExists) ExpectPathParam1(path string) *mPatchableValuesCollectorMockExists {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("PatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &PatchableValuesCollectorMockExistsExpectation{}
	}

	if mmExists.defaultExpectation.params != nil {
		mmExists.mock.t.Fatalf("PatchableValuesCollectorMock.Exists mock is already set by Expect")
	}

	if mmExists.defaultExpectation.paramPtrs == nil {
		mmExists.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockExistsParamPtrs{}
	}
	mmExists.defaultExpectation.paramPtrs.path = &path
	mmExists.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmExists
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.Exists
func (mmExists *mPatchableValuesCollectorMockExists) Inspect(f func(path string)) *mPatchableValuesCollectorMockExists {
	if mmExists.mock.inspectFuncExists != nil {
		mmExists.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.Exists")
	}

	mmExists.mock.inspectFuncExists = f

	return mmExists
}

// Return sets up results that will be returned by PatchableValuesCollector.Exists
func (mmExists *mPatchableValuesCollectorMockExists) Return(b1 bool) *PatchableValuesCollectorMock {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("PatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &PatchableValuesCollectorMockExistsExpectation{mock: mmExists.mock}
	}
	mmExists.defaultExpectation.results = &PatchableValuesCollectorMockExistsResults{b1}
	mmExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExists.mock
}

// Set uses given function f to mock the PatchableValuesCollector.Exists method
func (mmExists *mPatchableValuesCollectorMockExists) Set(f func(path string) (b1 bool)) *PatchableValuesCollectorMock {
	if mmExists.defaultExpectation != nil {
		mmExists.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.Exists method")
	}

	if len(mmExists.expectations) > 0 {
		mmExists.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.Exists method")
	}

	mmExists.mock.funcExists = f
	mmExists.mock.funcExistsOrigin = minimock.CallerInfo(1)
	return mmExists.mock
}

// When sets expectation for the PatchableValuesCollector.Exists which will trigger the result defined by the following
// Then helper
func (mmExists *mPatchableValuesCollectorMockExists) When(path string) *PatchableValuesCollectorMockExistsExpectation {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("PatchableValuesCollectorMock.Exists mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockExistsExpectation{
		mock:               mmExists.mock,
		params:             &PatchableValuesCollectorMockExistsParams{path},
		expectationOrigins: PatchableValuesCollectorMockExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExists.expectations = append(mmExists.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.Exists return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockExistsExpectation) Then(b1 bool) *PatchableValuesCollectorMock {
	e.results = &PatchableValuesCollectorMockExistsResults{b1}
	return e.mock
}

// Times sets number of times PatchableValuesCollector.Exists should be invoked
func (mmExists *mPatchableValuesCollectorMockExists) Times(n uint64) *mPatchableValuesCollectorMockExists {
	if n == 0 {
		mmExists.mock.t.Fatalf("Times of PatchableValuesCollectorMock.Exists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExists.expectedInvocations, n)
	mmExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExists
}

func (mmExists *mPatchableValuesCollectorMockExists) invocationsDone() bool {
	if len(mmExists.expectations) == 0 && mmExists.defaultExpectation == nil && mmExists.mock.funcExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExists.mock.afterExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exists implements mm_pkg.PatchableValuesCollector
func (mmExists *PatchableValuesCollectorMock) Exists(path string) (b1 bool) {
	mm_atomic.AddUint64(&mmExists.beforeExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmExists.afterExistsCounter, 1)

	mmExists.t.Helper()

	if mmExists.inspectFuncExists != nil {
		mmExists.inspectFuncExists(path)
	}

	mm_params := PatchableValuesCollectorMockExistsParams{path}

	// Record call args
	mmExists.ExistsMock.mutex.Lock()
	mmExists.ExistsMock.callArgs = append(mmExists.ExistsMock.callArgs, &mm_params)
	mmExists.ExistsMock.mutex.Unlock()

	for _, e := range mmExists.ExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmExists.ExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExists.ExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmExists.ExistsMock.defaultExpectation.params
		mm_want_ptrs := mmExists.ExistsMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockExistsParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmExists.t.Errorf("PatchableValuesCollectorMock.Exists got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExists.ExistsMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExists.t.Errorf("PatchableValuesCollectorMock.Exists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExists.ExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExists.ExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmExists.t.Fatal("No results are set for the PatchableValuesCollectorMock.Exists")
		}
		return (*mm_results).b1
	}
	if mmExists.funcExists != nil {
		return mmExists.funcExists(path)
	}
	mmExists.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.Exists. %v", path)
	return
}

// ExistsAfterCounter returns a count of finished PatchableValuesCollectorMock.Exists invocations
func (mmExists *PatchableValuesCollectorMock) ExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExists.afterExistsCounter)
}

// ExistsBeforeCounter returns a count of PatchableValuesCollectorMock.Exists invocations
func (mmExists *PatchableValuesCollectorMock) ExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExists.beforeExistsCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.Exists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExists *mPatchableValuesCollectorMockExists) Calls() []*PatchableValuesCollectorMockExistsParams {
	mmExists.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockExistsParams, len(mmExists.callArgs))
	copy(argCopy, mmExists.callArgs)

	mmExists.mutex.RUnlock()

	return argCopy
}

// MinimockExistsDone returns true if the count of the Exists invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockExistsDone() bool {
	if m.ExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExistsMock.invocationsDone()
}

// MinimockExistsInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockExistsInspect() {
	for _, e := range m.ExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Exists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExistsCounter := mm_atomic.LoadUint64(&m.afterExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExistsMock.defaultExpectation != nil && afterExistsCounter < 1 {
		if m.ExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Exists at\n%s", m.ExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Exists at\n%s with params: %#v", m.ExistsMock.defaultExpectation.expectationOrigins.origin, *m.ExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExists != nil && afterExistsCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.Exists at\n%s", m.funcExistsOrigin)
	}

	if !m.ExistsMock.invocationsDone() && afterExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.Exists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExistsMock.expectedInvocations), m.ExistsMock.expectedInvocationsOrigin, afterExistsCounter)
	}
}

type mPatchableValuesCollectorMockGet struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockGetExpectation
	expectations       []*PatchableValuesCollectorMockGetExpectation

	callArgs []*PatchableValuesCollectorMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockGetExpectation specifies expectation struct of the PatchableValuesCollector.Get
type PatchableValuesCollectorMockGetExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockGetParams
	paramPtrs          *PatchableValuesCollectorMockGetParamPtrs
	expectationOrigins PatchableValuesCollectorMockGetExpectationOrigins
	results            *PatchableValuesCollectorMockGetResults
	returnOrigin       string
	Counter            uint64
}

// PatchableValuesCollectorMockGetParams contains parameters of the PatchableValuesCollector.Get
type PatchableValuesCollectorMockGetParams struct {
	path string
}

// PatchableValuesCollectorMockGetParamPtrs contains pointers to parameters of the PatchableValuesCollector.Get
type PatchableValuesCollectorMockGetParamPtrs struct {
	path *string
}

// PatchableValuesCollectorMockGetResults contains results of the PatchableValuesCollector.Get
type PatchableValuesCollectorMockGetResults struct {
	r1 gjson.Result
}

// PatchableValuesCollectorMockGetOrigins contains origins of expectations of the PatchableValuesCollector.Get
type PatchableValuesCollectorMockGetExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mPatchableValuesCollectorMockGet) Optional() *mPatchableValuesCollectorMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for PatchableValuesCollector.Get
func (mmGet *mPatchableValuesCollectorMockGet) Expect(path string) *mPatchableValuesCollectorMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PatchableValuesCollectorMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PatchableValuesCollectorMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("PatchableValuesCollectorMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &PatchableValuesCollectorMockGetParams{path}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectPathParam1 sets up expected param path for PatchableValuesCollector.Get
func (mmGet *mPatchableValuesCollectorMockGet) ExpectPathParam1(path string) *mPatchableValuesCollectorMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PatchableValuesCollectorMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PatchableValuesCollectorMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("PatchableValuesCollectorMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.path = &path
	mmGet.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.Get
func (mmGet *mPatchableValuesCollectorMockGet) Inspect(f func(path string)) *mPatchableValuesCollectorMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by PatchableValuesCollector.Get
func (mmGet *mPatchableValuesCollectorMockGet) Return(r1 gjson.Result) *PatchableValuesCollectorMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PatchableValuesCollectorMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PatchableValuesCollectorMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &PatchableValuesCollectorMockGetResults{r1}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the PatchableValuesCollector.Get method
func (mmGet *mPatchableValuesCollectorMockGet) Set(f func(path string) (r1 gjson.Result)) *PatchableValuesCollectorMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the PatchableValuesCollector.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mPatchableValuesCollectorMockGet) When(path string) *PatchableValuesCollectorMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PatchableValuesCollectorMock.Get mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockGetExpectation{
		mock:               mmGet.mock,
		params:             &PatchableValuesCollectorMockGetParams{path},
		expectationOrigins: PatchableValuesCollectorMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.Get return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockGetExpectation) Then(r1 gjson.Result) *PatchableValuesCollectorMock {
	e.results = &PatchableValuesCollectorMockGetResults{r1}
	return e.mock
}

// Times sets number of times PatchableValuesCollector.Get should be invoked
func (mmGet *mPatchableValuesCollectorMockGet) Times(n uint64) *mPatchableValuesCollectorMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of PatchableValuesCollectorMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mPatchableValuesCollectorMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_pkg.PatchableValuesCollector
func (mmGet *PatchableValuesCollectorMock) Get(path string) (r1 gjson.Result) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(path)
	}

	mm_params := PatchableValuesCollectorMockGetParams{path}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockGetParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmGet.t.Errorf("PatchableValuesCollectorMock.Get got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("PatchableValuesCollectorMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the PatchableValuesCollectorMock.Get")
		}
		return (*mm_results).r1
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(path)
	}
	mmGet.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.Get. %v", path)
	return
}

// GetAfterCounter returns a count of finished PatchableValuesCollectorMock.Get invocations
func (mmGet *PatchableValuesCollectorMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of PatchableValuesCollectorMock.Get invocations
func (mmGet *PatchableValuesCollectorMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mPatchableValuesCollectorMockGet) Calls() []*PatchableValuesCollectorMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mPatchableValuesCollectorMockGetOk struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockGetOkExpectation
	expectations       []*PatchableValuesCollectorMockGetOkExpectation

	callArgs []*PatchableValuesCollectorMockGetOkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockGetOkExpectation specifies expectation struct of the PatchableValuesCollector.GetOk
type PatchableValuesCollectorMockGetOkExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockGetOkParams
	paramPtrs          *PatchableValuesCollectorMockGetOkParamPtrs
	expectationOrigins PatchableValuesCollectorMockGetOkExpectationOrigins
	results            *PatchableValuesCollectorMockGetOkResults
	returnOrigin       string
	Counter            uint64
}

// PatchableValuesCollectorMockGetOkParams contains parameters of the PatchableValuesCollector.GetOk
type PatchableValuesCollectorMockGetOkParams struct {
	path string
}

// PatchableValuesCollectorMockGetOkParamPtrs contains pointers to parameters of the PatchableValuesCollector.GetOk
type PatchableValuesCollectorMockGetOkParamPtrs struct {
	path *string
}

// PatchableValuesCollectorMockGetOkResults contains results of the PatchableValuesCollector.GetOk
type PatchableValuesCollectorMockGetOkResults struct {
	r1 gjson.Result
	b1 bool
}

// PatchableValuesCollectorMockGetOkOrigins contains origins of expectations of the PatchableValuesCollector.GetOk
type PatchableValuesCollectorMockGetOkExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOk *mPatchableValuesCollectorMockGetOk) Optional() *mPatchableValuesCollectorMockGetOk {
	mmGetOk.optional = true
	return mmGetOk
}

// Expect sets up expected params for PatchableValuesCollector.GetOk
func (mmGetOk *mPatchableValuesCollectorMockGetOk) Expect(path string) *mPatchableValuesCollectorMockGetOk {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("PatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	if mmGetOk.defaultExpectation == nil {
		mmGetOk.defaultExpectation = &PatchableValuesCollectorMockGetOkExpectation{}
	}

	if mmGetOk.defaultExpectation.paramPtrs != nil {
		mmGetOk.mock.t.Fatalf("PatchableValuesCollectorMock.GetOk mock is already set by ExpectParams functions")
	}

	mmGetOk.defaultExpectation.params = &PatchableValuesCollectorMockGetOkParams{path}
	mmGetOk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOk.expectations {
		if minimock.Equal(e.params, mmGetOk.defaultExpectation.params) {
			mmGetOk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOk.defaultExpectation.params)
		}
	}

	return mmGetOk
}

// ExpectPathParam1 sets up expected param path for PatchableValuesCollector.GetOk
func (mmGetOk *mPatchableValuesCollectorMockGetOk) ExpectPathParam1(path string) *mPatchableValuesCollectorMockGetOk {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("PatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	if mmGetOk.defaultExpectation == nil {
		mmGetOk.defaultExpectation = &PatchableValuesCollectorMockGetOkExpectation{}
	}

	if mmGetOk.defaultExpectation.params != nil {
		mmGetOk.mock.t.Fatalf("PatchableValuesCollectorMock.GetOk mock is already set by Expect")
	}

	if mmGetOk.defaultExpectation.paramPtrs == nil {
		mmGetOk.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockGetOkParamPtrs{}
	}
	mmGetOk.defaultExpectation.paramPtrs.path = &path
	mmGetOk.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmGetOk
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.GetOk
func (mmGetOk *mPatchableValuesCollectorMockGetOk) Inspect(f func(path string)) *mPatchableValuesCollectorMockGetOk {
	if mmGetOk.mock.inspectFuncGetOk != nil {
		mmGetOk.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.GetOk")
	}

	mmGetOk.mock.inspectFuncGetOk = f

	return mmGetOk
}

// Return sets up results that will be returned by PatchableValuesCollector.GetOk
func (mmGetOk *mPatchableValuesCollectorMockGetOk) Return(r1 gjson.Result, b1 bool) *PatchableValuesCollectorMock {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("PatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	if mmGetOk.defaultExpectation == nil {
		mmGetOk.defaultExpectation = &PatchableValuesCollectorMockGetOkExpectation{mock: mmGetOk.mock}
	}
	mmGetOk.defaultExpectation.results = &PatchableValuesCollectorMockGetOkResults{r1, b1}
	mmGetOk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOk.mock
}

// Set uses given function f to mock the PatchableValuesCollector.GetOk method
func (mmGetOk *mPatchableValuesCollectorMockGetOk) Set(f func(path string) (r1 gjson.Result, b1 bool)) *PatchableValuesCollectorMock {
	if mmGetOk.defaultExpectation != nil {
		mmGetOk.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.GetOk method")
	}

	if len(mmGetOk.expectations) > 0 {
		mmGetOk.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.GetOk method")
	}

	mmGetOk.mock.funcGetOk = f
	mmGetOk.mock.funcGetOkOrigin = minimock.CallerInfo(1)
	return mmGetOk.mock
}

// When sets expectation for the PatchableValuesCollector.GetOk which will trigger the result defined by the following
// Then helper
func (mmGetOk *mPatchableValuesCollectorMockGetOk) When(path string) *PatchableValuesCollectorMockGetOkExpectation {
	if mmGetOk.mock.funcGetOk != nil {
		mmGetOk.mock.t.Fatalf("PatchableValuesCollectorMock.GetOk mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockGetOkExpectation{
		mock:               mmGetOk.mock,
		params:             &PatchableValuesCollectorMockGetOkParams{path},
		expectationOrigins: PatchableValuesCollectorMockGetOkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOk.expectations = append(mmGetOk.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.GetOk return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockGetOkExpectation) Then(r1 gjson.Result, b1 bool) *PatchableValuesCollectorMock {
	e.results = &PatchableValuesCollectorMockGetOkResults{r1, b1}
	return e.mock
}

// Times sets number of times PatchableValuesCollector.GetOk should be invoked
func (mmGetOk *mPatchableValuesCollectorMockGetOk) Times(n uint64) *mPatchableValuesCollectorMockGetOk {
	if n == 0 {
		mmGetOk.mock.t.Fatalf("Times of PatchableValuesCollectorMock.GetOk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOk.expectedInvocations, n)
	mmGetOk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOk
}

func (mmGetOk *mPatchableValuesCollectorMockGetOk) invocationsDone() bool {
	if len(mmGetOk.expectations) == 0 && mmGetOk.defaultExpectation == nil && mmGetOk.mock.funcGetOk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOk.mock.afterGetOkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOk implements mm_pkg.PatchableValuesCollector
func (mmGetOk *PatchableValuesCollectorMock) GetOk(path string) (r1 gjson.Result, b1 bool) {
	mm_atomic.AddUint64(&mmGetOk.beforeGetOkCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOk.afterGetOkCounter, 1)

	mmGetOk.t.Helper()

	if mmGetOk.inspectFuncGetOk != nil {
		mmGetOk.inspectFuncGetOk(path)
	}

	mm_params := PatchableValuesCollectorMockGetOkParams{path}

	// Record call args
	mmGetOk.GetOkMock.mutex.Lock()
	mmGetOk.GetOkMock.callArgs = append(mmGetOk.GetOkMock.callArgs, &mm_params)
	mmGetOk.GetOkMock.mutex.Unlock()

	for _, e := range mmGetOk.GetOkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.b1
		}
	}

	if mmGetOk.GetOkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOk.GetOkMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOk.GetOkMock.defaultExpectation.params
		mm_want_ptrs := mmGetOk.GetOkMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockGetOkParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmGetOk.t.Errorf("PatchableValuesCollectorMock.GetOk got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOk.GetOkMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOk.t.Errorf("PatchableValuesCollectorMock.GetOk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOk.GetOkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOk.GetOkMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOk.t.Fatal("No results are set for the PatchableValuesCollectorMock.GetOk")
		}
		return (*mm_results).r1, (*mm_results).b1
	}
	if mmGetOk.funcGetOk != nil {
		return mmGetOk.funcGetOk(path)
	}
	mmGetOk.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.GetOk. %v", path)
	return
}

// GetOkAfterCounter returns a count of finished PatchableValuesCollectorMock.GetOk invocations
func (mmGetOk *PatchableValuesCollectorMock) GetOkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOk.afterGetOkCounter)
}

// GetOkBeforeCounter returns a count of PatchableValuesCollectorMock.GetOk invocations
func (mmGetOk *PatchableValuesCollectorMock) GetOkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOk.beforeGetOkCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.GetOk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOk *mPatchableValuesCollectorMockGetOk) Calls() []*PatchableValuesCollectorMockGetOkParams {
	mmGetOk.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockGetOkParams, len(mmGetOk.callArgs))
	copy(argCopy, mmGetOk.callArgs)

	mmGetOk.mutex.RUnlock()

	return argCopy
}

// MinimockGetOkDone returns true if the count of the GetOk invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockGetOkDone() bool {
	if m.GetOkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOkMock.invocationsDone()
}

// MinimockGetOkInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockGetOkInspect() {
	for _, e := range m.GetOkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetOk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOkCounter := mm_atomic.LoadUint64(&m.afterGetOkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOkMock.defaultExpectation != nil && afterGetOkCounter < 1 {
		if m.GetOkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetOk at\n%s", m.GetOkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetOk at\n%s with params: %#v", m.GetOkMock.defaultExpectation.expectationOrigins.origin, *m.GetOkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOk != nil && afterGetOkCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetOk at\n%s", m.funcGetOkOrigin)
	}

	if !m.GetOkMock.invocationsDone() && afterGetOkCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.GetOk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOkMock.expectedInvocations), m.GetOkMock.expectedInvocationsOrigin, afterGetOkCounter)
	}
}

type mPatchableValuesCollectorMockGetPatches struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockGetPatchesExpectation
	expectations       []*PatchableValuesCollectorMockGetPatchesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockGetPatchesExpectation specifies expectation struct of the PatchableValuesCollector.GetPatches
type PatchableValuesCollectorMockGetPatchesExpectation struct {
	mock *PatchableValuesCollectorMock

	results      *PatchableValuesCollectorMockGetPatchesResults
	returnOrigin string
	Counter      uint64
}

// PatchableValuesCollectorMockGetPatchesResults contains results of the PatchableValuesCollector.GetPatches
type PatchableValuesCollectorMockGetPatchesResults struct {
	vpa1 []*utils.ValuesPatchOperation
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPatches *mPatchableValuesCollectorMockGetPatches) Optional() *mPatchableValuesCollectorMockGetPatches {
	mmGetPatches.optional = true
	return mmGetPatches
}

// Expect sets up expected params for PatchableValuesCollector.GetPatches
func (mmGetPatches *mPatchableValuesCollectorMockGetPatches) Expect() *mPatchableValuesCollectorMockGetPatches {
	if mmGetPatches.mock.funcGetPatches != nil {
		mmGetPatches.mock.t.Fatalf("PatchableValuesCollectorMock.GetPatches mock is already set by Set")
	}

	if mmGetPatches.defaultExpectation == nil {
		mmGetPatches.defaultExpectation = &PatchableValuesCollectorMockGetPatchesExpectation{}
	}

	return mmGetPatches
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.GetPatches
func (mmGetPatches *mPatchableValuesCollectorMockGetPatches) Inspect(f func()) *mPatchableValuesCollectorMockGetPatches {
	if mmGetPatches.mock.inspectFuncGetPatches != nil {
		mmGetPatches.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.GetPatches")
	}

	mmGetPatches.mock.inspectFuncGetPatches = f

	return mmGetPatches
}

// Return sets up results that will be returned by PatchableValuesCollector.GetPatches
func (mmGetPatches *mPatchableValuesCollectorMockGetPatches) Return(vpa1 []*utils.ValuesPatchOperation) *PatchableValuesCollectorMock {
	if mmGetPatches.mock.funcGetPatches != nil {
		mmGetPatches.mock.t.Fatalf("PatchableValuesCollectorMock.GetPatches mock is already set by Set")
	}

	if mmGetPatches.defaultExpectation == nil {
		mmGetPatches.defaultExpectation = &PatchableValuesCollectorMockGetPatchesExpectation{mock: mmGetPatches.mock}
	}
	mmGetPatches.defaultExpectation.results = &PatchableValuesCollectorMockGetPatchesResults{vpa1}
	mmGetPatches.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPatches.mock
}

// Set uses given function f to mock the PatchableValuesCollector.GetPatches method
func (mmGetPatches *mPatchableValuesCollectorMockGetPatches) Set(f func() (vpa1 []*utils.ValuesPatchOperation)) *PatchableValuesCollectorMock {
	if mmGetPatches.defaultExpectation != nil {
		mmGetPatches.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.GetPatches method")
	}

	if len(mmGetPatches.expectations) > 0 {
		mmGetPatches.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.GetPatches method")
	}

	mmGetPatches.mock.funcGetPatches = f
	mmGetPatches.mock.funcGetPatchesOrigin = minimock.CallerInfo(1)
	return mmGetPatches.mock
}

// Times sets number of times PatchableValuesCollector.GetPatches should be invoked
func (mmGetPatches *mPatchableValuesCollectorMockGetPatches) Times(n uint64) *mPatchableValuesCollectorMockGetPatches {
	if n == 0 {
		mmGetPatches.mock.t.Fatalf("Times of PatchableValuesCollectorMock.GetPatches mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPatches.expectedInvocations, n)
	mmGetPatches.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPatches
}

func (mmGetPatches *mPatchableValuesCollectorMockGetPatches) invocationsDone() bool {
	if len(mmGetPatches.expectations) == 0 && mmGetPatches.defaultExpectation == nil && mmGetPatches.mock.funcGetPatches == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPatches.mock.afterGetPatchesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPatches.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPatches implements mm_pkg.PatchableValuesCollector
func (mmGetPatches *PatchableValuesCollectorMock) GetPatches() (vpa1 []*utils.ValuesPatchOperation) {
	mm_atomic.AddUint64(&mmGetPatches.beforeGetPatchesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPatches.afterGetPatchesCounter, 1)

	mmGetPatches.t.Helper()

	if mmGetPatches.inspectFuncGetPatches != nil {
		mmGetPatches.inspectFuncGetPatches()
	}

	if mmGetPatches.GetPatchesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPatches.GetPatchesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPatches.GetPatchesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPatches.t.Fatal("No results are set for the PatchableValuesCollectorMock.GetPatches")
		}
		return (*mm_results).vpa1
	}
	if mmGetPatches.funcGetPatches != nil {
		return mmGetPatches.funcGetPatches()
	}
	mmGetPatches.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.GetPatches.")
	return
}

// GetPatchesAfterCounter returns a count of finished PatchableValuesCollectorMock.GetPatches invocations
func (mmGetPatches *PatchableValuesCollectorMock) GetPatchesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPatches.afterGetPatchesCounter)
}

// GetPatchesBeforeCounter returns a count of PatchableValuesCollectorMock.GetPatches invocations
func (mmGetPatches *PatchableValuesCollectorMock) GetPatchesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPatches.beforeGetPatchesCounter)
}

// MinimockGetPatchesDone returns true if the count of the GetPatches invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockGetPatchesDone() bool {
	if m.GetPatchesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPatchesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPatchesMock.invocationsDone()
}

// MinimockGetPatchesInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockGetPatchesInspect() {
	for _, e := range m.GetPatchesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PatchableValuesCollectorMock.GetPatches")
		}
	}

	afterGetPatchesCounter := mm_atomic.LoadUint64(&m.afterGetPatchesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPatchesMock.defaultExpectation != nil && afterGetPatchesCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetPatches at\n%s", m.GetPatchesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPatches != nil && afterGetPatchesCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetPatches at\n%s", m.funcGetPatchesOrigin)
	}

	if !m.GetPatchesMock.invocationsDone() && afterGetPatchesCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.GetPatches at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPatchesMock.expectedInvocations), m.GetPatchesMock.expectedInvocationsOrigin, afterGetPatchesCounter)
	}
}

type mPatchableValuesCollectorMockGetRaw struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockGetRawExpectation
	expectations       []*PatchableValuesCollectorMockGetRawExpectation

	callArgs []*PatchableValuesCollectorMockGetRawParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockGetRawExpectation specifies expectation struct of the PatchableValuesCollector.GetRaw
type PatchableValuesCollectorMockGetRawExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockGetRawParams
	paramPtrs          *PatchableValuesCollectorMockGetRawParamPtrs
	expectationOrigins PatchableValuesCollectorMockGetRawExpectationOrigins
	results            *PatchableValuesCollectorMockGetRawResults
	returnOrigin       string
	Counter            uint64
}

// PatchableValuesCollectorMockGetRawParams contains parameters of the PatchableValuesCollector.GetRaw
type PatchableValuesCollectorMockGetRawParams struct {
	path string
}

// PatchableValuesCollectorMockGetRawParamPtrs contains pointers to parameters of the PatchableValuesCollector.GetRaw
type PatchableValuesCollectorMockGetRawParamPtrs struct {
	path *string
}

// PatchableValuesCollectorMockGetRawResults contains results of the PatchableValuesCollector.GetRaw
type PatchableValuesCollectorMockGetRawResults struct {
	a1 any
}

// PatchableValuesCollectorMockGetRawOrigins contains origins of expectations of the PatchableValuesCollector.GetRaw
type PatchableValuesCollectorMockGetRawExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) Optional() *mPatchableValuesCollectorMockGetRaw {
	mmGetRaw.optional = true
	return mmGetRaw
}

// Expect sets up expected params for PatchableValuesCollector.GetRaw
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) Expect(path string) *mPatchableValuesCollectorMockGetRaw {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("PatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	if mmGetRaw.defaultExpectation == nil {
		mmGetRaw.defaultExpectation = &PatchableValuesCollectorMockGetRawExpectation{}
	}

	if mmGetRaw.defaultExpectation.paramPtrs != nil {
		mmGetRaw.mock.t.Fatalf("PatchableValuesCollectorMock.GetRaw mock is already set by ExpectParams functions")
	}

	mmGetRaw.defaultExpectation.params = &PatchableValuesCollectorMockGetRawParams{path}
	mmGetRaw.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRaw.expectations {
		if minimock.Equal(e.params, mmGetRaw.defaultExpectation.params) {
			mmGetRaw.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRaw.defaultExpectation.params)
		}
	}

	return mmGetRaw
}

// ExpectPathParam1 sets up expected param path for PatchableValuesCollector.GetRaw
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) ExpectPathParam1(path string) *mPatchableValuesCollectorMockGetRaw {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("PatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	if mmGetRaw.defaultExpectation == nil {
		mmGetRaw.defaultExpectation = &PatchableValuesCollectorMockGetRawExpectation{}
	}

	if mmGetRaw.defaultExpectation.params != nil {
		mmGetRaw.mock.t.Fatalf("PatchableValuesCollectorMock.GetRaw mock is already set by Expect")
	}

	if mmGetRaw.defaultExpectation.paramPtrs == nil {
		mmGetRaw.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockGetRawParamPtrs{}
	}
	mmGetRaw.defaultExpectation.paramPtrs.path = &path
	mmGetRaw.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmGetRaw
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.GetRaw
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) Inspect(f func(path string)) *mPatchableValuesCollectorMockGetRaw {
	if mmGetRaw.mock.inspectFuncGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.GetRaw")
	}

	mmGetRaw.mock.inspectFuncGetRaw = f

	return mmGetRaw
}

// Return sets up results that will be returned by PatchableValuesCollector.GetRaw
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) Return(a1 any) *PatchableValuesCollectorMock {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("PatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	if mmGetRaw.defaultExpectation == nil {
		mmGetRaw.defaultExpectation = &PatchableValuesCollectorMockGetRawExpectation{mock: mmGetRaw.mock}
	}
	mmGetRaw.defaultExpectation.results = &PatchableValuesCollectorMockGetRawResults{a1}
	mmGetRaw.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRaw.mock
}

// Set uses given function f to mock the PatchableValuesCollector.GetRaw method
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) Set(f func(path string) (a1 any)) *PatchableValuesCollectorMock {
	if mmGetRaw.defaultExpectation != nil {
		mmGetRaw.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.GetRaw method")
	}

	if len(mmGetRaw.expectations) > 0 {
		mmGetRaw.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.GetRaw method")
	}

	mmGetRaw.mock.funcGetRaw = f
	mmGetRaw.mock.funcGetRawOrigin = minimock.CallerInfo(1)
	return mmGetRaw.mock
}

// When sets expectation for the PatchableValuesCollector.GetRaw which will trigger the result defined by the following
// Then helper
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) When(path string) *PatchableValuesCollectorMockGetRawExpectation {
	if mmGetRaw.mock.funcGetRaw != nil {
		mmGetRaw.mock.t.Fatalf("PatchableValuesCollectorMock.GetRaw mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockGetRawExpectation{
		mock:               mmGetRaw.mock,
		params:             &PatchableValuesCollectorMockGetRawParams{path},
		expectationOrigins: PatchableValuesCollectorMockGetRawExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRaw.expectations = append(mmGetRaw.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.GetRaw return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockGetRawExpectation) Then(a1 any) *PatchableValuesCollectorMock {
	e.results = &PatchableValuesCollectorMockGetRawResults{a1}
	return e.mock
}

// Times sets number of times PatchableValuesCollector.GetRaw should be invoked
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) Times(n uint64) *mPatchableValuesCollectorMockGetRaw {
	if n == 0 {
		mmGetRaw.mock.t.Fatalf("Times of PatchableValuesCollectorMock.GetRaw mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRaw.expectedInvocations, n)
	mmGetRaw.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRaw
}

func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) invocationsDone() bool {
	if len(mmGetRaw.expectations) == 0 && mmGetRaw.defaultExpectation == nil && mmGetRaw.mock.funcGetRaw == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRaw.mock.afterGetRawCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRaw.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRaw implements mm_pkg.PatchableValuesCollector
func (mmGetRaw *PatchableValuesCollectorMock) GetRaw(path string) (a1 any) {
	mm_atomic.AddUint64(&mmGetRaw.beforeGetRawCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRaw.afterGetRawCounter, 1)

	mmGetRaw.t.Helper()

	if mmGetRaw.inspectFuncGetRaw != nil {
		mmGetRaw.inspectFuncGetRaw(path)
	}

	mm_params := PatchableValuesCollectorMockGetRawParams{path}

	// Record call args
	mmGetRaw.GetRawMock.mutex.Lock()
	mmGetRaw.GetRawMock.callArgs = append(mmGetRaw.GetRawMock.callArgs, &mm_params)
	mmGetRaw.GetRawMock.mutex.Unlock()

	for _, e := range mmGetRaw.GetRawMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1
		}
	}

	if mmGetRaw.GetRawMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRaw.GetRawMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRaw.GetRawMock.defaultExpectation.params
		mm_want_ptrs := mmGetRaw.GetRawMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockGetRawParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmGetRaw.t.Errorf("PatchableValuesCollectorMock.GetRaw got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRaw.GetRawMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRaw.t.Errorf("PatchableValuesCollectorMock.GetRaw got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRaw.GetRawMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRaw.GetRawMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRaw.t.Fatal("No results are set for the PatchableValuesCollectorMock.GetRaw")
		}
		return (*mm_results).a1
	}
	if mmGetRaw.funcGetRaw != nil {
		return mmGetRaw.funcGetRaw(path)
	}
	mmGetRaw.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.GetRaw. %v", path)
	return
}

// GetRawAfterCounter returns a count of finished PatchableValuesCollectorMock.GetRaw invocations
func (mmGetRaw *PatchableValuesCollectorMock) GetRawAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRaw.afterGetRawCounter)
}

// GetRawBeforeCounter returns a count of PatchableValuesCollectorMock.GetRaw invocations
func (mmGetRaw *PatchableValuesCollectorMock) GetRawBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRaw.beforeGetRawCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.GetRaw.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRaw *mPatchableValuesCollectorMockGetRaw) Calls() []*PatchableValuesCollectorMockGetRawParams {
	mmGetRaw.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockGetRawParams, len(mmGetRaw.callArgs))
	copy(argCopy, mmGetRaw.callArgs)

	mmGetRaw.mutex.RUnlock()

	return argCopy
}

// MinimockGetRawDone returns true if the count of the GetRaw invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockGetRawDone() bool {
	if m.GetRawMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRawMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRawMock.invocationsDone()
}

// MinimockGetRawInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockGetRawInspect() {
	for _, e := range m.GetRawMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetRaw at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRawCounter := mm_atomic.LoadUint64(&m.afterGetRawCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRawMock.defaultExpectation != nil && afterGetRawCounter < 1 {
		if m.GetRawMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetRaw at\n%s", m.GetRawMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetRaw at\n%s with params: %#v", m.GetRawMock.defaultExpectation.expectationOrigins.origin, *m.GetRawMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRaw != nil && afterGetRawCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.GetRaw at\n%s", m.funcGetRawOrigin)
	}

	if !m.GetRawMock.invocationsDone() && afterGetRawCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.GetRaw at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRawMock.expectedInvocations), m.GetRawMock.expectedInvocationsOrigin, afterGetRawCounter)
	}
}

type mPatchableValuesCollectorMockRemove struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockRemoveExpectation
	expectations       []*PatchableValuesCollectorMockRemoveExpectation

	callArgs []*PatchableValuesCollectorMockRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockRemoveExpectation specifies expectation struct of the PatchableValuesCollector.Remove
type PatchableValuesCollectorMockRemoveExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockRemoveParams
	paramPtrs          *PatchableValuesCollectorMockRemoveParamPtrs
	expectationOrigins PatchableValuesCollectorMockRemoveExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchableValuesCollectorMockRemoveParams contains parameters of the PatchableValuesCollector.Remove
type PatchableValuesCollectorMockRemoveParams struct {
	path string
}

// PatchableValuesCollectorMockRemoveParamPtrs contains pointers to parameters of the PatchableValuesCollector.Remove
type PatchableValuesCollectorMockRemoveParamPtrs struct {
	path *string
}

// PatchableValuesCollectorMockRemoveOrigins contains origins of expectations of the PatchableValuesCollector.Remove
type PatchableValuesCollectorMockRemoveExpectationOrigins struct {
	origin     string
	originPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemove *mPatchableValuesCollectorMockRemove) Optional() *mPatchableValuesCollectorMockRemove {
	mmRemove.optional = true
	return mmRemove
}

// Expect sets up expected params for PatchableValuesCollector.Remove
func (mmRemove *mPatchableValuesCollectorMockRemove) Expect(path string) *mPatchableValuesCollectorMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("PatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &PatchableValuesCollectorMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.paramPtrs != nil {
		mmRemove.mock.t.Fatalf("PatchableValuesCollectorMock.Remove mock is already set by ExpectParams functions")
	}

	mmRemove.defaultExpectation.params = &PatchableValuesCollectorMockRemoveParams{path}
	mmRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// ExpectPathParam1 sets up expected param path for PatchableValuesCollector.Remove
func (mmRemove *mPatchableValuesCollectorMockRemove) ExpectPathParam1(path string) *mPatchableValuesCollectorMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("PatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &PatchableValuesCollectorMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("PatchableValuesCollectorMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.path = &path
	mmRemove.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.Remove
func (mmRemove *mPatchableValuesCollectorMockRemove) Inspect(f func(path string)) *mPatchableValuesCollectorMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by PatchableValuesCollector.Remove
func (mmRemove *mPatchableValuesCollectorMockRemove) Return() *PatchableValuesCollectorMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("PatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &PatchableValuesCollectorMockRemoveExpectation{mock: mmRemove.mock}
	}

	mmRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// Set uses given function f to mock the PatchableValuesCollector.Remove method
func (mmRemove *mPatchableValuesCollectorMockRemove) Set(f func(path string)) *PatchableValuesCollectorMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.Remove method")
	}

	mmRemove.mock.funcRemove = f
	mmRemove.mock.funcRemoveOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// When sets expectation for the PatchableValuesCollector.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mPatchableValuesCollectorMockRemove) When(path string) *PatchableValuesCollectorMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("PatchableValuesCollectorMock.Remove mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockRemoveExpectation{
		mock:               mmRemove.mock,
		params:             &PatchableValuesCollectorMockRemoveParams{path},
		expectationOrigins: PatchableValuesCollectorMockRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.Remove return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockRemoveExpectation) Then() *PatchableValuesCollectorMock {
	return e.mock
}

// Times sets number of times PatchableValuesCollector.Remove should be invoked
func (mmRemove *mPatchableValuesCollectorMockRemove) Times(n uint64) *mPatchableValuesCollectorMockRemove {
	if n == 0 {
		mmRemove.mock.t.Fatalf("Times of PatchableValuesCollectorMock.Remove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemove.expectedInvocations, n)
	mmRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemove
}

func (mmRemove *mPatchableValuesCollectorMockRemove) invocationsDone() bool {
	if len(mmRemove.expectations) == 0 && mmRemove.defaultExpectation == nil && mmRemove.mock.funcRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemove.mock.afterRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Remove implements mm_pkg.PatchableValuesCollector
func (mmRemove *PatchableValuesCollectorMock) Remove(path string) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	mmRemove.t.Helper()

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(path)
	}

	mm_params := PatchableValuesCollectorMockRemoveParams{path}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, &mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_want_ptrs := mmRemove.RemoveMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockRemoveParams{path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmRemove.t.Errorf("PatchableValuesCollectorMock.Remove got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("PatchableValuesCollectorMock.Remove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemove.RemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRemove.funcRemove != nil {
		mmRemove.funcRemove(path)
		return
	}
	mmRemove.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.Remove. %v", path)

}

// RemoveAfterCounter returns a count of finished PatchableValuesCollectorMock.Remove invocations
func (mmRemove *PatchableValuesCollectorMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of PatchableValuesCollectorMock.Remove invocations
func (mmRemove *PatchableValuesCollectorMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mPatchableValuesCollectorMockRemove) Calls() []*PatchableValuesCollectorMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockRemoveDone() bool {
	if m.RemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveMock.invocationsDone()
}

// MinimockRemoveInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Remove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCounter := mm_atomic.LoadUint64(&m.afterRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && afterRemoveCounter < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Remove at\n%s", m.RemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Remove at\n%s with params: %#v", m.RemoveMock.defaultExpectation.expectationOrigins.origin, *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && afterRemoveCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.Remove at\n%s", m.funcRemoveOrigin)
	}

	if !m.RemoveMock.invocationsDone() && afterRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.Remove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveMock.expectedInvocations), m.RemoveMock.expectedInvocationsOrigin, afterRemoveCounter)
	}
}

type mPatchableValuesCollectorMockSet struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockSetExpectation
	expectations       []*PatchableValuesCollectorMockSetExpectation

	callArgs []*PatchableValuesCollectorMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockSetExpectation specifies expectation struct of the PatchableValuesCollector.Set
type PatchableValuesCollectorMockSetExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockSetParams
	paramPtrs          *PatchableValuesCollectorMockSetParamPtrs
	expectationOrigins PatchableValuesCollectorMockSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PatchableValuesCollectorMockSetParams contains parameters of the PatchableValuesCollector.Set
type PatchableValuesCollectorMockSetParams struct {
	path  string
	value any
}

// PatchableValuesCollectorMockSetParamPtrs contains pointers to parameters of the PatchableValuesCollector.Set
type PatchableValuesCollectorMockSetParamPtrs struct {
	path  *string
	value *any
}

// PatchableValuesCollectorMockSetOrigins contains origins of expectations of the PatchableValuesCollector.Set
type PatchableValuesCollectorMockSetExpectationOrigins struct {
	origin      string
	originPath  string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mPatchableValuesCollectorMockSet) Optional() *mPatchableValuesCollectorMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for PatchableValuesCollector.Set
func (mmSet *mPatchableValuesCollectorMockSet) Expect(path string, value any) *mPatchableValuesCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &PatchableValuesCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &PatchableValuesCollectorMockSetParams{path, value}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectPathParam1 sets up expected param path for PatchableValuesCollector.Set
func (mmSet *mPatchableValuesCollectorMockSet) ExpectPathParam1(path string) *mPatchableValuesCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &PatchableValuesCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.path = &path
	mmSet.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmSet
}

// ExpectValueParam2 sets up expected param value for PatchableValuesCollector.Set
func (mmSet *mPatchableValuesCollectorMockSet) ExpectValueParam2(value any) *mPatchableValuesCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &PatchableValuesCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value
	mmSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.Set
func (mmSet *mPatchableValuesCollectorMockSet) Inspect(f func(path string, value any)) *mPatchableValuesCollectorMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by PatchableValuesCollector.Set
func (mmSet *mPatchableValuesCollectorMockSet) Return() *PatchableValuesCollectorMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &PatchableValuesCollectorMockSetExpectation{mock: mmSet.mock}
	}

	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the PatchableValuesCollector.Set method
func (mmSet *mPatchableValuesCollectorMockSet) Set(f func(path string, value any)) *PatchableValuesCollectorMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the PatchableValuesCollector.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mPatchableValuesCollectorMockSet) When(path string, value any) *PatchableValuesCollectorMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("PatchableValuesCollectorMock.Set mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockSetExpectation{
		mock:               mmSet.mock,
		params:             &PatchableValuesCollectorMockSetParams{path, value},
		expectationOrigins: PatchableValuesCollectorMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.Set return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockSetExpectation) Then() *PatchableValuesCollectorMock {
	return e.mock
}

// Times sets number of times PatchableValuesCollector.Set should be invoked
func (mmSet *mPatchableValuesCollectorMockSet) Times(n uint64) *mPatchableValuesCollectorMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of PatchableValuesCollectorMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mPatchableValuesCollectorMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_pkg.PatchableValuesCollector
func (mmSet *PatchableValuesCollectorMock) Set(path string, value any) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(path, value)
	}

	mm_params := PatchableValuesCollectorMockSetParams{path, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockSetParams{path, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmSet.t.Errorf("PatchableValuesCollectorMock.Set got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("PatchableValuesCollectorMock.Set got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("PatchableValuesCollectorMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSet.funcSet != nil {
		mmSet.funcSet(path, value)
		return
	}
	mmSet.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.Set. %v %v", path, value)

}

// SetAfterCounter returns a count of finished PatchableValuesCollectorMock.Set invocations
func (mmSet *PatchableValuesCollectorMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of PatchableValuesCollectorMock.Set invocations
func (mmSet *PatchableValuesCollectorMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mPatchableValuesCollectorMockSet) Calls() []*PatchableValuesCollectorMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

type mPatchableValuesCollectorMockWriteOutput struct {
	optional           bool
	mock               *PatchableValuesCollectorMock
	defaultExpectation *PatchableValuesCollectorMockWriteOutputExpectation
	expectations       []*PatchableValuesCollectorMockWriteOutputExpectation

	callArgs []*PatchableValuesCollectorMockWriteOutputParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PatchableValuesCollectorMockWriteOutputExpectation specifies expectation struct of the PatchableValuesCollector.WriteOutput
type PatchableValuesCollectorMockWriteOutputExpectation struct {
	mock               *PatchableValuesCollectorMock
	params             *PatchableValuesCollectorMockWriteOutputParams
	paramPtrs          *PatchableValuesCollectorMockWriteOutputParamPtrs
	expectationOrigins PatchableValuesCollectorMockWriteOutputExpectationOrigins
	results            *PatchableValuesCollectorMockWriteOutputResults
	returnOrigin       string
	Counter            uint64
}

// PatchableValuesCollectorMockWriteOutputParams contains parameters of the PatchableValuesCollector.WriteOutput
type PatchableValuesCollectorMockWriteOutputParams struct {
	writer io.Writer
}

// PatchableValuesCollectorMockWriteOutputParamPtrs contains pointers to parameters of the PatchableValuesCollector.WriteOutput
type PatchableValuesCollectorMockWriteOutputParamPtrs struct {
	writer *io.Writer
}

// PatchableValuesCollectorMockWriteOutputResults contains results of the PatchableValuesCollector.WriteOutput
type PatchableValuesCollectorMockWriteOutputResults struct {
	err error
}

// PatchableValuesCollectorMockWriteOutputOrigins contains origins of expectations of the PatchableValuesCollector.WriteOutput
type PatchableValuesCollectorMockWriteOutputExpectationOrigins struct {
	origin       string
	originWriter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) Optional() *mPatchableValuesCollectorMockWriteOutput {
	mmWriteOutput.optional = true
	return mmWriteOutput
}

// Expect sets up expected params for PatchableValuesCollector.WriteOutput
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) Expect(writer io.Writer) *mPatchableValuesCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchableValuesCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.paramPtrs != nil {
		mmWriteOutput.mock.t.Fatalf("PatchableValuesCollectorMock.WriteOutput mock is already set by ExpectParams functions")
	}

	mmWriteOutput.defaultExpectation.params = &PatchableValuesCollectorMockWriteOutputParams{writer}
	mmWriteOutput.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWriteOutput.expectations {
		if minimock.Equal(e.params, mmWriteOutput.defaultExpectation.params) {
			mmWriteOutput.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteOutput.defaultExpectation.params)
		}
	}

	return mmWriteOutput
}

// ExpectWriterParam1 sets up expected param writer for PatchableValuesCollector.WriteOutput
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) ExpectWriterParam1(writer io.Writer) *mPatchableValuesCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchableValuesCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.params != nil {
		mmWriteOutput.mock.t.Fatalf("PatchableValuesCollectorMock.WriteOutput mock is already set by Expect")
	}

	if mmWriteOutput.defaultExpectation.paramPtrs == nil {
		mmWriteOutput.defaultExpectation.paramPtrs = &PatchableValuesCollectorMockWriteOutputParamPtrs{}
	}
	mmWriteOutput.defaultExpectation.paramPtrs.writer = &writer
	mmWriteOutput.defaultExpectation.expectationOrigins.originWriter = minimock.CallerInfo(1)

	return mmWriteOutput
}

// Inspect accepts an inspector function that has same arguments as the PatchableValuesCollector.WriteOutput
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) Inspect(f func(writer io.Writer)) *mPatchableValuesCollectorMockWriteOutput {
	if mmWriteOutput.mock.inspectFuncWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("Inspect function is already set for PatchableValuesCollectorMock.WriteOutput")
	}

	mmWriteOutput.mock.inspectFuncWriteOutput = f

	return mmWriteOutput
}

// Return sets up results that will be returned by PatchableValuesCollector.WriteOutput
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) Return(err error) *PatchableValuesCollectorMock {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &PatchableValuesCollectorMockWriteOutputExpectation{mock: mmWriteOutput.mock}
	}
	mmWriteOutput.defaultExpectation.results = &PatchableValuesCollectorMockWriteOutputResults{err}
	mmWriteOutput.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// Set uses given function f to mock the PatchableValuesCollector.WriteOutput method
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) Set(f func(writer io.Writer) (err error)) *PatchableValuesCollectorMock {
	if mmWriteOutput.defaultExpectation != nil {
		mmWriteOutput.mock.t.Fatalf("Default expectation is already set for the PatchableValuesCollector.WriteOutput method")
	}

	if len(mmWriteOutput.expectations) > 0 {
		mmWriteOutput.mock.t.Fatalf("Some expectations are already set for the PatchableValuesCollector.WriteOutput method")
	}

	mmWriteOutput.mock.funcWriteOutput = f
	mmWriteOutput.mock.funcWriteOutputOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// When sets expectation for the PatchableValuesCollector.WriteOutput which will trigger the result defined by the following
// Then helper
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) When(writer io.Writer) *PatchableValuesCollectorMockWriteOutputExpectation {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("PatchableValuesCollectorMock.WriteOutput mock is already set by Set")
	}

	expectation := &PatchableValuesCollectorMockWriteOutputExpectation{
		mock:               mmWriteOutput.mock,
		params:             &PatchableValuesCollectorMockWriteOutputParams{writer},
		expectationOrigins: PatchableValuesCollectorMockWriteOutputExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWriteOutput.expectations = append(mmWriteOutput.expectations, expectation)
	return expectation
}

// Then sets up PatchableValuesCollector.WriteOutput return parameters for the expectation previously defined by the When method
func (e *PatchableValuesCollectorMockWriteOutputExpectation) Then(err error) *PatchableValuesCollectorMock {
	e.results = &PatchableValuesCollectorMockWriteOutputResults{err}
	return e.mock
}

// Times sets number of times PatchableValuesCollector.WriteOutput should be invoked
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) Times(n uint64) *mPatchableValuesCollectorMockWriteOutput {
	if n == 0 {
		mmWriteOutput.mock.t.Fatalf("Times of PatchableValuesCollectorMock.WriteOutput mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteOutput.expectedInvocations, n)
	mmWriteOutput.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWriteOutput
}

func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) invocationsDone() bool {
	if len(mmWriteOutput.expectations) == 0 && mmWriteOutput.defaultExpectation == nil && mmWriteOutput.mock.funcWriteOutput == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteOutput.mock.afterWriteOutputCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteOutput.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteOutput implements mm_pkg.PatchableValuesCollector
func (mmWriteOutput *PatchableValuesCollectorMock) WriteOutput(writer io.Writer) (err error) {
	mm_atomic.AddUint64(&mmWriteOutput.beforeWriteOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteOutput.afterWriteOutputCounter, 1)

	mmWriteOutput.t.Helper()

	if mmWriteOutput.inspectFuncWriteOutput != nil {
		mmWriteOutput.inspectFuncWriteOutput(writer)
	}

	mm_params := PatchableValuesCollectorMockWriteOutputParams{writer}

	// Record call args
	mmWriteOutput.WriteOutputMock.mutex.Lock()
	mmWriteOutput.WriteOutputMock.callArgs = append(mmWriteOutput.WriteOutputMock.callArgs, &mm_params)
	mmWriteOutput.WriteOutputMock.mutex.Unlock()

	for _, e := range mmWriteOutput.WriteOutputMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWriteOutput.WriteOutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteOutput.WriteOutputMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteOutput.WriteOutputMock.defaultExpectation.params
		mm_want_ptrs := mmWriteOutput.WriteOutputMock.defaultExpectation.paramPtrs

		mm_got := PatchableValuesCollectorMockWriteOutputParams{writer}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.writer != nil && !minimock.Equal(*mm_want_ptrs.writer, mm_got.writer) {
				mmWriteOutput.t.Errorf("PatchableValuesCollectorMock.WriteOutput got unexpected parameter writer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.originWriter, *mm_want_ptrs.writer, mm_got.writer, minimock.Diff(*mm_want_ptrs.writer, mm_got.writer))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteOutput.t.Errorf("PatchableValuesCollectorMock.WriteOutput got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteOutput.WriteOutputMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteOutput.t.Fatal("No results are set for the PatchableValuesCollectorMock.WriteOutput")
		}
		return (*mm_results).err
	}
	if mmWriteOutput.funcWriteOutput != nil {
		return mmWriteOutput.funcWriteOutput(writer)
	}
	mmWriteOutput.t.Fatalf("Unexpected call to PatchableValuesCollectorMock.WriteOutput. %v", writer)
	return
}

// WriteOutputAfterCounter returns a count of finished PatchableValuesCollectorMock.WriteOutput invocations
func (mmWriteOutput *PatchableValuesCollectorMock) WriteOutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.afterWriteOutputCounter)
}

// WriteOutputBeforeCounter returns a count of PatchableValuesCollectorMock.WriteOutput invocations
func (mmWriteOutput *PatchableValuesCollectorMock) WriteOutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.beforeWriteOutputCounter)
}

// Calls returns a list of arguments used in each call to PatchableValuesCollectorMock.WriteOutput.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteOutput *mPatchableValuesCollectorMockWriteOutput) Calls() []*PatchableValuesCollectorMockWriteOutputParams {
	mmWriteOutput.mutex.RLock()

	argCopy := make([]*PatchableValuesCollectorMockWriteOutputParams, len(mmWriteOutput.callArgs))
	copy(argCopy, mmWriteOutput.callArgs)

	mmWriteOutput.mutex.RUnlock()

	return argCopy
}

// MinimockWriteOutputDone returns true if the count of the WriteOutput invocations corresponds
// the number of defined expectations
func (m *PatchableValuesCollectorMock) MinimockWriteOutputDone() bool {
	if m.WriteOutputMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteOutputMock.invocationsDone()
}

// MinimockWriteOutputInspect logs each unmet expectation
func (m *PatchableValuesCollectorMock) MinimockWriteOutputInspect() {
	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.WriteOutput at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWriteOutputCounter := mm_atomic.LoadUint64(&m.afterWriteOutputCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteOutputMock.defaultExpectation != nil && afterWriteOutputCounter < 1 {
		if m.WriteOutputMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.WriteOutput at\n%s", m.WriteOutputMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PatchableValuesCollectorMock.WriteOutput at\n%s with params: %#v", m.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *m.WriteOutputMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteOutput != nil && afterWriteOutputCounter < 1 {
		m.t.Errorf("Expected call to PatchableValuesCollectorMock.WriteOutput at\n%s", m.funcWriteOutputOrigin)
	}

	if !m.WriteOutputMock.invocationsDone() && afterWriteOutputCounter > 0 {
		m.t.Errorf("Expected %d calls to PatchableValuesCollectorMock.WriteOutput at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteOutputMock.expectedInvocations), m.WriteOutputMock.expectedInvocationsOrigin, afterWriteOutputCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PatchableValuesCollectorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockArrayCountInspect()

			m.MinimockExistsInspect()

			m.MinimockGetInspect()

			m.MinimockGetOkInspect()

			m.MinimockGetPatchesInspect()

			m.MinimockGetRawInspect()

			m.MinimockRemoveInspect()

			m.MinimockSetInspect()

			m.MinimockWriteOutputInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PatchableValuesCollectorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PatchableValuesCollectorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArrayCountDone() &&
		m.MinimockExistsDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetOkDone() &&
		m.MinimockGetPatchesDone() &&
		m.MinimockGetRawDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockSetDone() &&
		m.MinimockWriteOutputDone()
}
