// Code generated by http://github.com/gojuno/minimock ((devel)). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.Logger -o logger_mock.go -n LoggerMock -p mock

import (
	"context"
	"io"
	"log/slog"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/deckhouse/deckhouse/pkg/log"
	"github.com/gojuno/minimock/v3"
)

// LoggerMock implements mm_pkg.Logger
type LoggerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebug          func(msg string, args ...any)
	funcDebugOrigin    string
	inspectFuncDebug   func(msg string, args ...any)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugContext          func(ctx context.Context, msg string, args ...any)
	funcDebugContextOrigin    string
	inspectFuncDebugContext   func(ctx context.Context, msg string, args ...any)
	afterDebugContextCounter  uint64
	beforeDebugContextCounter uint64
	DebugContextMock          mLoggerMockDebugContext

	funcEnabled          func(ctx context.Context, level slog.Level) (b1 bool)
	funcEnabledOrigin    string
	inspectFuncEnabled   func(ctx context.Context, level slog.Level)
	afterEnabledCounter  uint64
	beforeEnabledCounter uint64
	EnabledMock          mLoggerMockEnabled

	funcError          func(msg string, args ...any)
	funcErrorOrigin    string
	inspectFuncError   func(msg string, args ...any)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorContext          func(ctx context.Context, msg string, args ...any)
	funcErrorContextOrigin    string
	inspectFuncErrorContext   func(ctx context.Context, msg string, args ...any)
	afterErrorContextCounter  uint64
	beforeErrorContextCounter uint64
	ErrorContextMock          mLoggerMockErrorContext

	funcFatal          func(msg string, args ...any)
	funcFatalOrigin    string
	inspectFuncFatal   func(msg string, args ...any)
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mLoggerMockFatal

	funcGetLevel          func() (l1 log.Level)
	funcGetLevelOrigin    string
	inspectFuncGetLevel   func()
	afterGetLevelCounter  uint64
	beforeGetLevelCounter uint64
	GetLevelMock          mLoggerMockGetLevel

	funcHandler          func() (h1 slog.Handler)
	funcHandlerOrigin    string
	inspectFuncHandler   func()
	afterHandlerCounter  uint64
	beforeHandlerCounter uint64
	HandlerMock          mLoggerMockHandler

	funcInfo          func(msg string, args ...any)
	funcInfoOrigin    string
	inspectFuncInfo   func(msg string, args ...any)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfoContext          func(ctx context.Context, msg string, args ...any)
	funcInfoContextOrigin    string
	inspectFuncInfoContext   func(ctx context.Context, msg string, args ...any)
	afterInfoContextCounter  uint64
	beforeInfoContextCounter uint64
	InfoContextMock          mLoggerMockInfoContext

	funcLog          func(ctx context.Context, level slog.Level, msg string, args ...any)
	funcLogOrigin    string
	inspectFuncLog   func(ctx context.Context, level slog.Level, msg string, args ...any)
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mLoggerMockLog

	funcLogAttrs          func(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr)
	funcLogAttrsOrigin    string
	inspectFuncLogAttrs   func(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr)
	afterLogAttrsCounter  uint64
	beforeLogAttrsCounter uint64
	LogAttrsMock          mLoggerMockLogAttrs

	funcNamed          func(name string) (lp1 *log.Logger)
	funcNamedOrigin    string
	inspectFuncNamed   func(name string)
	afterNamedCounter  uint64
	beforeNamedCounter uint64
	NamedMock          mLoggerMockNamed

	funcSetLevel          func(level log.Level)
	funcSetLevelOrigin    string
	inspectFuncSetLevel   func(level log.Level)
	afterSetLevelCounter  uint64
	beforeSetLevelCounter uint64
	SetLevelMock          mLoggerMockSetLevel

	funcSetOutput          func(w io.Writer)
	funcSetOutputOrigin    string
	inspectFuncSetOutput   func(w io.Writer)
	afterSetOutputCounter  uint64
	beforeSetOutputCounter uint64
	SetOutputMock          mLoggerMockSetOutput

	funcWarn          func(msg string, args ...any)
	funcWarnOrigin    string
	inspectFuncWarn   func(msg string, args ...any)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnContext          func(ctx context.Context, msg string, args ...any)
	funcWarnContextOrigin    string
	inspectFuncWarnContext   func(ctx context.Context, msg string, args ...any)
	afterWarnContextCounter  uint64
	beforeWarnContextCounter uint64
	WarnContextMock          mLoggerMockWarnContext

	funcWith          func(args ...any) (lp1 *log.Logger)
	funcWithOrigin    string
	inspectFuncWith   func(args ...any)
	afterWithCounter  uint64
	beforeWithCounter uint64
	WithMock          mLoggerMockWith

	funcWithGroup          func(name string) (lp1 *log.Logger)
	funcWithGroupOrigin    string
	inspectFuncWithGroup   func(name string)
	afterWithGroupCounter  uint64
	beforeWithGroupCounter uint64
	WithGroupMock          mLoggerMockWithGroup
}

// NewLoggerMock returns a mock for mm_pkg.Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugContextMock = mLoggerMockDebugContext{mock: m}
	m.DebugContextMock.callArgs = []*LoggerMockDebugContextParams{}

	m.EnabledMock = mLoggerMockEnabled{mock: m}
	m.EnabledMock.callArgs = []*LoggerMockEnabledParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorContextMock = mLoggerMockErrorContext{mock: m}
	m.ErrorContextMock.callArgs = []*LoggerMockErrorContextParams{}

	m.FatalMock = mLoggerMockFatal{mock: m}
	m.FatalMock.callArgs = []*LoggerMockFatalParams{}

	m.GetLevelMock = mLoggerMockGetLevel{mock: m}

	m.HandlerMock = mLoggerMockHandler{mock: m}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfoContextMock = mLoggerMockInfoContext{mock: m}
	m.InfoContextMock.callArgs = []*LoggerMockInfoContextParams{}

	m.LogMock = mLoggerMockLog{mock: m}
	m.LogMock.callArgs = []*LoggerMockLogParams{}

	m.LogAttrsMock = mLoggerMockLogAttrs{mock: m}
	m.LogAttrsMock.callArgs = []*LoggerMockLogAttrsParams{}

	m.NamedMock = mLoggerMockNamed{mock: m}
	m.NamedMock.callArgs = []*LoggerMockNamedParams{}

	m.SetLevelMock = mLoggerMockSetLevel{mock: m}
	m.SetLevelMock.callArgs = []*LoggerMockSetLevelParams{}

	m.SetOutputMock = mLoggerMockSetOutput{mock: m}
	m.SetOutputMock.callArgs = []*LoggerMockSetOutputParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnContextMock = mLoggerMockWarnContext{mock: m}
	m.WarnContextMock.callArgs = []*LoggerMockWarnContextParams{}

	m.WithMock = mLoggerMockWith{mock: m}
	m.WithMock.callArgs = []*LoggerMockWithParams{}

	m.WithGroupMock = mLoggerMockWithGroup{mock: m}
	m.WithGroupMock.callArgs = []*LoggerMockWithGroupParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerMockDebug struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockDebugParams
	paramPtrs          *LoggerMockDebugParamPtrs
	expectationOrigins LoggerMockDebugExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	msg  string
	args []any
}

// LoggerMockDebugParamPtrs contains pointers to parameters of the Logger.Debug
type LoggerMockDebugParamPtrs struct {
	msg  *string
	args *[]any
}

// LoggerMockDebugOrigins contains origins of expectations of the Logger.Debug
type LoggerMockDebugExpectationOrigins struct {
	origin     string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebug *mLoggerMockDebug) Optional() *mLoggerMockDebug {
	mmDebug.optional = true
	return mmDebug
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(msg string, args ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.paramPtrs != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by ExpectParams functions")
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{msg, args}
	mmDebug.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// ExpectMsgParam1 sets up expected param msg for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectMsgParam1(msg string) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.msg = &msg
	mmDebug.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmDebug
}

// ExpectArgsParam2 sets up expected param args for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectArgsParam2(args ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.args = &args
	mmDebug.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(msg string, args ...any)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	mmDebug.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(msg string, args ...any)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	mmDebug.mock.funcDebugOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// When sets expectation for the Logger.Debug which will trigger the result defined by the following
// Then helper
func (mmDebug *mLoggerMockDebug) When(msg string, args ...any) *LoggerMockDebugExpectation {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	expectation := &LoggerMockDebugExpectation{
		mock:               mmDebug.mock,
		params:             &LoggerMockDebugParams{msg, args},
		expectationOrigins: LoggerMockDebugExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebug.expectations = append(mmDebug.expectations, expectation)
	return expectation
}

// Then sets up Logger.Debug return parameters for the expectation previously defined by the When method
func (e *LoggerMockDebugExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Debug should be invoked
func (mmDebug *mLoggerMockDebug) Times(n uint64) *mLoggerMockDebug {
	if n == 0 {
		mmDebug.mock.t.Fatalf("Times of LoggerMock.Debug mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebug.expectedInvocations, n)
	mmDebug.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebug
}

func (mmDebug *mLoggerMockDebug) invocationsDone() bool {
	if len(mmDebug.expectations) == 0 && mmDebug.defaultExpectation == nil && mmDebug.mock.funcDebug == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebug.mock.afterDebugCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebug.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debug implements mm_pkg.Logger
func (mmDebug *LoggerMock) Debug(msg string, args ...any) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	mmDebug.t.Helper()

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, args...)
	}

	mm_params := LoggerMockDebugParams{msg, args}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_want_ptrs := mmDebug.DebugMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugParams{msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebug.DebugMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, args...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v %v", msg, args)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	if m.DebugMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugMock.invocationsDone()
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugCounter := mm_atomic.LoadUint64(&m.afterDebugCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && afterDebugCounter < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.DebugMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", m.DebugMock.defaultExpectation.expectationOrigins.origin, *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && afterDebugCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.funcDebugOrigin)
	}

	if !m.DebugMock.invocationsDone() && afterDebugCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debug at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugMock.expectedInvocations), m.DebugMock.expectedInvocationsOrigin, afterDebugCounter)
	}
}

type mLoggerMockDebugContext struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugContextExpectation
	expectations       []*LoggerMockDebugContextExpectation

	callArgs []*LoggerMockDebugContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockDebugContextExpectation specifies expectation struct of the Logger.DebugContext
type LoggerMockDebugContextExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockDebugContextParams
	paramPtrs          *LoggerMockDebugContextParamPtrs
	expectationOrigins LoggerMockDebugContextExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockDebugContextParams contains parameters of the Logger.DebugContext
type LoggerMockDebugContextParams struct {
	ctx  context.Context
	msg  string
	args []any
}

// LoggerMockDebugContextParamPtrs contains pointers to parameters of the Logger.DebugContext
type LoggerMockDebugContextParamPtrs struct {
	ctx  *context.Context
	msg  *string
	args *[]any
}

// LoggerMockDebugContextOrigins contains origins of expectations of the Logger.DebugContext
type LoggerMockDebugContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebugContext *mLoggerMockDebugContext) Optional() *mLoggerMockDebugContext {
	mmDebugContext.optional = true
	return mmDebugContext
}

// Expect sets up expected params for Logger.DebugContext
func (mmDebugContext *mLoggerMockDebugContext) Expect(ctx context.Context, msg string, args ...any) *mLoggerMockDebugContext {
	if mmDebugContext.mock.funcDebugContext != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Set")
	}

	if mmDebugContext.defaultExpectation == nil {
		mmDebugContext.defaultExpectation = &LoggerMockDebugContextExpectation{}
	}

	if mmDebugContext.defaultExpectation.paramPtrs != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by ExpectParams functions")
	}

	mmDebugContext.defaultExpectation.params = &LoggerMockDebugContextParams{ctx, msg, args}
	mmDebugContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebugContext.expectations {
		if minimock.Equal(e.params, mmDebugContext.defaultExpectation.params) {
			mmDebugContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugContext.defaultExpectation.params)
		}
	}

	return mmDebugContext
}

// ExpectCtxParam1 sets up expected param ctx for Logger.DebugContext
func (mmDebugContext *mLoggerMockDebugContext) ExpectCtxParam1(ctx context.Context) *mLoggerMockDebugContext {
	if mmDebugContext.mock.funcDebugContext != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Set")
	}

	if mmDebugContext.defaultExpectation == nil {
		mmDebugContext.defaultExpectation = &LoggerMockDebugContextExpectation{}
	}

	if mmDebugContext.defaultExpectation.params != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Expect")
	}

	if mmDebugContext.defaultExpectation.paramPtrs == nil {
		mmDebugContext.defaultExpectation.paramPtrs = &LoggerMockDebugContextParamPtrs{}
	}
	mmDebugContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmDebugContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDebugContext
}

// ExpectMsgParam2 sets up expected param msg for Logger.DebugContext
func (mmDebugContext *mLoggerMockDebugContext) ExpectMsgParam2(msg string) *mLoggerMockDebugContext {
	if mmDebugContext.mock.funcDebugContext != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Set")
	}

	if mmDebugContext.defaultExpectation == nil {
		mmDebugContext.defaultExpectation = &LoggerMockDebugContextExpectation{}
	}

	if mmDebugContext.defaultExpectation.params != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Expect")
	}

	if mmDebugContext.defaultExpectation.paramPtrs == nil {
		mmDebugContext.defaultExpectation.paramPtrs = &LoggerMockDebugContextParamPtrs{}
	}
	mmDebugContext.defaultExpectation.paramPtrs.msg = &msg
	mmDebugContext.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmDebugContext
}

// ExpectArgsParam3 sets up expected param args for Logger.DebugContext
func (mmDebugContext *mLoggerMockDebugContext) ExpectArgsParam3(args ...any) *mLoggerMockDebugContext {
	if mmDebugContext.mock.funcDebugContext != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Set")
	}

	if mmDebugContext.defaultExpectation == nil {
		mmDebugContext.defaultExpectation = &LoggerMockDebugContextExpectation{}
	}

	if mmDebugContext.defaultExpectation.params != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Expect")
	}

	if mmDebugContext.defaultExpectation.paramPtrs == nil {
		mmDebugContext.defaultExpectation.paramPtrs = &LoggerMockDebugContextParamPtrs{}
	}
	mmDebugContext.defaultExpectation.paramPtrs.args = &args
	mmDebugContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmDebugContext
}

// Inspect accepts an inspector function that has same arguments as the Logger.DebugContext
func (mmDebugContext *mLoggerMockDebugContext) Inspect(f func(ctx context.Context, msg string, args ...any)) *mLoggerMockDebugContext {
	if mmDebugContext.mock.inspectFuncDebugContext != nil {
		mmDebugContext.mock.t.Fatalf("Inspect function is already set for LoggerMock.DebugContext")
	}

	mmDebugContext.mock.inspectFuncDebugContext = f

	return mmDebugContext
}

// Return sets up results that will be returned by Logger.DebugContext
func (mmDebugContext *mLoggerMockDebugContext) Return() *LoggerMock {
	if mmDebugContext.mock.funcDebugContext != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Set")
	}

	if mmDebugContext.defaultExpectation == nil {
		mmDebugContext.defaultExpectation = &LoggerMockDebugContextExpectation{mock: mmDebugContext.mock}
	}

	mmDebugContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebugContext.mock
}

// Set uses given function f to mock the Logger.DebugContext method
func (mmDebugContext *mLoggerMockDebugContext) Set(f func(ctx context.Context, msg string, args ...any)) *LoggerMock {
	if mmDebugContext.defaultExpectation != nil {
		mmDebugContext.mock.t.Fatalf("Default expectation is already set for the Logger.DebugContext method")
	}

	if len(mmDebugContext.expectations) > 0 {
		mmDebugContext.mock.t.Fatalf("Some expectations are already set for the Logger.DebugContext method")
	}

	mmDebugContext.mock.funcDebugContext = f
	mmDebugContext.mock.funcDebugContextOrigin = minimock.CallerInfo(1)
	return mmDebugContext.mock
}

// When sets expectation for the Logger.DebugContext which will trigger the result defined by the following
// Then helper
func (mmDebugContext *mLoggerMockDebugContext) When(ctx context.Context, msg string, args ...any) *LoggerMockDebugContextExpectation {
	if mmDebugContext.mock.funcDebugContext != nil {
		mmDebugContext.mock.t.Fatalf("LoggerMock.DebugContext mock is already set by Set")
	}

	expectation := &LoggerMockDebugContextExpectation{
		mock:               mmDebugContext.mock,
		params:             &LoggerMockDebugContextParams{ctx, msg, args},
		expectationOrigins: LoggerMockDebugContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebugContext.expectations = append(mmDebugContext.expectations, expectation)
	return expectation
}

// Then sets up Logger.DebugContext return parameters for the expectation previously defined by the When method
func (e *LoggerMockDebugContextExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.DebugContext should be invoked
func (mmDebugContext *mLoggerMockDebugContext) Times(n uint64) *mLoggerMockDebugContext {
	if n == 0 {
		mmDebugContext.mock.t.Fatalf("Times of LoggerMock.DebugContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebugContext.expectedInvocations, n)
	mmDebugContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebugContext
}

func (mmDebugContext *mLoggerMockDebugContext) invocationsDone() bool {
	if len(mmDebugContext.expectations) == 0 && mmDebugContext.defaultExpectation == nil && mmDebugContext.mock.funcDebugContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebugContext.mock.afterDebugContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebugContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DebugContext implements mm_pkg.Logger
func (mmDebugContext *LoggerMock) DebugContext(ctx context.Context, msg string, args ...any) {
	mm_atomic.AddUint64(&mmDebugContext.beforeDebugContextCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugContext.afterDebugContextCounter, 1)

	mmDebugContext.t.Helper()

	if mmDebugContext.inspectFuncDebugContext != nil {
		mmDebugContext.inspectFuncDebugContext(ctx, msg, args...)
	}

	mm_params := LoggerMockDebugContextParams{ctx, msg, args}

	// Record call args
	mmDebugContext.DebugContextMock.mutex.Lock()
	mmDebugContext.DebugContextMock.callArgs = append(mmDebugContext.DebugContextMock.callArgs, &mm_params)
	mmDebugContext.DebugContextMock.mutex.Unlock()

	for _, e := range mmDebugContext.DebugContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugContext.DebugContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugContext.DebugContextMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugContext.DebugContextMock.defaultExpectation.params
		mm_want_ptrs := mmDebugContext.DebugContextMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugContextParams{ctx, msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDebugContext.t.Errorf("LoggerMock.DebugContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugContext.DebugContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmDebugContext.t.Errorf("LoggerMock.DebugContext got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugContext.DebugContextMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmDebugContext.t.Errorf("LoggerMock.DebugContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugContext.DebugContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugContext.t.Errorf("LoggerMock.DebugContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebugContext.DebugContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugContext.funcDebugContext != nil {
		mmDebugContext.funcDebugContext(ctx, msg, args...)
		return
	}
	mmDebugContext.t.Fatalf("Unexpected call to LoggerMock.DebugContext. %v %v %v", ctx, msg, args)

}

// DebugContextAfterCounter returns a count of finished LoggerMock.DebugContext invocations
func (mmDebugContext *LoggerMock) DebugContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugContext.afterDebugContextCounter)
}

// DebugContextBeforeCounter returns a count of LoggerMock.DebugContext invocations
func (mmDebugContext *LoggerMock) DebugContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugContext.beforeDebugContextCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.DebugContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugContext *mLoggerMockDebugContext) Calls() []*LoggerMockDebugContextParams {
	mmDebugContext.mutex.RLock()

	argCopy := make([]*LoggerMockDebugContextParams, len(mmDebugContext.callArgs))
	copy(argCopy, mmDebugContext.callArgs)

	mmDebugContext.mutex.RUnlock()

	return argCopy
}

// MinimockDebugContextDone returns true if the count of the DebugContext invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugContextDone() bool {
	if m.DebugContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugContextMock.invocationsDone()
}

// MinimockDebugContextInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugContextInspect() {
	for _, e := range m.DebugContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.DebugContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugContextCounter := mm_atomic.LoadUint64(&m.afterDebugContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugContextMock.defaultExpectation != nil && afterDebugContextCounter < 1 {
		if m.DebugContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.DebugContext at\n%s", m.DebugContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.DebugContext at\n%s with params: %#v", m.DebugContextMock.defaultExpectation.expectationOrigins.origin, *m.DebugContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugContext != nil && afterDebugContextCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.DebugContext at\n%s", m.funcDebugContextOrigin)
	}

	if !m.DebugContextMock.invocationsDone() && afterDebugContextCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.DebugContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugContextMock.expectedInvocations), m.DebugContextMock.expectedInvocationsOrigin, afterDebugContextCounter)
	}
}

type mLoggerMockEnabled struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockEnabledExpectation
	expectations       []*LoggerMockEnabledExpectation

	callArgs []*LoggerMockEnabledParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockEnabledExpectation specifies expectation struct of the Logger.Enabled
type LoggerMockEnabledExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockEnabledParams
	paramPtrs          *LoggerMockEnabledParamPtrs
	expectationOrigins LoggerMockEnabledExpectationOrigins
	results            *LoggerMockEnabledResults
	returnOrigin       string
	Counter            uint64
}

// LoggerMockEnabledParams contains parameters of the Logger.Enabled
type LoggerMockEnabledParams struct {
	ctx   context.Context
	level slog.Level
}

// LoggerMockEnabledParamPtrs contains pointers to parameters of the Logger.Enabled
type LoggerMockEnabledParamPtrs struct {
	ctx   *context.Context
	level *slog.Level
}

// LoggerMockEnabledResults contains results of the Logger.Enabled
type LoggerMockEnabledResults struct {
	b1 bool
}

// LoggerMockEnabledOrigins contains origins of expectations of the Logger.Enabled
type LoggerMockEnabledExpectationOrigins struct {
	origin      string
	originCtx   string
	originLevel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEnabled *mLoggerMockEnabled) Optional() *mLoggerMockEnabled {
	mmEnabled.optional = true
	return mmEnabled
}

// Expect sets up expected params for Logger.Enabled
func (mmEnabled *mLoggerMockEnabled) Expect(ctx context.Context, level slog.Level) *mLoggerMockEnabled {
	if mmEnabled.mock.funcEnabled != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by Set")
	}

	if mmEnabled.defaultExpectation == nil {
		mmEnabled.defaultExpectation = &LoggerMockEnabledExpectation{}
	}

	if mmEnabled.defaultExpectation.paramPtrs != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by ExpectParams functions")
	}

	mmEnabled.defaultExpectation.params = &LoggerMockEnabledParams{ctx, level}
	mmEnabled.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEnabled.expectations {
		if minimock.Equal(e.params, mmEnabled.defaultExpectation.params) {
			mmEnabled.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnabled.defaultExpectation.params)
		}
	}

	return mmEnabled
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Enabled
func (mmEnabled *mLoggerMockEnabled) ExpectCtxParam1(ctx context.Context) *mLoggerMockEnabled {
	if mmEnabled.mock.funcEnabled != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by Set")
	}

	if mmEnabled.defaultExpectation == nil {
		mmEnabled.defaultExpectation = &LoggerMockEnabledExpectation{}
	}

	if mmEnabled.defaultExpectation.params != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by Expect")
	}

	if mmEnabled.defaultExpectation.paramPtrs == nil {
		mmEnabled.defaultExpectation.paramPtrs = &LoggerMockEnabledParamPtrs{}
	}
	mmEnabled.defaultExpectation.paramPtrs.ctx = &ctx
	mmEnabled.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEnabled
}

// ExpectLevelParam2 sets up expected param level for Logger.Enabled
func (mmEnabled *mLoggerMockEnabled) ExpectLevelParam2(level slog.Level) *mLoggerMockEnabled {
	if mmEnabled.mock.funcEnabled != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by Set")
	}

	if mmEnabled.defaultExpectation == nil {
		mmEnabled.defaultExpectation = &LoggerMockEnabledExpectation{}
	}

	if mmEnabled.defaultExpectation.params != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by Expect")
	}

	if mmEnabled.defaultExpectation.paramPtrs == nil {
		mmEnabled.defaultExpectation.paramPtrs = &LoggerMockEnabledParamPtrs{}
	}
	mmEnabled.defaultExpectation.paramPtrs.level = &level
	mmEnabled.defaultExpectation.expectationOrigins.originLevel = minimock.CallerInfo(1)

	return mmEnabled
}

// Inspect accepts an inspector function that has same arguments as the Logger.Enabled
func (mmEnabled *mLoggerMockEnabled) Inspect(f func(ctx context.Context, level slog.Level)) *mLoggerMockEnabled {
	if mmEnabled.mock.inspectFuncEnabled != nil {
		mmEnabled.mock.t.Fatalf("Inspect function is already set for LoggerMock.Enabled")
	}

	mmEnabled.mock.inspectFuncEnabled = f

	return mmEnabled
}

// Return sets up results that will be returned by Logger.Enabled
func (mmEnabled *mLoggerMockEnabled) Return(b1 bool) *LoggerMock {
	if mmEnabled.mock.funcEnabled != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by Set")
	}

	if mmEnabled.defaultExpectation == nil {
		mmEnabled.defaultExpectation = &LoggerMockEnabledExpectation{mock: mmEnabled.mock}
	}
	mmEnabled.defaultExpectation.results = &LoggerMockEnabledResults{b1}
	mmEnabled.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEnabled.mock
}

// Set uses given function f to mock the Logger.Enabled method
func (mmEnabled *mLoggerMockEnabled) Set(f func(ctx context.Context, level slog.Level) (b1 bool)) *LoggerMock {
	if mmEnabled.defaultExpectation != nil {
		mmEnabled.mock.t.Fatalf("Default expectation is already set for the Logger.Enabled method")
	}

	if len(mmEnabled.expectations) > 0 {
		mmEnabled.mock.t.Fatalf("Some expectations are already set for the Logger.Enabled method")
	}

	mmEnabled.mock.funcEnabled = f
	mmEnabled.mock.funcEnabledOrigin = minimock.CallerInfo(1)
	return mmEnabled.mock
}

// When sets expectation for the Logger.Enabled which will trigger the result defined by the following
// Then helper
func (mmEnabled *mLoggerMockEnabled) When(ctx context.Context, level slog.Level) *LoggerMockEnabledExpectation {
	if mmEnabled.mock.funcEnabled != nil {
		mmEnabled.mock.t.Fatalf("LoggerMock.Enabled mock is already set by Set")
	}

	expectation := &LoggerMockEnabledExpectation{
		mock:               mmEnabled.mock,
		params:             &LoggerMockEnabledParams{ctx, level},
		expectationOrigins: LoggerMockEnabledExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEnabled.expectations = append(mmEnabled.expectations, expectation)
	return expectation
}

// Then sets up Logger.Enabled return parameters for the expectation previously defined by the When method
func (e *LoggerMockEnabledExpectation) Then(b1 bool) *LoggerMock {
	e.results = &LoggerMockEnabledResults{b1}
	return e.mock
}

// Times sets number of times Logger.Enabled should be invoked
func (mmEnabled *mLoggerMockEnabled) Times(n uint64) *mLoggerMockEnabled {
	if n == 0 {
		mmEnabled.mock.t.Fatalf("Times of LoggerMock.Enabled mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEnabled.expectedInvocations, n)
	mmEnabled.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEnabled
}

func (mmEnabled *mLoggerMockEnabled) invocationsDone() bool {
	if len(mmEnabled.expectations) == 0 && mmEnabled.defaultExpectation == nil && mmEnabled.mock.funcEnabled == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEnabled.mock.afterEnabledCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEnabled.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Enabled implements mm_pkg.Logger
func (mmEnabled *LoggerMock) Enabled(ctx context.Context, level slog.Level) (b1 bool) {
	mm_atomic.AddUint64(&mmEnabled.beforeEnabledCounter, 1)
	defer mm_atomic.AddUint64(&mmEnabled.afterEnabledCounter, 1)

	mmEnabled.t.Helper()

	if mmEnabled.inspectFuncEnabled != nil {
		mmEnabled.inspectFuncEnabled(ctx, level)
	}

	mm_params := LoggerMockEnabledParams{ctx, level}

	// Record call args
	mmEnabled.EnabledMock.mutex.Lock()
	mmEnabled.EnabledMock.callArgs = append(mmEnabled.EnabledMock.callArgs, &mm_params)
	mmEnabled.EnabledMock.mutex.Unlock()

	for _, e := range mmEnabled.EnabledMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEnabled.EnabledMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnabled.EnabledMock.defaultExpectation.Counter, 1)
		mm_want := mmEnabled.EnabledMock.defaultExpectation.params
		mm_want_ptrs := mmEnabled.EnabledMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockEnabledParams{ctx, level}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEnabled.t.Errorf("LoggerMock.Enabled got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEnabled.EnabledMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.level != nil && !minimock.Equal(*mm_want_ptrs.level, mm_got.level) {
				mmEnabled.t.Errorf("LoggerMock.Enabled got unexpected parameter level, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEnabled.EnabledMock.defaultExpectation.expectationOrigins.originLevel, *mm_want_ptrs.level, mm_got.level, minimock.Diff(*mm_want_ptrs.level, mm_got.level))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnabled.t.Errorf("LoggerMock.Enabled got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEnabled.EnabledMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEnabled.EnabledMock.defaultExpectation.results
		if mm_results == nil {
			mmEnabled.t.Fatal("No results are set for the LoggerMock.Enabled")
		}
		return (*mm_results).b1
	}
	if mmEnabled.funcEnabled != nil {
		return mmEnabled.funcEnabled(ctx, level)
	}
	mmEnabled.t.Fatalf("Unexpected call to LoggerMock.Enabled. %v %v", ctx, level)
	return
}

// EnabledAfterCounter returns a count of finished LoggerMock.Enabled invocations
func (mmEnabled *LoggerMock) EnabledAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnabled.afterEnabledCounter)
}

// EnabledBeforeCounter returns a count of LoggerMock.Enabled invocations
func (mmEnabled *LoggerMock) EnabledBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnabled.beforeEnabledCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Enabled.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnabled *mLoggerMockEnabled) Calls() []*LoggerMockEnabledParams {
	mmEnabled.mutex.RLock()

	argCopy := make([]*LoggerMockEnabledParams, len(mmEnabled.callArgs))
	copy(argCopy, mmEnabled.callArgs)

	mmEnabled.mutex.RUnlock()

	return argCopy
}

// MinimockEnabledDone returns true if the count of the Enabled invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockEnabledDone() bool {
	if m.EnabledMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EnabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EnabledMock.invocationsDone()
}

// MinimockEnabledInspect logs each unmet expectation
func (m *LoggerMock) MinimockEnabledInspect() {
	for _, e := range m.EnabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Enabled at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEnabledCounter := mm_atomic.LoadUint64(&m.afterEnabledCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EnabledMock.defaultExpectation != nil && afterEnabledCounter < 1 {
		if m.EnabledMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Enabled at\n%s", m.EnabledMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Enabled at\n%s with params: %#v", m.EnabledMock.defaultExpectation.expectationOrigins.origin, *m.EnabledMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnabled != nil && afterEnabledCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Enabled at\n%s", m.funcEnabledOrigin)
	}

	if !m.EnabledMock.invocationsDone() && afterEnabledCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Enabled at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EnabledMock.expectedInvocations), m.EnabledMock.expectedInvocationsOrigin, afterEnabledCounter)
	}
}

type mLoggerMockError struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockErrorParams
	paramPtrs          *LoggerMockErrorParamPtrs
	expectationOrigins LoggerMockErrorExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	msg  string
	args []any
}

// LoggerMockErrorParamPtrs contains pointers to parameters of the Logger.Error
type LoggerMockErrorParamPtrs struct {
	msg  *string
	args *[]any
}

// LoggerMockErrorOrigins contains origins of expectations of the Logger.Error
type LoggerMockErrorExpectationOrigins struct {
	origin     string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mLoggerMockError) Optional() *mLoggerMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(msg string, args ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{msg, args}
	mmError.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectMsgParam1 sets up expected param msg for Logger.Error
func (mmError *mLoggerMockError) ExpectMsgParam1(msg string) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.msg = &msg
	mmError.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmError
}

// ExpectArgsParam2 sets up expected param args for Logger.Error
func (mmError *mLoggerMockError) ExpectArgsParam2(args ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.args = &args
	mmError.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(msg string, args ...any)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	mmError.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(msg string, args ...any)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	mmError.mock.funcErrorOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// When sets expectation for the Logger.Error which will trigger the result defined by the following
// Then helper
func (mmError *mLoggerMockError) When(msg string, args ...any) *LoggerMockErrorExpectation {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	expectation := &LoggerMockErrorExpectation{
		mock:               mmError.mock,
		params:             &LoggerMockErrorParams{msg, args},
		expectationOrigins: LoggerMockErrorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmError.expectations = append(mmError.expectations, expectation)
	return expectation
}

// Then sets up Logger.Error return parameters for the expectation previously defined by the When method
func (e *LoggerMockErrorExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Error should be invoked
func (mmError *mLoggerMockError) Times(n uint64) *mLoggerMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of LoggerMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	mmError.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmError
}

func (mmError *mLoggerMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements mm_pkg.Logger
func (mmError *LoggerMock) Error(msg string, args ...any) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	mmError.t.Helper()

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, args...)
	}

	mm_params := LoggerMockErrorParams{msg, args}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorParams{msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmError.ErrorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, args...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v %v", msg, args)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.ErrorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", m.ErrorMock.defaultExpectation.expectationOrigins.origin, *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.funcErrorOrigin)
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Error at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), m.ErrorMock.expectedInvocationsOrigin, afterErrorCounter)
	}
}

type mLoggerMockErrorContext struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorContextExpectation
	expectations       []*LoggerMockErrorContextExpectation

	callArgs []*LoggerMockErrorContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockErrorContextExpectation specifies expectation struct of the Logger.ErrorContext
type LoggerMockErrorContextExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockErrorContextParams
	paramPtrs          *LoggerMockErrorContextParamPtrs
	expectationOrigins LoggerMockErrorContextExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockErrorContextParams contains parameters of the Logger.ErrorContext
type LoggerMockErrorContextParams struct {
	ctx  context.Context
	msg  string
	args []any
}

// LoggerMockErrorContextParamPtrs contains pointers to parameters of the Logger.ErrorContext
type LoggerMockErrorContextParamPtrs struct {
	ctx  *context.Context
	msg  *string
	args *[]any
}

// LoggerMockErrorContextOrigins contains origins of expectations of the Logger.ErrorContext
type LoggerMockErrorContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrorContext *mLoggerMockErrorContext) Optional() *mLoggerMockErrorContext {
	mmErrorContext.optional = true
	return mmErrorContext
}

// Expect sets up expected params for Logger.ErrorContext
func (mmErrorContext *mLoggerMockErrorContext) Expect(ctx context.Context, msg string, args ...any) *mLoggerMockErrorContext {
	if mmErrorContext.mock.funcErrorContext != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Set")
	}

	if mmErrorContext.defaultExpectation == nil {
		mmErrorContext.defaultExpectation = &LoggerMockErrorContextExpectation{}
	}

	if mmErrorContext.defaultExpectation.paramPtrs != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by ExpectParams functions")
	}

	mmErrorContext.defaultExpectation.params = &LoggerMockErrorContextParams{ctx, msg, args}
	mmErrorContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmErrorContext.expectations {
		if minimock.Equal(e.params, mmErrorContext.defaultExpectation.params) {
			mmErrorContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorContext.defaultExpectation.params)
		}
	}

	return mmErrorContext
}

// ExpectCtxParam1 sets up expected param ctx for Logger.ErrorContext
func (mmErrorContext *mLoggerMockErrorContext) ExpectCtxParam1(ctx context.Context) *mLoggerMockErrorContext {
	if mmErrorContext.mock.funcErrorContext != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Set")
	}

	if mmErrorContext.defaultExpectation == nil {
		mmErrorContext.defaultExpectation = &LoggerMockErrorContextExpectation{}
	}

	if mmErrorContext.defaultExpectation.params != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Expect")
	}

	if mmErrorContext.defaultExpectation.paramPtrs == nil {
		mmErrorContext.defaultExpectation.paramPtrs = &LoggerMockErrorContextParamPtrs{}
	}
	mmErrorContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmErrorContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmErrorContext
}

// ExpectMsgParam2 sets up expected param msg for Logger.ErrorContext
func (mmErrorContext *mLoggerMockErrorContext) ExpectMsgParam2(msg string) *mLoggerMockErrorContext {
	if mmErrorContext.mock.funcErrorContext != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Set")
	}

	if mmErrorContext.defaultExpectation == nil {
		mmErrorContext.defaultExpectation = &LoggerMockErrorContextExpectation{}
	}

	if mmErrorContext.defaultExpectation.params != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Expect")
	}

	if mmErrorContext.defaultExpectation.paramPtrs == nil {
		mmErrorContext.defaultExpectation.paramPtrs = &LoggerMockErrorContextParamPtrs{}
	}
	mmErrorContext.defaultExpectation.paramPtrs.msg = &msg
	mmErrorContext.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmErrorContext
}

// ExpectArgsParam3 sets up expected param args for Logger.ErrorContext
func (mmErrorContext *mLoggerMockErrorContext) ExpectArgsParam3(args ...any) *mLoggerMockErrorContext {
	if mmErrorContext.mock.funcErrorContext != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Set")
	}

	if mmErrorContext.defaultExpectation == nil {
		mmErrorContext.defaultExpectation = &LoggerMockErrorContextExpectation{}
	}

	if mmErrorContext.defaultExpectation.params != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Expect")
	}

	if mmErrorContext.defaultExpectation.paramPtrs == nil {
		mmErrorContext.defaultExpectation.paramPtrs = &LoggerMockErrorContextParamPtrs{}
	}
	mmErrorContext.defaultExpectation.paramPtrs.args = &args
	mmErrorContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmErrorContext
}

// Inspect accepts an inspector function that has same arguments as the Logger.ErrorContext
func (mmErrorContext *mLoggerMockErrorContext) Inspect(f func(ctx context.Context, msg string, args ...any)) *mLoggerMockErrorContext {
	if mmErrorContext.mock.inspectFuncErrorContext != nil {
		mmErrorContext.mock.t.Fatalf("Inspect function is already set for LoggerMock.ErrorContext")
	}

	mmErrorContext.mock.inspectFuncErrorContext = f

	return mmErrorContext
}

// Return sets up results that will be returned by Logger.ErrorContext
func (mmErrorContext *mLoggerMockErrorContext) Return() *LoggerMock {
	if mmErrorContext.mock.funcErrorContext != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Set")
	}

	if mmErrorContext.defaultExpectation == nil {
		mmErrorContext.defaultExpectation = &LoggerMockErrorContextExpectation{mock: mmErrorContext.mock}
	}

	mmErrorContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmErrorContext.mock
}

// Set uses given function f to mock the Logger.ErrorContext method
func (mmErrorContext *mLoggerMockErrorContext) Set(f func(ctx context.Context, msg string, args ...any)) *LoggerMock {
	if mmErrorContext.defaultExpectation != nil {
		mmErrorContext.mock.t.Fatalf("Default expectation is already set for the Logger.ErrorContext method")
	}

	if len(mmErrorContext.expectations) > 0 {
		mmErrorContext.mock.t.Fatalf("Some expectations are already set for the Logger.ErrorContext method")
	}

	mmErrorContext.mock.funcErrorContext = f
	mmErrorContext.mock.funcErrorContextOrigin = minimock.CallerInfo(1)
	return mmErrorContext.mock
}

// When sets expectation for the Logger.ErrorContext which will trigger the result defined by the following
// Then helper
func (mmErrorContext *mLoggerMockErrorContext) When(ctx context.Context, msg string, args ...any) *LoggerMockErrorContextExpectation {
	if mmErrorContext.mock.funcErrorContext != nil {
		mmErrorContext.mock.t.Fatalf("LoggerMock.ErrorContext mock is already set by Set")
	}

	expectation := &LoggerMockErrorContextExpectation{
		mock:               mmErrorContext.mock,
		params:             &LoggerMockErrorContextParams{ctx, msg, args},
		expectationOrigins: LoggerMockErrorContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmErrorContext.expectations = append(mmErrorContext.expectations, expectation)
	return expectation
}

// Then sets up Logger.ErrorContext return parameters for the expectation previously defined by the When method
func (e *LoggerMockErrorContextExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.ErrorContext should be invoked
func (mmErrorContext *mLoggerMockErrorContext) Times(n uint64) *mLoggerMockErrorContext {
	if n == 0 {
		mmErrorContext.mock.t.Fatalf("Times of LoggerMock.ErrorContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrorContext.expectedInvocations, n)
	mmErrorContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmErrorContext
}

func (mmErrorContext *mLoggerMockErrorContext) invocationsDone() bool {
	if len(mmErrorContext.expectations) == 0 && mmErrorContext.defaultExpectation == nil && mmErrorContext.mock.funcErrorContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrorContext.mock.afterErrorContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrorContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ErrorContext implements mm_pkg.Logger
func (mmErrorContext *LoggerMock) ErrorContext(ctx context.Context, msg string, args ...any) {
	mm_atomic.AddUint64(&mmErrorContext.beforeErrorContextCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorContext.afterErrorContextCounter, 1)

	mmErrorContext.t.Helper()

	if mmErrorContext.inspectFuncErrorContext != nil {
		mmErrorContext.inspectFuncErrorContext(ctx, msg, args...)
	}

	mm_params := LoggerMockErrorContextParams{ctx, msg, args}

	// Record call args
	mmErrorContext.ErrorContextMock.mutex.Lock()
	mmErrorContext.ErrorContextMock.callArgs = append(mmErrorContext.ErrorContextMock.callArgs, &mm_params)
	mmErrorContext.ErrorContextMock.mutex.Unlock()

	for _, e := range mmErrorContext.ErrorContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorContext.ErrorContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorContext.ErrorContextMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorContext.ErrorContextMock.defaultExpectation.params
		mm_want_ptrs := mmErrorContext.ErrorContextMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorContextParams{ctx, msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmErrorContext.t.Errorf("LoggerMock.ErrorContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorContext.ErrorContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmErrorContext.t.Errorf("LoggerMock.ErrorContext got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorContext.ErrorContextMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmErrorContext.t.Errorf("LoggerMock.ErrorContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorContext.ErrorContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorContext.t.Errorf("LoggerMock.ErrorContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmErrorContext.ErrorContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorContext.funcErrorContext != nil {
		mmErrorContext.funcErrorContext(ctx, msg, args...)
		return
	}
	mmErrorContext.t.Fatalf("Unexpected call to LoggerMock.ErrorContext. %v %v %v", ctx, msg, args)

}

// ErrorContextAfterCounter returns a count of finished LoggerMock.ErrorContext invocations
func (mmErrorContext *LoggerMock) ErrorContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorContext.afterErrorContextCounter)
}

// ErrorContextBeforeCounter returns a count of LoggerMock.ErrorContext invocations
func (mmErrorContext *LoggerMock) ErrorContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorContext.beforeErrorContextCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.ErrorContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorContext *mLoggerMockErrorContext) Calls() []*LoggerMockErrorContextParams {
	mmErrorContext.mutex.RLock()

	argCopy := make([]*LoggerMockErrorContextParams, len(mmErrorContext.callArgs))
	copy(argCopy, mmErrorContext.callArgs)

	mmErrorContext.mutex.RUnlock()

	return argCopy
}

// MinimockErrorContextDone returns true if the count of the ErrorContext invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorContextDone() bool {
	if m.ErrorContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorContextMock.invocationsDone()
}

// MinimockErrorContextInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorContextInspect() {
	for _, e := range m.ErrorContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.ErrorContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorContextCounter := mm_atomic.LoadUint64(&m.afterErrorContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorContextMock.defaultExpectation != nil && afterErrorContextCounter < 1 {
		if m.ErrorContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.ErrorContext at\n%s", m.ErrorContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.ErrorContext at\n%s with params: %#v", m.ErrorContextMock.defaultExpectation.expectationOrigins.origin, *m.ErrorContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorContext != nil && afterErrorContextCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.ErrorContext at\n%s", m.funcErrorContextOrigin)
	}

	if !m.ErrorContextMock.invocationsDone() && afterErrorContextCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.ErrorContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorContextMock.expectedInvocations), m.ErrorContextMock.expectedInvocationsOrigin, afterErrorContextCounter)
	}
}

type mLoggerMockFatal struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalExpectation
	expectations       []*LoggerMockFatalExpectation

	callArgs []*LoggerMockFatalParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockFatalExpectation specifies expectation struct of the Logger.Fatal
type LoggerMockFatalExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockFatalParams
	paramPtrs          *LoggerMockFatalParamPtrs
	expectationOrigins LoggerMockFatalExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockFatalParams contains parameters of the Logger.Fatal
type LoggerMockFatalParams struct {
	msg  string
	args []any
}

// LoggerMockFatalParamPtrs contains pointers to parameters of the Logger.Fatal
type LoggerMockFatalParamPtrs struct {
	msg  *string
	args *[]any
}

// LoggerMockFatalOrigins contains origins of expectations of the Logger.Fatal
type LoggerMockFatalExpectationOrigins struct {
	origin     string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatal *mLoggerMockFatal) Optional() *mLoggerMockFatal {
	mmFatal.optional = true
	return mmFatal
}

// Expect sets up expected params for Logger.Fatal
func (mmFatal *mLoggerMockFatal) Expect(msg string, args ...any) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.paramPtrs != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by ExpectParams functions")
	}

	mmFatal.defaultExpectation.params = &LoggerMockFatalParams{msg, args}
	mmFatal.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// ExpectMsgParam1 sets up expected param msg for Logger.Fatal
func (mmFatal *mLoggerMockFatal) ExpectMsgParam1(msg string) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.msg = &msg
	mmFatal.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmFatal
}

// ExpectArgsParam2 sets up expected param args for Logger.Fatal
func (mmFatal *mLoggerMockFatal) ExpectArgsParam2(args ...any) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.args = &args
	mmFatal.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatal
func (mmFatal *mLoggerMockFatal) Inspect(f func(msg string, args ...any)) *mLoggerMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by Logger.Fatal
func (mmFatal *mLoggerMockFatal) Return() *LoggerMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{mock: mmFatal.mock}
	}

	mmFatal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFatal.mock
}

// Set uses given function f to mock the Logger.Fatal method
func (mmFatal *mLoggerMockFatal) Set(f func(msg string, args ...any)) *LoggerMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the Logger.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the Logger.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	mmFatal.mock.funcFatalOrigin = minimock.CallerInfo(1)
	return mmFatal.mock
}

// When sets expectation for the Logger.Fatal which will trigger the result defined by the following
// Then helper
func (mmFatal *mLoggerMockFatal) When(msg string, args ...any) *LoggerMockFatalExpectation {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	expectation := &LoggerMockFatalExpectation{
		mock:               mmFatal.mock,
		params:             &LoggerMockFatalParams{msg, args},
		expectationOrigins: LoggerMockFatalExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFatal.expectations = append(mmFatal.expectations, expectation)
	return expectation
}

// Then sets up Logger.Fatal return parameters for the expectation previously defined by the When method
func (e *LoggerMockFatalExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Fatal should be invoked
func (mmFatal *mLoggerMockFatal) Times(n uint64) *mLoggerMockFatal {
	if n == 0 {
		mmFatal.mock.t.Fatalf("Times of LoggerMock.Fatal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatal.expectedInvocations, n)
	mmFatal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFatal
}

func (mmFatal *mLoggerMockFatal) invocationsDone() bool {
	if len(mmFatal.expectations) == 0 && mmFatal.defaultExpectation == nil && mmFatal.mock.funcFatal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatal.mock.afterFatalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatal implements mm_pkg.Logger
func (mmFatal *LoggerMock) Fatal(msg string, args ...any) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	mmFatal.t.Helper()

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(msg, args...)
	}

	mm_params := LoggerMockFatalParams{msg, args}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, &mm_params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		mm_want := mmFatal.FatalMock.defaultExpectation.params
		mm_want_ptrs := mmFatal.FatalMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockFatalParams{msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatal.FatalMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatal.FatalMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFatal.FatalMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(msg, args...)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to LoggerMock.Fatal. %v %v", msg, args)

}

// FatalAfterCounter returns a count of finished LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mLoggerMockFatal) Calls() []*LoggerMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*LoggerMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalDone() bool {
	if m.FatalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalMock.invocationsDone()
}

// MinimockFatalInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFatalCounter := mm_atomic.LoadUint64(&m.afterFatalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && afterFatalCounter < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s", m.FatalMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s with params: %#v", m.FatalMock.defaultExpectation.expectationOrigins.origin, *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && afterFatalCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s", m.funcFatalOrigin)
	}

	if !m.FatalMock.invocationsDone() && afterFatalCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Fatal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FatalMock.expectedInvocations), m.FatalMock.expectedInvocationsOrigin, afterFatalCounter)
	}
}

type mLoggerMockGetLevel struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockGetLevelExpectation
	expectations       []*LoggerMockGetLevelExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockGetLevelExpectation specifies expectation struct of the Logger.GetLevel
type LoggerMockGetLevelExpectation struct {
	mock *LoggerMock

	results      *LoggerMockGetLevelResults
	returnOrigin string
	Counter      uint64
}

// LoggerMockGetLevelResults contains results of the Logger.GetLevel
type LoggerMockGetLevelResults struct {
	l1 log.Level
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLevel *mLoggerMockGetLevel) Optional() *mLoggerMockGetLevel {
	mmGetLevel.optional = true
	return mmGetLevel
}

// Expect sets up expected params for Logger.GetLevel
func (mmGetLevel *mLoggerMockGetLevel) Expect() *mLoggerMockGetLevel {
	if mmGetLevel.mock.funcGetLevel != nil {
		mmGetLevel.mock.t.Fatalf("LoggerMock.GetLevel mock is already set by Set")
	}

	if mmGetLevel.defaultExpectation == nil {
		mmGetLevel.defaultExpectation = &LoggerMockGetLevelExpectation{}
	}

	return mmGetLevel
}

// Inspect accepts an inspector function that has same arguments as the Logger.GetLevel
func (mmGetLevel *mLoggerMockGetLevel) Inspect(f func()) *mLoggerMockGetLevel {
	if mmGetLevel.mock.inspectFuncGetLevel != nil {
		mmGetLevel.mock.t.Fatalf("Inspect function is already set for LoggerMock.GetLevel")
	}

	mmGetLevel.mock.inspectFuncGetLevel = f

	return mmGetLevel
}

// Return sets up results that will be returned by Logger.GetLevel
func (mmGetLevel *mLoggerMockGetLevel) Return(l1 log.Level) *LoggerMock {
	if mmGetLevel.mock.funcGetLevel != nil {
		mmGetLevel.mock.t.Fatalf("LoggerMock.GetLevel mock is already set by Set")
	}

	if mmGetLevel.defaultExpectation == nil {
		mmGetLevel.defaultExpectation = &LoggerMockGetLevelExpectation{mock: mmGetLevel.mock}
	}
	mmGetLevel.defaultExpectation.results = &LoggerMockGetLevelResults{l1}
	mmGetLevel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLevel.mock
}

// Set uses given function f to mock the Logger.GetLevel method
func (mmGetLevel *mLoggerMockGetLevel) Set(f func() (l1 log.Level)) *LoggerMock {
	if mmGetLevel.defaultExpectation != nil {
		mmGetLevel.mock.t.Fatalf("Default expectation is already set for the Logger.GetLevel method")
	}

	if len(mmGetLevel.expectations) > 0 {
		mmGetLevel.mock.t.Fatalf("Some expectations are already set for the Logger.GetLevel method")
	}

	mmGetLevel.mock.funcGetLevel = f
	mmGetLevel.mock.funcGetLevelOrigin = minimock.CallerInfo(1)
	return mmGetLevel.mock
}

// Times sets number of times Logger.GetLevel should be invoked
func (mmGetLevel *mLoggerMockGetLevel) Times(n uint64) *mLoggerMockGetLevel {
	if n == 0 {
		mmGetLevel.mock.t.Fatalf("Times of LoggerMock.GetLevel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLevel.expectedInvocations, n)
	mmGetLevel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLevel
}

func (mmGetLevel *mLoggerMockGetLevel) invocationsDone() bool {
	if len(mmGetLevel.expectations) == 0 && mmGetLevel.defaultExpectation == nil && mmGetLevel.mock.funcGetLevel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLevel.mock.afterGetLevelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLevel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLevel implements mm_pkg.Logger
func (mmGetLevel *LoggerMock) GetLevel() (l1 log.Level) {
	mm_atomic.AddUint64(&mmGetLevel.beforeGetLevelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLevel.afterGetLevelCounter, 1)

	mmGetLevel.t.Helper()

	if mmGetLevel.inspectFuncGetLevel != nil {
		mmGetLevel.inspectFuncGetLevel()
	}

	if mmGetLevel.GetLevelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLevel.GetLevelMock.defaultExpectation.Counter, 1)

		mm_results := mmGetLevel.GetLevelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLevel.t.Fatal("No results are set for the LoggerMock.GetLevel")
		}
		return (*mm_results).l1
	}
	if mmGetLevel.funcGetLevel != nil {
		return mmGetLevel.funcGetLevel()
	}
	mmGetLevel.t.Fatalf("Unexpected call to LoggerMock.GetLevel.")
	return
}

// GetLevelAfterCounter returns a count of finished LoggerMock.GetLevel invocations
func (mmGetLevel *LoggerMock) GetLevelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLevel.afterGetLevelCounter)
}

// GetLevelBeforeCounter returns a count of LoggerMock.GetLevel invocations
func (mmGetLevel *LoggerMock) GetLevelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLevel.beforeGetLevelCounter)
}

// MinimockGetLevelDone returns true if the count of the GetLevel invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockGetLevelDone() bool {
	if m.GetLevelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLevelMock.invocationsDone()
}

// MinimockGetLevelInspect logs each unmet expectation
func (m *LoggerMock) MinimockGetLevelInspect() {
	for _, e := range m.GetLevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LoggerMock.GetLevel")
		}
	}

	afterGetLevelCounter := mm_atomic.LoadUint64(&m.afterGetLevelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLevelMock.defaultExpectation != nil && afterGetLevelCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.GetLevel at\n%s", m.GetLevelMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLevel != nil && afterGetLevelCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.GetLevel at\n%s", m.funcGetLevelOrigin)
	}

	if !m.GetLevelMock.invocationsDone() && afterGetLevelCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.GetLevel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLevelMock.expectedInvocations), m.GetLevelMock.expectedInvocationsOrigin, afterGetLevelCounter)
	}
}

type mLoggerMockHandler struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockHandlerExpectation
	expectations       []*LoggerMockHandlerExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockHandlerExpectation specifies expectation struct of the Logger.Handler
type LoggerMockHandlerExpectation struct {
	mock *LoggerMock

	results      *LoggerMockHandlerResults
	returnOrigin string
	Counter      uint64
}

// LoggerMockHandlerResults contains results of the Logger.Handler
type LoggerMockHandlerResults struct {
	h1 slog.Handler
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHandler *mLoggerMockHandler) Optional() *mLoggerMockHandler {
	mmHandler.optional = true
	return mmHandler
}

// Expect sets up expected params for Logger.Handler
func (mmHandler *mLoggerMockHandler) Expect() *mLoggerMockHandler {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("LoggerMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &LoggerMockHandlerExpectation{}
	}

	return mmHandler
}

// Inspect accepts an inspector function that has same arguments as the Logger.Handler
func (mmHandler *mLoggerMockHandler) Inspect(f func()) *mLoggerMockHandler {
	if mmHandler.mock.inspectFuncHandler != nil {
		mmHandler.mock.t.Fatalf("Inspect function is already set for LoggerMock.Handler")
	}

	mmHandler.mock.inspectFuncHandler = f

	return mmHandler
}

// Return sets up results that will be returned by Logger.Handler
func (mmHandler *mLoggerMockHandler) Return(h1 slog.Handler) *LoggerMock {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("LoggerMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &LoggerMockHandlerExpectation{mock: mmHandler.mock}
	}
	mmHandler.defaultExpectation.results = &LoggerMockHandlerResults{h1}
	mmHandler.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Set uses given function f to mock the Logger.Handler method
func (mmHandler *mLoggerMockHandler) Set(f func() (h1 slog.Handler)) *LoggerMock {
	if mmHandler.defaultExpectation != nil {
		mmHandler.mock.t.Fatalf("Default expectation is already set for the Logger.Handler method")
	}

	if len(mmHandler.expectations) > 0 {
		mmHandler.mock.t.Fatalf("Some expectations are already set for the Logger.Handler method")
	}

	mmHandler.mock.funcHandler = f
	mmHandler.mock.funcHandlerOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Times sets number of times Logger.Handler should be invoked
func (mmHandler *mLoggerMockHandler) Times(n uint64) *mLoggerMockHandler {
	if n == 0 {
		mmHandler.mock.t.Fatalf("Times of LoggerMock.Handler mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHandler.expectedInvocations, n)
	mmHandler.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHandler
}

func (mmHandler *mLoggerMockHandler) invocationsDone() bool {
	if len(mmHandler.expectations) == 0 && mmHandler.defaultExpectation == nil && mmHandler.mock.funcHandler == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHandler.mock.afterHandlerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHandler.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Handler implements mm_pkg.Logger
func (mmHandler *LoggerMock) Handler() (h1 slog.Handler) {
	mm_atomic.AddUint64(&mmHandler.beforeHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmHandler.afterHandlerCounter, 1)

	mmHandler.t.Helper()

	if mmHandler.inspectFuncHandler != nil {
		mmHandler.inspectFuncHandler()
	}

	if mmHandler.HandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHandler.HandlerMock.defaultExpectation.Counter, 1)

		mm_results := mmHandler.HandlerMock.defaultExpectation.results
		if mm_results == nil {
			mmHandler.t.Fatal("No results are set for the LoggerMock.Handler")
		}
		return (*mm_results).h1
	}
	if mmHandler.funcHandler != nil {
		return mmHandler.funcHandler()
	}
	mmHandler.t.Fatalf("Unexpected call to LoggerMock.Handler.")
	return
}

// HandlerAfterCounter returns a count of finished LoggerMock.Handler invocations
func (mmHandler *LoggerMock) HandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.afterHandlerCounter)
}

// HandlerBeforeCounter returns a count of LoggerMock.Handler invocations
func (mmHandler *LoggerMock) HandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.beforeHandlerCounter)
}

// MinimockHandlerDone returns true if the count of the Handler invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockHandlerDone() bool {
	if m.HandlerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HandlerMock.invocationsDone()
}

// MinimockHandlerInspect logs each unmet expectation
func (m *LoggerMock) MinimockHandlerInspect() {
	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LoggerMock.Handler")
		}
	}

	afterHandlerCounter := mm_atomic.LoadUint64(&m.afterHandlerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HandlerMock.defaultExpectation != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Handler at\n%s", m.HandlerMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHandler != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Handler at\n%s", m.funcHandlerOrigin)
	}

	if !m.HandlerMock.invocationsDone() && afterHandlerCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Handler at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HandlerMock.expectedInvocations), m.HandlerMock.expectedInvocationsOrigin, afterHandlerCounter)
	}
}

type mLoggerMockInfo struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockInfoParams
	paramPtrs          *LoggerMockInfoParamPtrs
	expectationOrigins LoggerMockInfoExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	msg  string
	args []any
}

// LoggerMockInfoParamPtrs contains pointers to parameters of the Logger.Info
type LoggerMockInfoParamPtrs struct {
	msg  *string
	args *[]any
}

// LoggerMockInfoOrigins contains origins of expectations of the Logger.Info
type LoggerMockInfoExpectationOrigins struct {
	origin     string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfo *mLoggerMockInfo) Optional() *mLoggerMockInfo {
	mmInfo.optional = true
	return mmInfo
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(msg string, args ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.paramPtrs != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by ExpectParams functions")
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{msg, args}
	mmInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// ExpectMsgParam1 sets up expected param msg for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectMsgParam1(msg string) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.msg = &msg
	mmInfo.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmInfo
}

// ExpectArgsParam2 sets up expected param args for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectArgsParam2(args ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.args = &args
	mmInfo.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(msg string, args ...any)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	mmInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(msg string, args ...any)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	mmInfo.mock.funcInfoOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// When sets expectation for the Logger.Info which will trigger the result defined by the following
// Then helper
func (mmInfo *mLoggerMockInfo) When(msg string, args ...any) *LoggerMockInfoExpectation {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	expectation := &LoggerMockInfoExpectation{
		mock:               mmInfo.mock,
		params:             &LoggerMockInfoParams{msg, args},
		expectationOrigins: LoggerMockInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfo.expectations = append(mmInfo.expectations, expectation)
	return expectation
}

// Then sets up Logger.Info return parameters for the expectation previously defined by the When method
func (e *LoggerMockInfoExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Info should be invoked
func (mmInfo *mLoggerMockInfo) Times(n uint64) *mLoggerMockInfo {
	if n == 0 {
		mmInfo.mock.t.Fatalf("Times of LoggerMock.Info mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfo.expectedInvocations, n)
	mmInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfo
}

func (mmInfo *mLoggerMockInfo) invocationsDone() bool {
	if len(mmInfo.expectations) == 0 && mmInfo.defaultExpectation == nil && mmInfo.mock.funcInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfo.mock.afterInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Info implements mm_pkg.Logger
func (mmInfo *LoggerMock) Info(msg string, args ...any) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	mmInfo.t.Helper()

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, args...)
	}

	mm_params := LoggerMockInfoParams{msg, args}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_want_ptrs := mmInfo.InfoMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfoParams{msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfo.InfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, args...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v %v", msg, args)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	if m.InfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoMock.invocationsDone()
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfoCounter := mm_atomic.LoadUint64(&m.afterInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && afterInfoCounter < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.InfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", m.InfoMock.defaultExpectation.expectationOrigins.origin, *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && afterInfoCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.funcInfoOrigin)
	}

	if !m.InfoMock.invocationsDone() && afterInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Info at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfoMock.expectedInvocations), m.InfoMock.expectedInvocationsOrigin, afterInfoCounter)
	}
}

type mLoggerMockInfoContext struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoContextExpectation
	expectations       []*LoggerMockInfoContextExpectation

	callArgs []*LoggerMockInfoContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockInfoContextExpectation specifies expectation struct of the Logger.InfoContext
type LoggerMockInfoContextExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockInfoContextParams
	paramPtrs          *LoggerMockInfoContextParamPtrs
	expectationOrigins LoggerMockInfoContextExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockInfoContextParams contains parameters of the Logger.InfoContext
type LoggerMockInfoContextParams struct {
	ctx  context.Context
	msg  string
	args []any
}

// LoggerMockInfoContextParamPtrs contains pointers to parameters of the Logger.InfoContext
type LoggerMockInfoContextParamPtrs struct {
	ctx  *context.Context
	msg  *string
	args *[]any
}

// LoggerMockInfoContextOrigins contains origins of expectations of the Logger.InfoContext
type LoggerMockInfoContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfoContext *mLoggerMockInfoContext) Optional() *mLoggerMockInfoContext {
	mmInfoContext.optional = true
	return mmInfoContext
}

// Expect sets up expected params for Logger.InfoContext
func (mmInfoContext *mLoggerMockInfoContext) Expect(ctx context.Context, msg string, args ...any) *mLoggerMockInfoContext {
	if mmInfoContext.mock.funcInfoContext != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Set")
	}

	if mmInfoContext.defaultExpectation == nil {
		mmInfoContext.defaultExpectation = &LoggerMockInfoContextExpectation{}
	}

	if mmInfoContext.defaultExpectation.paramPtrs != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by ExpectParams functions")
	}

	mmInfoContext.defaultExpectation.params = &LoggerMockInfoContextParams{ctx, msg, args}
	mmInfoContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfoContext.expectations {
		if minimock.Equal(e.params, mmInfoContext.defaultExpectation.params) {
			mmInfoContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfoContext.defaultExpectation.params)
		}
	}

	return mmInfoContext
}

// ExpectCtxParam1 sets up expected param ctx for Logger.InfoContext
func (mmInfoContext *mLoggerMockInfoContext) ExpectCtxParam1(ctx context.Context) *mLoggerMockInfoContext {
	if mmInfoContext.mock.funcInfoContext != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Set")
	}

	if mmInfoContext.defaultExpectation == nil {
		mmInfoContext.defaultExpectation = &LoggerMockInfoContextExpectation{}
	}

	if mmInfoContext.defaultExpectation.params != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Expect")
	}

	if mmInfoContext.defaultExpectation.paramPtrs == nil {
		mmInfoContext.defaultExpectation.paramPtrs = &LoggerMockInfoContextParamPtrs{}
	}
	mmInfoContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmInfoContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInfoContext
}

// ExpectMsgParam2 sets up expected param msg for Logger.InfoContext
func (mmInfoContext *mLoggerMockInfoContext) ExpectMsgParam2(msg string) *mLoggerMockInfoContext {
	if mmInfoContext.mock.funcInfoContext != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Set")
	}

	if mmInfoContext.defaultExpectation == nil {
		mmInfoContext.defaultExpectation = &LoggerMockInfoContextExpectation{}
	}

	if mmInfoContext.defaultExpectation.params != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Expect")
	}

	if mmInfoContext.defaultExpectation.paramPtrs == nil {
		mmInfoContext.defaultExpectation.paramPtrs = &LoggerMockInfoContextParamPtrs{}
	}
	mmInfoContext.defaultExpectation.paramPtrs.msg = &msg
	mmInfoContext.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmInfoContext
}

// ExpectArgsParam3 sets up expected param args for Logger.InfoContext
func (mmInfoContext *mLoggerMockInfoContext) ExpectArgsParam3(args ...any) *mLoggerMockInfoContext {
	if mmInfoContext.mock.funcInfoContext != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Set")
	}

	if mmInfoContext.defaultExpectation == nil {
		mmInfoContext.defaultExpectation = &LoggerMockInfoContextExpectation{}
	}

	if mmInfoContext.defaultExpectation.params != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Expect")
	}

	if mmInfoContext.defaultExpectation.paramPtrs == nil {
		mmInfoContext.defaultExpectation.paramPtrs = &LoggerMockInfoContextParamPtrs{}
	}
	mmInfoContext.defaultExpectation.paramPtrs.args = &args
	mmInfoContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmInfoContext
}

// Inspect accepts an inspector function that has same arguments as the Logger.InfoContext
func (mmInfoContext *mLoggerMockInfoContext) Inspect(f func(ctx context.Context, msg string, args ...any)) *mLoggerMockInfoContext {
	if mmInfoContext.mock.inspectFuncInfoContext != nil {
		mmInfoContext.mock.t.Fatalf("Inspect function is already set for LoggerMock.InfoContext")
	}

	mmInfoContext.mock.inspectFuncInfoContext = f

	return mmInfoContext
}

// Return sets up results that will be returned by Logger.InfoContext
func (mmInfoContext *mLoggerMockInfoContext) Return() *LoggerMock {
	if mmInfoContext.mock.funcInfoContext != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Set")
	}

	if mmInfoContext.defaultExpectation == nil {
		mmInfoContext.defaultExpectation = &LoggerMockInfoContextExpectation{mock: mmInfoContext.mock}
	}

	mmInfoContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfoContext.mock
}

// Set uses given function f to mock the Logger.InfoContext method
func (mmInfoContext *mLoggerMockInfoContext) Set(f func(ctx context.Context, msg string, args ...any)) *LoggerMock {
	if mmInfoContext.defaultExpectation != nil {
		mmInfoContext.mock.t.Fatalf("Default expectation is already set for the Logger.InfoContext method")
	}

	if len(mmInfoContext.expectations) > 0 {
		mmInfoContext.mock.t.Fatalf("Some expectations are already set for the Logger.InfoContext method")
	}

	mmInfoContext.mock.funcInfoContext = f
	mmInfoContext.mock.funcInfoContextOrigin = minimock.CallerInfo(1)
	return mmInfoContext.mock
}

// When sets expectation for the Logger.InfoContext which will trigger the result defined by the following
// Then helper
func (mmInfoContext *mLoggerMockInfoContext) When(ctx context.Context, msg string, args ...any) *LoggerMockInfoContextExpectation {
	if mmInfoContext.mock.funcInfoContext != nil {
		mmInfoContext.mock.t.Fatalf("LoggerMock.InfoContext mock is already set by Set")
	}

	expectation := &LoggerMockInfoContextExpectation{
		mock:               mmInfoContext.mock,
		params:             &LoggerMockInfoContextParams{ctx, msg, args},
		expectationOrigins: LoggerMockInfoContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfoContext.expectations = append(mmInfoContext.expectations, expectation)
	return expectation
}

// Then sets up Logger.InfoContext return parameters for the expectation previously defined by the When method
func (e *LoggerMockInfoContextExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.InfoContext should be invoked
func (mmInfoContext *mLoggerMockInfoContext) Times(n uint64) *mLoggerMockInfoContext {
	if n == 0 {
		mmInfoContext.mock.t.Fatalf("Times of LoggerMock.InfoContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfoContext.expectedInvocations, n)
	mmInfoContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfoContext
}

func (mmInfoContext *mLoggerMockInfoContext) invocationsDone() bool {
	if len(mmInfoContext.expectations) == 0 && mmInfoContext.defaultExpectation == nil && mmInfoContext.mock.funcInfoContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfoContext.mock.afterInfoContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfoContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InfoContext implements mm_pkg.Logger
func (mmInfoContext *LoggerMock) InfoContext(ctx context.Context, msg string, args ...any) {
	mm_atomic.AddUint64(&mmInfoContext.beforeInfoContextCounter, 1)
	defer mm_atomic.AddUint64(&mmInfoContext.afterInfoContextCounter, 1)

	mmInfoContext.t.Helper()

	if mmInfoContext.inspectFuncInfoContext != nil {
		mmInfoContext.inspectFuncInfoContext(ctx, msg, args...)
	}

	mm_params := LoggerMockInfoContextParams{ctx, msg, args}

	// Record call args
	mmInfoContext.InfoContextMock.mutex.Lock()
	mmInfoContext.InfoContextMock.callArgs = append(mmInfoContext.InfoContextMock.callArgs, &mm_params)
	mmInfoContext.InfoContextMock.mutex.Unlock()

	for _, e := range mmInfoContext.InfoContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfoContext.InfoContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfoContext.InfoContextMock.defaultExpectation.Counter, 1)
		mm_want := mmInfoContext.InfoContextMock.defaultExpectation.params
		mm_want_ptrs := mmInfoContext.InfoContextMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfoContextParams{ctx, msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInfoContext.t.Errorf("LoggerMock.InfoContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfoContext.InfoContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmInfoContext.t.Errorf("LoggerMock.InfoContext got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfoContext.InfoContextMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmInfoContext.t.Errorf("LoggerMock.InfoContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfoContext.InfoContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfoContext.t.Errorf("LoggerMock.InfoContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfoContext.InfoContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfoContext.funcInfoContext != nil {
		mmInfoContext.funcInfoContext(ctx, msg, args...)
		return
	}
	mmInfoContext.t.Fatalf("Unexpected call to LoggerMock.InfoContext. %v %v %v", ctx, msg, args)

}

// InfoContextAfterCounter returns a count of finished LoggerMock.InfoContext invocations
func (mmInfoContext *LoggerMock) InfoContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfoContext.afterInfoContextCounter)
}

// InfoContextBeforeCounter returns a count of LoggerMock.InfoContext invocations
func (mmInfoContext *LoggerMock) InfoContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfoContext.beforeInfoContextCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.InfoContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfoContext *mLoggerMockInfoContext) Calls() []*LoggerMockInfoContextParams {
	mmInfoContext.mutex.RLock()

	argCopy := make([]*LoggerMockInfoContextParams, len(mmInfoContext.callArgs))
	copy(argCopy, mmInfoContext.callArgs)

	mmInfoContext.mutex.RUnlock()

	return argCopy
}

// MinimockInfoContextDone returns true if the count of the InfoContext invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoContextDone() bool {
	if m.InfoContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoContextMock.invocationsDone()
}

// MinimockInfoContextInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoContextInspect() {
	for _, e := range m.InfoContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.InfoContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfoContextCounter := mm_atomic.LoadUint64(&m.afterInfoContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoContextMock.defaultExpectation != nil && afterInfoContextCounter < 1 {
		if m.InfoContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.InfoContext at\n%s", m.InfoContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.InfoContext at\n%s with params: %#v", m.InfoContextMock.defaultExpectation.expectationOrigins.origin, *m.InfoContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfoContext != nil && afterInfoContextCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.InfoContext at\n%s", m.funcInfoContextOrigin)
	}

	if !m.InfoContextMock.invocationsDone() && afterInfoContextCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.InfoContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfoContextMock.expectedInvocations), m.InfoContextMock.expectedInvocationsOrigin, afterInfoContextCounter)
	}
}

type mLoggerMockLog struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockLogExpectation
	expectations       []*LoggerMockLogExpectation

	callArgs []*LoggerMockLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockLogExpectation specifies expectation struct of the Logger.Log
type LoggerMockLogExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockLogParams
	paramPtrs          *LoggerMockLogParamPtrs
	expectationOrigins LoggerMockLogExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockLogParams contains parameters of the Logger.Log
type LoggerMockLogParams struct {
	ctx   context.Context
	level slog.Level
	msg   string
	args  []any
}

// LoggerMockLogParamPtrs contains pointers to parameters of the Logger.Log
type LoggerMockLogParamPtrs struct {
	ctx   *context.Context
	level *slog.Level
	msg   *string
	args  *[]any
}

// LoggerMockLogOrigins contains origins of expectations of the Logger.Log
type LoggerMockLogExpectationOrigins struct {
	origin      string
	originCtx   string
	originLevel string
	originMsg   string
	originArgs  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLog *mLoggerMockLog) Optional() *mLoggerMockLog {
	mmLog.optional = true
	return mmLog
}

// Expect sets up expected params for Logger.Log
func (mmLog *mLoggerMockLog) Expect(ctx context.Context, level slog.Level, msg string, args ...any) *mLoggerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &LoggerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.paramPtrs != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by ExpectParams functions")
	}

	mmLog.defaultExpectation.params = &LoggerMockLogParams{ctx, level, msg, args}
	mmLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLog.expectations {
		if minimock.Equal(e.params, mmLog.defaultExpectation.params) {
			mmLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLog.defaultExpectation.params)
		}
	}

	return mmLog
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Log
func (mmLog *mLoggerMockLog) ExpectCtxParam1(ctx context.Context) *mLoggerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &LoggerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &LoggerMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLog
}

// ExpectLevelParam2 sets up expected param level for Logger.Log
func (mmLog *mLoggerMockLog) ExpectLevelParam2(level slog.Level) *mLoggerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &LoggerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &LoggerMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.level = &level
	mmLog.defaultExpectation.expectationOrigins.originLevel = minimock.CallerInfo(1)

	return mmLog
}

// ExpectMsgParam3 sets up expected param msg for Logger.Log
func (mmLog *mLoggerMockLog) ExpectMsgParam3(msg string) *mLoggerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &LoggerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &LoggerMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.msg = &msg
	mmLog.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmLog
}

// ExpectArgsParam4 sets up expected param args for Logger.Log
func (mmLog *mLoggerMockLog) ExpectArgsParam4(args ...any) *mLoggerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &LoggerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &LoggerMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.args = &args
	mmLog.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the Logger.Log
func (mmLog *mLoggerMockLog) Inspect(f func(ctx context.Context, level slog.Level, msg string, args ...any)) *mLoggerMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for LoggerMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by Logger.Log
func (mmLog *mLoggerMockLog) Return() *LoggerMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &LoggerMockLogExpectation{mock: mmLog.mock}
	}

	mmLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// Set uses given function f to mock the Logger.Log method
func (mmLog *mLoggerMockLog) Set(f func(ctx context.Context, level slog.Level, msg string, args ...any)) *LoggerMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the Logger.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the Logger.Log method")
	}

	mmLog.mock.funcLog = f
	mmLog.mock.funcLogOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// When sets expectation for the Logger.Log which will trigger the result defined by the following
// Then helper
func (mmLog *mLoggerMockLog) When(ctx context.Context, level slog.Level, msg string, args ...any) *LoggerMockLogExpectation {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("LoggerMock.Log mock is already set by Set")
	}

	expectation := &LoggerMockLogExpectation{
		mock:               mmLog.mock,
		params:             &LoggerMockLogParams{ctx, level, msg, args},
		expectationOrigins: LoggerMockLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLog.expectations = append(mmLog.expectations, expectation)
	return expectation
}

// Then sets up Logger.Log return parameters for the expectation previously defined by the When method
func (e *LoggerMockLogExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Log should be invoked
func (mmLog *mLoggerMockLog) Times(n uint64) *mLoggerMockLog {
	if n == 0 {
		mmLog.mock.t.Fatalf("Times of LoggerMock.Log mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLog.expectedInvocations, n)
	mmLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLog
}

func (mmLog *mLoggerMockLog) invocationsDone() bool {
	if len(mmLog.expectations) == 0 && mmLog.defaultExpectation == nil && mmLog.mock.funcLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLog.mock.afterLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Log implements mm_pkg.Logger
func (mmLog *LoggerMock) Log(ctx context.Context, level slog.Level, msg string, args ...any) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	mmLog.t.Helper()

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog(ctx, level, msg, args...)
	}

	mm_params := LoggerMockLogParams{ctx, level, msg, args}

	// Record call args
	mmLog.LogMock.mutex.Lock()
	mmLog.LogMock.callArgs = append(mmLog.LogMock.callArgs, &mm_params)
	mmLog.LogMock.mutex.Unlock()

	for _, e := range mmLog.LogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)
		mm_want := mmLog.LogMock.defaultExpectation.params
		mm_want_ptrs := mmLog.LogMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockLogParams{ctx, level, msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLog.t.Errorf("LoggerMock.Log got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.level != nil && !minimock.Equal(*mm_want_ptrs.level, mm_got.level) {
				mmLog.t.Errorf("LoggerMock.Log got unexpected parameter level, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originLevel, *mm_want_ptrs.level, mm_got.level, minimock.Diff(*mm_want_ptrs.level, mm_got.level))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmLog.t.Errorf("LoggerMock.Log got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmLog.t.Errorf("LoggerMock.Log got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLog.t.Errorf("LoggerMock.Log got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLog.LogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmLog.funcLog != nil {
		mmLog.funcLog(ctx, level, msg, args...)
		return
	}
	mmLog.t.Fatalf("Unexpected call to LoggerMock.Log. %v %v %v %v", ctx, level, msg, args)

}

// LogAfterCounter returns a count of finished LoggerMock.Log invocations
func (mmLog *LoggerMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of LoggerMock.Log invocations
func (mmLog *LoggerMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Log.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLog *mLoggerMockLog) Calls() []*LoggerMockLogParams {
	mmLog.mutex.RLock()

	argCopy := make([]*LoggerMockLogParams, len(mmLog.callArgs))
	copy(argCopy, mmLog.callArgs)

	mmLog.mutex.RUnlock()

	return argCopy
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockLogDone() bool {
	if m.LogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogMock.invocationsDone()
}

// MinimockLogInspect logs each unmet expectation
func (m *LoggerMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Log at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogCounter := mm_atomic.LoadUint64(&m.afterLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && afterLogCounter < 1 {
		if m.LogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Log at\n%s", m.LogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Log at\n%s with params: %#v", m.LogMock.defaultExpectation.expectationOrigins.origin, *m.LogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && afterLogCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Log at\n%s", m.funcLogOrigin)
	}

	if !m.LogMock.invocationsDone() && afterLogCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Log at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogMock.expectedInvocations), m.LogMock.expectedInvocationsOrigin, afterLogCounter)
	}
}

type mLoggerMockLogAttrs struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockLogAttrsExpectation
	expectations       []*LoggerMockLogAttrsExpectation

	callArgs []*LoggerMockLogAttrsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockLogAttrsExpectation specifies expectation struct of the Logger.LogAttrs
type LoggerMockLogAttrsExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockLogAttrsParams
	paramPtrs          *LoggerMockLogAttrsParamPtrs
	expectationOrigins LoggerMockLogAttrsExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockLogAttrsParams contains parameters of the Logger.LogAttrs
type LoggerMockLogAttrsParams struct {
	ctx   context.Context
	level slog.Level
	msg   string
	attrs []slog.Attr
}

// LoggerMockLogAttrsParamPtrs contains pointers to parameters of the Logger.LogAttrs
type LoggerMockLogAttrsParamPtrs struct {
	ctx   *context.Context
	level *slog.Level
	msg   *string
	attrs *[]slog.Attr
}

// LoggerMockLogAttrsOrigins contains origins of expectations of the Logger.LogAttrs
type LoggerMockLogAttrsExpectationOrigins struct {
	origin      string
	originCtx   string
	originLevel string
	originMsg   string
	originAttrs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogAttrs *mLoggerMockLogAttrs) Optional() *mLoggerMockLogAttrs {
	mmLogAttrs.optional = true
	return mmLogAttrs
}

// Expect sets up expected params for Logger.LogAttrs
func (mmLogAttrs *mLoggerMockLogAttrs) Expect(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr) *mLoggerMockLogAttrs {
	if mmLogAttrs.mock.funcLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Set")
	}

	if mmLogAttrs.defaultExpectation == nil {
		mmLogAttrs.defaultExpectation = &LoggerMockLogAttrsExpectation{}
	}

	if mmLogAttrs.defaultExpectation.paramPtrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by ExpectParams functions")
	}

	mmLogAttrs.defaultExpectation.params = &LoggerMockLogAttrsParams{ctx, level, msg, attrs}
	mmLogAttrs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogAttrs.expectations {
		if minimock.Equal(e.params, mmLogAttrs.defaultExpectation.params) {
			mmLogAttrs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogAttrs.defaultExpectation.params)
		}
	}

	return mmLogAttrs
}

// ExpectCtxParam1 sets up expected param ctx for Logger.LogAttrs
func (mmLogAttrs *mLoggerMockLogAttrs) ExpectCtxParam1(ctx context.Context) *mLoggerMockLogAttrs {
	if mmLogAttrs.mock.funcLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Set")
	}

	if mmLogAttrs.defaultExpectation == nil {
		mmLogAttrs.defaultExpectation = &LoggerMockLogAttrsExpectation{}
	}

	if mmLogAttrs.defaultExpectation.params != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Expect")
	}

	if mmLogAttrs.defaultExpectation.paramPtrs == nil {
		mmLogAttrs.defaultExpectation.paramPtrs = &LoggerMockLogAttrsParamPtrs{}
	}
	mmLogAttrs.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogAttrs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogAttrs
}

// ExpectLevelParam2 sets up expected param level for Logger.LogAttrs
func (mmLogAttrs *mLoggerMockLogAttrs) ExpectLevelParam2(level slog.Level) *mLoggerMockLogAttrs {
	if mmLogAttrs.mock.funcLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Set")
	}

	if mmLogAttrs.defaultExpectation == nil {
		mmLogAttrs.defaultExpectation = &LoggerMockLogAttrsExpectation{}
	}

	if mmLogAttrs.defaultExpectation.params != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Expect")
	}

	if mmLogAttrs.defaultExpectation.paramPtrs == nil {
		mmLogAttrs.defaultExpectation.paramPtrs = &LoggerMockLogAttrsParamPtrs{}
	}
	mmLogAttrs.defaultExpectation.paramPtrs.level = &level
	mmLogAttrs.defaultExpectation.expectationOrigins.originLevel = minimock.CallerInfo(1)

	return mmLogAttrs
}

// ExpectMsgParam3 sets up expected param msg for Logger.LogAttrs
func (mmLogAttrs *mLoggerMockLogAttrs) ExpectMsgParam3(msg string) *mLoggerMockLogAttrs {
	if mmLogAttrs.mock.funcLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Set")
	}

	if mmLogAttrs.defaultExpectation == nil {
		mmLogAttrs.defaultExpectation = &LoggerMockLogAttrsExpectation{}
	}

	if mmLogAttrs.defaultExpectation.params != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Expect")
	}

	if mmLogAttrs.defaultExpectation.paramPtrs == nil {
		mmLogAttrs.defaultExpectation.paramPtrs = &LoggerMockLogAttrsParamPtrs{}
	}
	mmLogAttrs.defaultExpectation.paramPtrs.msg = &msg
	mmLogAttrs.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmLogAttrs
}

// ExpectAttrsParam4 sets up expected param attrs for Logger.LogAttrs
func (mmLogAttrs *mLoggerMockLogAttrs) ExpectAttrsParam4(attrs ...slog.Attr) *mLoggerMockLogAttrs {
	if mmLogAttrs.mock.funcLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Set")
	}

	if mmLogAttrs.defaultExpectation == nil {
		mmLogAttrs.defaultExpectation = &LoggerMockLogAttrsExpectation{}
	}

	if mmLogAttrs.defaultExpectation.params != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Expect")
	}

	if mmLogAttrs.defaultExpectation.paramPtrs == nil {
		mmLogAttrs.defaultExpectation.paramPtrs = &LoggerMockLogAttrsParamPtrs{}
	}
	mmLogAttrs.defaultExpectation.paramPtrs.attrs = &attrs
	mmLogAttrs.defaultExpectation.expectationOrigins.originAttrs = minimock.CallerInfo(1)

	return mmLogAttrs
}

// Inspect accepts an inspector function that has same arguments as the Logger.LogAttrs
func (mmLogAttrs *mLoggerMockLogAttrs) Inspect(f func(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr)) *mLoggerMockLogAttrs {
	if mmLogAttrs.mock.inspectFuncLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("Inspect function is already set for LoggerMock.LogAttrs")
	}

	mmLogAttrs.mock.inspectFuncLogAttrs = f

	return mmLogAttrs
}

// Return sets up results that will be returned by Logger.LogAttrs
func (mmLogAttrs *mLoggerMockLogAttrs) Return() *LoggerMock {
	if mmLogAttrs.mock.funcLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Set")
	}

	if mmLogAttrs.defaultExpectation == nil {
		mmLogAttrs.defaultExpectation = &LoggerMockLogAttrsExpectation{mock: mmLogAttrs.mock}
	}

	mmLogAttrs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogAttrs.mock
}

// Set uses given function f to mock the Logger.LogAttrs method
func (mmLogAttrs *mLoggerMockLogAttrs) Set(f func(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr)) *LoggerMock {
	if mmLogAttrs.defaultExpectation != nil {
		mmLogAttrs.mock.t.Fatalf("Default expectation is already set for the Logger.LogAttrs method")
	}

	if len(mmLogAttrs.expectations) > 0 {
		mmLogAttrs.mock.t.Fatalf("Some expectations are already set for the Logger.LogAttrs method")
	}

	mmLogAttrs.mock.funcLogAttrs = f
	mmLogAttrs.mock.funcLogAttrsOrigin = minimock.CallerInfo(1)
	return mmLogAttrs.mock
}

// When sets expectation for the Logger.LogAttrs which will trigger the result defined by the following
// Then helper
func (mmLogAttrs *mLoggerMockLogAttrs) When(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr) *LoggerMockLogAttrsExpectation {
	if mmLogAttrs.mock.funcLogAttrs != nil {
		mmLogAttrs.mock.t.Fatalf("LoggerMock.LogAttrs mock is already set by Set")
	}

	expectation := &LoggerMockLogAttrsExpectation{
		mock:               mmLogAttrs.mock,
		params:             &LoggerMockLogAttrsParams{ctx, level, msg, attrs},
		expectationOrigins: LoggerMockLogAttrsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogAttrs.expectations = append(mmLogAttrs.expectations, expectation)
	return expectation
}

// Then sets up Logger.LogAttrs return parameters for the expectation previously defined by the When method
func (e *LoggerMockLogAttrsExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.LogAttrs should be invoked
func (mmLogAttrs *mLoggerMockLogAttrs) Times(n uint64) *mLoggerMockLogAttrs {
	if n == 0 {
		mmLogAttrs.mock.t.Fatalf("Times of LoggerMock.LogAttrs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogAttrs.expectedInvocations, n)
	mmLogAttrs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogAttrs
}

func (mmLogAttrs *mLoggerMockLogAttrs) invocationsDone() bool {
	if len(mmLogAttrs.expectations) == 0 && mmLogAttrs.defaultExpectation == nil && mmLogAttrs.mock.funcLogAttrs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogAttrs.mock.afterLogAttrsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogAttrs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LogAttrs implements mm_pkg.Logger
func (mmLogAttrs *LoggerMock) LogAttrs(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr) {
	mm_atomic.AddUint64(&mmLogAttrs.beforeLogAttrsCounter, 1)
	defer mm_atomic.AddUint64(&mmLogAttrs.afterLogAttrsCounter, 1)

	mmLogAttrs.t.Helper()

	if mmLogAttrs.inspectFuncLogAttrs != nil {
		mmLogAttrs.inspectFuncLogAttrs(ctx, level, msg, attrs...)
	}

	mm_params := LoggerMockLogAttrsParams{ctx, level, msg, attrs}

	// Record call args
	mmLogAttrs.LogAttrsMock.mutex.Lock()
	mmLogAttrs.LogAttrsMock.callArgs = append(mmLogAttrs.LogAttrsMock.callArgs, &mm_params)
	mmLogAttrs.LogAttrsMock.mutex.Unlock()

	for _, e := range mmLogAttrs.LogAttrsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmLogAttrs.LogAttrsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogAttrs.LogAttrsMock.defaultExpectation.Counter, 1)
		mm_want := mmLogAttrs.LogAttrsMock.defaultExpectation.params
		mm_want_ptrs := mmLogAttrs.LogAttrsMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockLogAttrsParams{ctx, level, msg, attrs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogAttrs.t.Errorf("LoggerMock.LogAttrs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogAttrs.LogAttrsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.level != nil && !minimock.Equal(*mm_want_ptrs.level, mm_got.level) {
				mmLogAttrs.t.Errorf("LoggerMock.LogAttrs got unexpected parameter level, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogAttrs.LogAttrsMock.defaultExpectation.expectationOrigins.originLevel, *mm_want_ptrs.level, mm_got.level, minimock.Diff(*mm_want_ptrs.level, mm_got.level))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmLogAttrs.t.Errorf("LoggerMock.LogAttrs got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogAttrs.LogAttrsMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.attrs != nil && !minimock.Equal(*mm_want_ptrs.attrs, mm_got.attrs) {
				mmLogAttrs.t.Errorf("LoggerMock.LogAttrs got unexpected parameter attrs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogAttrs.LogAttrsMock.defaultExpectation.expectationOrigins.originAttrs, *mm_want_ptrs.attrs, mm_got.attrs, minimock.Diff(*mm_want_ptrs.attrs, mm_got.attrs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogAttrs.t.Errorf("LoggerMock.LogAttrs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogAttrs.LogAttrsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmLogAttrs.funcLogAttrs != nil {
		mmLogAttrs.funcLogAttrs(ctx, level, msg, attrs...)
		return
	}
	mmLogAttrs.t.Fatalf("Unexpected call to LoggerMock.LogAttrs. %v %v %v %v", ctx, level, msg, attrs)

}

// LogAttrsAfterCounter returns a count of finished LoggerMock.LogAttrs invocations
func (mmLogAttrs *LoggerMock) LogAttrsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogAttrs.afterLogAttrsCounter)
}

// LogAttrsBeforeCounter returns a count of LoggerMock.LogAttrs invocations
func (mmLogAttrs *LoggerMock) LogAttrsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogAttrs.beforeLogAttrsCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.LogAttrs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogAttrs *mLoggerMockLogAttrs) Calls() []*LoggerMockLogAttrsParams {
	mmLogAttrs.mutex.RLock()

	argCopy := make([]*LoggerMockLogAttrsParams, len(mmLogAttrs.callArgs))
	copy(argCopy, mmLogAttrs.callArgs)

	mmLogAttrs.mutex.RUnlock()

	return argCopy
}

// MinimockLogAttrsDone returns true if the count of the LogAttrs invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockLogAttrsDone() bool {
	if m.LogAttrsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogAttrsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogAttrsMock.invocationsDone()
}

// MinimockLogAttrsInspect logs each unmet expectation
func (m *LoggerMock) MinimockLogAttrsInspect() {
	for _, e := range m.LogAttrsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.LogAttrs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogAttrsCounter := mm_atomic.LoadUint64(&m.afterLogAttrsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogAttrsMock.defaultExpectation != nil && afterLogAttrsCounter < 1 {
		if m.LogAttrsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.LogAttrs at\n%s", m.LogAttrsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.LogAttrs at\n%s with params: %#v", m.LogAttrsMock.defaultExpectation.expectationOrigins.origin, *m.LogAttrsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogAttrs != nil && afterLogAttrsCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.LogAttrs at\n%s", m.funcLogAttrsOrigin)
	}

	if !m.LogAttrsMock.invocationsDone() && afterLogAttrsCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.LogAttrs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogAttrsMock.expectedInvocations), m.LogAttrsMock.expectedInvocationsOrigin, afterLogAttrsCounter)
	}
}

type mLoggerMockNamed struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockNamedExpectation
	expectations       []*LoggerMockNamedExpectation

	callArgs []*LoggerMockNamedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockNamedExpectation specifies expectation struct of the Logger.Named
type LoggerMockNamedExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockNamedParams
	paramPtrs          *LoggerMockNamedParamPtrs
	expectationOrigins LoggerMockNamedExpectationOrigins
	results            *LoggerMockNamedResults
	returnOrigin       string
	Counter            uint64
}

// LoggerMockNamedParams contains parameters of the Logger.Named
type LoggerMockNamedParams struct {
	name string
}

// LoggerMockNamedParamPtrs contains pointers to parameters of the Logger.Named
type LoggerMockNamedParamPtrs struct {
	name *string
}

// LoggerMockNamedResults contains results of the Logger.Named
type LoggerMockNamedResults struct {
	lp1 *log.Logger
}

// LoggerMockNamedOrigins contains origins of expectations of the Logger.Named
type LoggerMockNamedExpectationOrigins struct {
	origin     string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNamed *mLoggerMockNamed) Optional() *mLoggerMockNamed {
	mmNamed.optional = true
	return mmNamed
}

// Expect sets up expected params for Logger.Named
func (mmNamed *mLoggerMockNamed) Expect(name string) *mLoggerMockNamed {
	if mmNamed.mock.funcNamed != nil {
		mmNamed.mock.t.Fatalf("LoggerMock.Named mock is already set by Set")
	}

	if mmNamed.defaultExpectation == nil {
		mmNamed.defaultExpectation = &LoggerMockNamedExpectation{}
	}

	if mmNamed.defaultExpectation.paramPtrs != nil {
		mmNamed.mock.t.Fatalf("LoggerMock.Named mock is already set by ExpectParams functions")
	}

	mmNamed.defaultExpectation.params = &LoggerMockNamedParams{name}
	mmNamed.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNamed.expectations {
		if minimock.Equal(e.params, mmNamed.defaultExpectation.params) {
			mmNamed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNamed.defaultExpectation.params)
		}
	}

	return mmNamed
}

// ExpectNameParam1 sets up expected param name for Logger.Named
func (mmNamed *mLoggerMockNamed) ExpectNameParam1(name string) *mLoggerMockNamed {
	if mmNamed.mock.funcNamed != nil {
		mmNamed.mock.t.Fatalf("LoggerMock.Named mock is already set by Set")
	}

	if mmNamed.defaultExpectation == nil {
		mmNamed.defaultExpectation = &LoggerMockNamedExpectation{}
	}

	if mmNamed.defaultExpectation.params != nil {
		mmNamed.mock.t.Fatalf("LoggerMock.Named mock is already set by Expect")
	}

	if mmNamed.defaultExpectation.paramPtrs == nil {
		mmNamed.defaultExpectation.paramPtrs = &LoggerMockNamedParamPtrs{}
	}
	mmNamed.defaultExpectation.paramPtrs.name = &name
	mmNamed.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmNamed
}

// Inspect accepts an inspector function that has same arguments as the Logger.Named
func (mmNamed *mLoggerMockNamed) Inspect(f func(name string)) *mLoggerMockNamed {
	if mmNamed.mock.inspectFuncNamed != nil {
		mmNamed.mock.t.Fatalf("Inspect function is already set for LoggerMock.Named")
	}

	mmNamed.mock.inspectFuncNamed = f

	return mmNamed
}

// Return sets up results that will be returned by Logger.Named
func (mmNamed *mLoggerMockNamed) Return(lp1 *log.Logger) *LoggerMock {
	if mmNamed.mock.funcNamed != nil {
		mmNamed.mock.t.Fatalf("LoggerMock.Named mock is already set by Set")
	}

	if mmNamed.defaultExpectation == nil {
		mmNamed.defaultExpectation = &LoggerMockNamedExpectation{mock: mmNamed.mock}
	}
	mmNamed.defaultExpectation.results = &LoggerMockNamedResults{lp1}
	mmNamed.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNamed.mock
}

// Set uses given function f to mock the Logger.Named method
func (mmNamed *mLoggerMockNamed) Set(f func(name string) (lp1 *log.Logger)) *LoggerMock {
	if mmNamed.defaultExpectation != nil {
		mmNamed.mock.t.Fatalf("Default expectation is already set for the Logger.Named method")
	}

	if len(mmNamed.expectations) > 0 {
		mmNamed.mock.t.Fatalf("Some expectations are already set for the Logger.Named method")
	}

	mmNamed.mock.funcNamed = f
	mmNamed.mock.funcNamedOrigin = minimock.CallerInfo(1)
	return mmNamed.mock
}

// When sets expectation for the Logger.Named which will trigger the result defined by the following
// Then helper
func (mmNamed *mLoggerMockNamed) When(name string) *LoggerMockNamedExpectation {
	if mmNamed.mock.funcNamed != nil {
		mmNamed.mock.t.Fatalf("LoggerMock.Named mock is already set by Set")
	}

	expectation := &LoggerMockNamedExpectation{
		mock:               mmNamed.mock,
		params:             &LoggerMockNamedParams{name},
		expectationOrigins: LoggerMockNamedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNamed.expectations = append(mmNamed.expectations, expectation)
	return expectation
}

// Then sets up Logger.Named return parameters for the expectation previously defined by the When method
func (e *LoggerMockNamedExpectation) Then(lp1 *log.Logger) *LoggerMock {
	e.results = &LoggerMockNamedResults{lp1}
	return e.mock
}

// Times sets number of times Logger.Named should be invoked
func (mmNamed *mLoggerMockNamed) Times(n uint64) *mLoggerMockNamed {
	if n == 0 {
		mmNamed.mock.t.Fatalf("Times of LoggerMock.Named mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNamed.expectedInvocations, n)
	mmNamed.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNamed
}

func (mmNamed *mLoggerMockNamed) invocationsDone() bool {
	if len(mmNamed.expectations) == 0 && mmNamed.defaultExpectation == nil && mmNamed.mock.funcNamed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNamed.mock.afterNamedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNamed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Named implements mm_pkg.Logger
func (mmNamed *LoggerMock) Named(name string) (lp1 *log.Logger) {
	mm_atomic.AddUint64(&mmNamed.beforeNamedCounter, 1)
	defer mm_atomic.AddUint64(&mmNamed.afterNamedCounter, 1)

	mmNamed.t.Helper()

	if mmNamed.inspectFuncNamed != nil {
		mmNamed.inspectFuncNamed(name)
	}

	mm_params := LoggerMockNamedParams{name}

	// Record call args
	mmNamed.NamedMock.mutex.Lock()
	mmNamed.NamedMock.callArgs = append(mmNamed.NamedMock.callArgs, &mm_params)
	mmNamed.NamedMock.mutex.Unlock()

	for _, e := range mmNamed.NamedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1
		}
	}

	if mmNamed.NamedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNamed.NamedMock.defaultExpectation.Counter, 1)
		mm_want := mmNamed.NamedMock.defaultExpectation.params
		mm_want_ptrs := mmNamed.NamedMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockNamedParams{name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmNamed.t.Errorf("LoggerMock.Named got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNamed.NamedMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNamed.t.Errorf("LoggerMock.Named got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNamed.NamedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNamed.NamedMock.defaultExpectation.results
		if mm_results == nil {
			mmNamed.t.Fatal("No results are set for the LoggerMock.Named")
		}
		return (*mm_results).lp1
	}
	if mmNamed.funcNamed != nil {
		return mmNamed.funcNamed(name)
	}
	mmNamed.t.Fatalf("Unexpected call to LoggerMock.Named. %v", name)
	return
}

// NamedAfterCounter returns a count of finished LoggerMock.Named invocations
func (mmNamed *LoggerMock) NamedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNamed.afterNamedCounter)
}

// NamedBeforeCounter returns a count of LoggerMock.Named invocations
func (mmNamed *LoggerMock) NamedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNamed.beforeNamedCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Named.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNamed *mLoggerMockNamed) Calls() []*LoggerMockNamedParams {
	mmNamed.mutex.RLock()

	argCopy := make([]*LoggerMockNamedParams, len(mmNamed.callArgs))
	copy(argCopy, mmNamed.callArgs)

	mmNamed.mutex.RUnlock()

	return argCopy
}

// MinimockNamedDone returns true if the count of the Named invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockNamedDone() bool {
	if m.NamedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NamedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NamedMock.invocationsDone()
}

// MinimockNamedInspect logs each unmet expectation
func (m *LoggerMock) MinimockNamedInspect() {
	for _, e := range m.NamedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Named at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNamedCounter := mm_atomic.LoadUint64(&m.afterNamedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NamedMock.defaultExpectation != nil && afterNamedCounter < 1 {
		if m.NamedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Named at\n%s", m.NamedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Named at\n%s with params: %#v", m.NamedMock.defaultExpectation.expectationOrigins.origin, *m.NamedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNamed != nil && afterNamedCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Named at\n%s", m.funcNamedOrigin)
	}

	if !m.NamedMock.invocationsDone() && afterNamedCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Named at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NamedMock.expectedInvocations), m.NamedMock.expectedInvocationsOrigin, afterNamedCounter)
	}
}

type mLoggerMockSetLevel struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockSetLevelExpectation
	expectations       []*LoggerMockSetLevelExpectation

	callArgs []*LoggerMockSetLevelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockSetLevelExpectation specifies expectation struct of the Logger.SetLevel
type LoggerMockSetLevelExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockSetLevelParams
	paramPtrs          *LoggerMockSetLevelParamPtrs
	expectationOrigins LoggerMockSetLevelExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockSetLevelParams contains parameters of the Logger.SetLevel
type LoggerMockSetLevelParams struct {
	level log.Level
}

// LoggerMockSetLevelParamPtrs contains pointers to parameters of the Logger.SetLevel
type LoggerMockSetLevelParamPtrs struct {
	level *log.Level
}

// LoggerMockSetLevelOrigins contains origins of expectations of the Logger.SetLevel
type LoggerMockSetLevelExpectationOrigins struct {
	origin      string
	originLevel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetLevel *mLoggerMockSetLevel) Optional() *mLoggerMockSetLevel {
	mmSetLevel.optional = true
	return mmSetLevel
}

// Expect sets up expected params for Logger.SetLevel
func (mmSetLevel *mLoggerMockSetLevel) Expect(level log.Level) *mLoggerMockSetLevel {
	if mmSetLevel.mock.funcSetLevel != nil {
		mmSetLevel.mock.t.Fatalf("LoggerMock.SetLevel mock is already set by Set")
	}

	if mmSetLevel.defaultExpectation == nil {
		mmSetLevel.defaultExpectation = &LoggerMockSetLevelExpectation{}
	}

	if mmSetLevel.defaultExpectation.paramPtrs != nil {
		mmSetLevel.mock.t.Fatalf("LoggerMock.SetLevel mock is already set by ExpectParams functions")
	}

	mmSetLevel.defaultExpectation.params = &LoggerMockSetLevelParams{level}
	mmSetLevel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetLevel.expectations {
		if minimock.Equal(e.params, mmSetLevel.defaultExpectation.params) {
			mmSetLevel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLevel.defaultExpectation.params)
		}
	}

	return mmSetLevel
}

// ExpectLevelParam1 sets up expected param level for Logger.SetLevel
func (mmSetLevel *mLoggerMockSetLevel) ExpectLevelParam1(level log.Level) *mLoggerMockSetLevel {
	if mmSetLevel.mock.funcSetLevel != nil {
		mmSetLevel.mock.t.Fatalf("LoggerMock.SetLevel mock is already set by Set")
	}

	if mmSetLevel.defaultExpectation == nil {
		mmSetLevel.defaultExpectation = &LoggerMockSetLevelExpectation{}
	}

	if mmSetLevel.defaultExpectation.params != nil {
		mmSetLevel.mock.t.Fatalf("LoggerMock.SetLevel mock is already set by Expect")
	}

	if mmSetLevel.defaultExpectation.paramPtrs == nil {
		mmSetLevel.defaultExpectation.paramPtrs = &LoggerMockSetLevelParamPtrs{}
	}
	mmSetLevel.defaultExpectation.paramPtrs.level = &level
	mmSetLevel.defaultExpectation.expectationOrigins.originLevel = minimock.CallerInfo(1)

	return mmSetLevel
}

// Inspect accepts an inspector function that has same arguments as the Logger.SetLevel
func (mmSetLevel *mLoggerMockSetLevel) Inspect(f func(level log.Level)) *mLoggerMockSetLevel {
	if mmSetLevel.mock.inspectFuncSetLevel != nil {
		mmSetLevel.mock.t.Fatalf("Inspect function is already set for LoggerMock.SetLevel")
	}

	mmSetLevel.mock.inspectFuncSetLevel = f

	return mmSetLevel
}

// Return sets up results that will be returned by Logger.SetLevel
func (mmSetLevel *mLoggerMockSetLevel) Return() *LoggerMock {
	if mmSetLevel.mock.funcSetLevel != nil {
		mmSetLevel.mock.t.Fatalf("LoggerMock.SetLevel mock is already set by Set")
	}

	if mmSetLevel.defaultExpectation == nil {
		mmSetLevel.defaultExpectation = &LoggerMockSetLevelExpectation{mock: mmSetLevel.mock}
	}

	mmSetLevel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetLevel.mock
}

// Set uses given function f to mock the Logger.SetLevel method
func (mmSetLevel *mLoggerMockSetLevel) Set(f func(level log.Level)) *LoggerMock {
	if mmSetLevel.defaultExpectation != nil {
		mmSetLevel.mock.t.Fatalf("Default expectation is already set for the Logger.SetLevel method")
	}

	if len(mmSetLevel.expectations) > 0 {
		mmSetLevel.mock.t.Fatalf("Some expectations are already set for the Logger.SetLevel method")
	}

	mmSetLevel.mock.funcSetLevel = f
	mmSetLevel.mock.funcSetLevelOrigin = minimock.CallerInfo(1)
	return mmSetLevel.mock
}

// When sets expectation for the Logger.SetLevel which will trigger the result defined by the following
// Then helper
func (mmSetLevel *mLoggerMockSetLevel) When(level log.Level) *LoggerMockSetLevelExpectation {
	if mmSetLevel.mock.funcSetLevel != nil {
		mmSetLevel.mock.t.Fatalf("LoggerMock.SetLevel mock is already set by Set")
	}

	expectation := &LoggerMockSetLevelExpectation{
		mock:               mmSetLevel.mock,
		params:             &LoggerMockSetLevelParams{level},
		expectationOrigins: LoggerMockSetLevelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetLevel.expectations = append(mmSetLevel.expectations, expectation)
	return expectation
}

// Then sets up Logger.SetLevel return parameters for the expectation previously defined by the When method
func (e *LoggerMockSetLevelExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.SetLevel should be invoked
func (mmSetLevel *mLoggerMockSetLevel) Times(n uint64) *mLoggerMockSetLevel {
	if n == 0 {
		mmSetLevel.mock.t.Fatalf("Times of LoggerMock.SetLevel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetLevel.expectedInvocations, n)
	mmSetLevel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetLevel
}

func (mmSetLevel *mLoggerMockSetLevel) invocationsDone() bool {
	if len(mmSetLevel.expectations) == 0 && mmSetLevel.defaultExpectation == nil && mmSetLevel.mock.funcSetLevel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetLevel.mock.afterSetLevelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetLevel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetLevel implements mm_pkg.Logger
func (mmSetLevel *LoggerMock) SetLevel(level log.Level) {
	mm_atomic.AddUint64(&mmSetLevel.beforeSetLevelCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLevel.afterSetLevelCounter, 1)

	mmSetLevel.t.Helper()

	if mmSetLevel.inspectFuncSetLevel != nil {
		mmSetLevel.inspectFuncSetLevel(level)
	}

	mm_params := LoggerMockSetLevelParams{level}

	// Record call args
	mmSetLevel.SetLevelMock.mutex.Lock()
	mmSetLevel.SetLevelMock.callArgs = append(mmSetLevel.SetLevelMock.callArgs, &mm_params)
	mmSetLevel.SetLevelMock.mutex.Unlock()

	for _, e := range mmSetLevel.SetLevelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLevel.SetLevelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLevel.SetLevelMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLevel.SetLevelMock.defaultExpectation.params
		mm_want_ptrs := mmSetLevel.SetLevelMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockSetLevelParams{level}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.level != nil && !minimock.Equal(*mm_want_ptrs.level, mm_got.level) {
				mmSetLevel.t.Errorf("LoggerMock.SetLevel got unexpected parameter level, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetLevel.SetLevelMock.defaultExpectation.expectationOrigins.originLevel, *mm_want_ptrs.level, mm_got.level, minimock.Diff(*mm_want_ptrs.level, mm_got.level))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLevel.t.Errorf("LoggerMock.SetLevel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetLevel.SetLevelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLevel.funcSetLevel != nil {
		mmSetLevel.funcSetLevel(level)
		return
	}
	mmSetLevel.t.Fatalf("Unexpected call to LoggerMock.SetLevel. %v", level)

}

// SetLevelAfterCounter returns a count of finished LoggerMock.SetLevel invocations
func (mmSetLevel *LoggerMock) SetLevelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLevel.afterSetLevelCounter)
}

// SetLevelBeforeCounter returns a count of LoggerMock.SetLevel invocations
func (mmSetLevel *LoggerMock) SetLevelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLevel.beforeSetLevelCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.SetLevel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLevel *mLoggerMockSetLevel) Calls() []*LoggerMockSetLevelParams {
	mmSetLevel.mutex.RLock()

	argCopy := make([]*LoggerMockSetLevelParams, len(mmSetLevel.callArgs))
	copy(argCopy, mmSetLevel.callArgs)

	mmSetLevel.mutex.RUnlock()

	return argCopy
}

// MinimockSetLevelDone returns true if the count of the SetLevel invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockSetLevelDone() bool {
	if m.SetLevelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetLevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetLevelMock.invocationsDone()
}

// MinimockSetLevelInspect logs each unmet expectation
func (m *LoggerMock) MinimockSetLevelInspect() {
	for _, e := range m.SetLevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.SetLevel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetLevelCounter := mm_atomic.LoadUint64(&m.afterSetLevelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetLevelMock.defaultExpectation != nil && afterSetLevelCounter < 1 {
		if m.SetLevelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.SetLevel at\n%s", m.SetLevelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.SetLevel at\n%s with params: %#v", m.SetLevelMock.defaultExpectation.expectationOrigins.origin, *m.SetLevelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLevel != nil && afterSetLevelCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.SetLevel at\n%s", m.funcSetLevelOrigin)
	}

	if !m.SetLevelMock.invocationsDone() && afterSetLevelCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.SetLevel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetLevelMock.expectedInvocations), m.SetLevelMock.expectedInvocationsOrigin, afterSetLevelCounter)
	}
}

type mLoggerMockSetOutput struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockSetOutputExpectation
	expectations       []*LoggerMockSetOutputExpectation

	callArgs []*LoggerMockSetOutputParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockSetOutputExpectation specifies expectation struct of the Logger.SetOutput
type LoggerMockSetOutputExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockSetOutputParams
	paramPtrs          *LoggerMockSetOutputParamPtrs
	expectationOrigins LoggerMockSetOutputExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockSetOutputParams contains parameters of the Logger.SetOutput
type LoggerMockSetOutputParams struct {
	w io.Writer
}

// LoggerMockSetOutputParamPtrs contains pointers to parameters of the Logger.SetOutput
type LoggerMockSetOutputParamPtrs struct {
	w *io.Writer
}

// LoggerMockSetOutputOrigins contains origins of expectations of the Logger.SetOutput
type LoggerMockSetOutputExpectationOrigins struct {
	origin  string
	originW string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOutput *mLoggerMockSetOutput) Optional() *mLoggerMockSetOutput {
	mmSetOutput.optional = true
	return mmSetOutput
}

// Expect sets up expected params for Logger.SetOutput
func (mmSetOutput *mLoggerMockSetOutput) Expect(w io.Writer) *mLoggerMockSetOutput {
	if mmSetOutput.mock.funcSetOutput != nil {
		mmSetOutput.mock.t.Fatalf("LoggerMock.SetOutput mock is already set by Set")
	}

	if mmSetOutput.defaultExpectation == nil {
		mmSetOutput.defaultExpectation = &LoggerMockSetOutputExpectation{}
	}

	if mmSetOutput.defaultExpectation.paramPtrs != nil {
		mmSetOutput.mock.t.Fatalf("LoggerMock.SetOutput mock is already set by ExpectParams functions")
	}

	mmSetOutput.defaultExpectation.params = &LoggerMockSetOutputParams{w}
	mmSetOutput.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOutput.expectations {
		if minimock.Equal(e.params, mmSetOutput.defaultExpectation.params) {
			mmSetOutput.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOutput.defaultExpectation.params)
		}
	}

	return mmSetOutput
}

// ExpectWParam1 sets up expected param w for Logger.SetOutput
func (mmSetOutput *mLoggerMockSetOutput) ExpectWParam1(w io.Writer) *mLoggerMockSetOutput {
	if mmSetOutput.mock.funcSetOutput != nil {
		mmSetOutput.mock.t.Fatalf("LoggerMock.SetOutput mock is already set by Set")
	}

	if mmSetOutput.defaultExpectation == nil {
		mmSetOutput.defaultExpectation = &LoggerMockSetOutputExpectation{}
	}

	if mmSetOutput.defaultExpectation.params != nil {
		mmSetOutput.mock.t.Fatalf("LoggerMock.SetOutput mock is already set by Expect")
	}

	if mmSetOutput.defaultExpectation.paramPtrs == nil {
		mmSetOutput.defaultExpectation.paramPtrs = &LoggerMockSetOutputParamPtrs{}
	}
	mmSetOutput.defaultExpectation.paramPtrs.w = &w
	mmSetOutput.defaultExpectation.expectationOrigins.originW = minimock.CallerInfo(1)

	return mmSetOutput
}

// Inspect accepts an inspector function that has same arguments as the Logger.SetOutput
func (mmSetOutput *mLoggerMockSetOutput) Inspect(f func(w io.Writer)) *mLoggerMockSetOutput {
	if mmSetOutput.mock.inspectFuncSetOutput != nil {
		mmSetOutput.mock.t.Fatalf("Inspect function is already set for LoggerMock.SetOutput")
	}

	mmSetOutput.mock.inspectFuncSetOutput = f

	return mmSetOutput
}

// Return sets up results that will be returned by Logger.SetOutput
func (mmSetOutput *mLoggerMockSetOutput) Return() *LoggerMock {
	if mmSetOutput.mock.funcSetOutput != nil {
		mmSetOutput.mock.t.Fatalf("LoggerMock.SetOutput mock is already set by Set")
	}

	if mmSetOutput.defaultExpectation == nil {
		mmSetOutput.defaultExpectation = &LoggerMockSetOutputExpectation{mock: mmSetOutput.mock}
	}

	mmSetOutput.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOutput.mock
}

// Set uses given function f to mock the Logger.SetOutput method
func (mmSetOutput *mLoggerMockSetOutput) Set(f func(w io.Writer)) *LoggerMock {
	if mmSetOutput.defaultExpectation != nil {
		mmSetOutput.mock.t.Fatalf("Default expectation is already set for the Logger.SetOutput method")
	}

	if len(mmSetOutput.expectations) > 0 {
		mmSetOutput.mock.t.Fatalf("Some expectations are already set for the Logger.SetOutput method")
	}

	mmSetOutput.mock.funcSetOutput = f
	mmSetOutput.mock.funcSetOutputOrigin = minimock.CallerInfo(1)
	return mmSetOutput.mock
}

// When sets expectation for the Logger.SetOutput which will trigger the result defined by the following
// Then helper
func (mmSetOutput *mLoggerMockSetOutput) When(w io.Writer) *LoggerMockSetOutputExpectation {
	if mmSetOutput.mock.funcSetOutput != nil {
		mmSetOutput.mock.t.Fatalf("LoggerMock.SetOutput mock is already set by Set")
	}

	expectation := &LoggerMockSetOutputExpectation{
		mock:               mmSetOutput.mock,
		params:             &LoggerMockSetOutputParams{w},
		expectationOrigins: LoggerMockSetOutputExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOutput.expectations = append(mmSetOutput.expectations, expectation)
	return expectation
}

// Then sets up Logger.SetOutput return parameters for the expectation previously defined by the When method
func (e *LoggerMockSetOutputExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.SetOutput should be invoked
func (mmSetOutput *mLoggerMockSetOutput) Times(n uint64) *mLoggerMockSetOutput {
	if n == 0 {
		mmSetOutput.mock.t.Fatalf("Times of LoggerMock.SetOutput mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOutput.expectedInvocations, n)
	mmSetOutput.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOutput
}

func (mmSetOutput *mLoggerMockSetOutput) invocationsDone() bool {
	if len(mmSetOutput.expectations) == 0 && mmSetOutput.defaultExpectation == nil && mmSetOutput.mock.funcSetOutput == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOutput.mock.afterSetOutputCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOutput.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOutput implements mm_pkg.Logger
func (mmSetOutput *LoggerMock) SetOutput(w io.Writer) {
	mm_atomic.AddUint64(&mmSetOutput.beforeSetOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOutput.afterSetOutputCounter, 1)

	mmSetOutput.t.Helper()

	if mmSetOutput.inspectFuncSetOutput != nil {
		mmSetOutput.inspectFuncSetOutput(w)
	}

	mm_params := LoggerMockSetOutputParams{w}

	// Record call args
	mmSetOutput.SetOutputMock.mutex.Lock()
	mmSetOutput.SetOutputMock.callArgs = append(mmSetOutput.SetOutputMock.callArgs, &mm_params)
	mmSetOutput.SetOutputMock.mutex.Unlock()

	for _, e := range mmSetOutput.SetOutputMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetOutput.SetOutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOutput.SetOutputMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOutput.SetOutputMock.defaultExpectation.params
		mm_want_ptrs := mmSetOutput.SetOutputMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockSetOutputParams{w}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.w != nil && !minimock.Equal(*mm_want_ptrs.w, mm_got.w) {
				mmSetOutput.t.Errorf("LoggerMock.SetOutput got unexpected parameter w, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOutput.SetOutputMock.defaultExpectation.expectationOrigins.originW, *mm_want_ptrs.w, mm_got.w, minimock.Diff(*mm_want_ptrs.w, mm_got.w))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOutput.t.Errorf("LoggerMock.SetOutput got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOutput.SetOutputMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetOutput.funcSetOutput != nil {
		mmSetOutput.funcSetOutput(w)
		return
	}
	mmSetOutput.t.Fatalf("Unexpected call to LoggerMock.SetOutput. %v", w)

}

// SetOutputAfterCounter returns a count of finished LoggerMock.SetOutput invocations
func (mmSetOutput *LoggerMock) SetOutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOutput.afterSetOutputCounter)
}

// SetOutputBeforeCounter returns a count of LoggerMock.SetOutput invocations
func (mmSetOutput *LoggerMock) SetOutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOutput.beforeSetOutputCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.SetOutput.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOutput *mLoggerMockSetOutput) Calls() []*LoggerMockSetOutputParams {
	mmSetOutput.mutex.RLock()

	argCopy := make([]*LoggerMockSetOutputParams, len(mmSetOutput.callArgs))
	copy(argCopy, mmSetOutput.callArgs)

	mmSetOutput.mutex.RUnlock()

	return argCopy
}

// MinimockSetOutputDone returns true if the count of the SetOutput invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockSetOutputDone() bool {
	if m.SetOutputMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOutputMock.invocationsDone()
}

// MinimockSetOutputInspect logs each unmet expectation
func (m *LoggerMock) MinimockSetOutputInspect() {
	for _, e := range m.SetOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.SetOutput at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOutputCounter := mm_atomic.LoadUint64(&m.afterSetOutputCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOutputMock.defaultExpectation != nil && afterSetOutputCounter < 1 {
		if m.SetOutputMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.SetOutput at\n%s", m.SetOutputMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.SetOutput at\n%s with params: %#v", m.SetOutputMock.defaultExpectation.expectationOrigins.origin, *m.SetOutputMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOutput != nil && afterSetOutputCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.SetOutput at\n%s", m.funcSetOutputOrigin)
	}

	if !m.SetOutputMock.invocationsDone() && afterSetOutputCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.SetOutput at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOutputMock.expectedInvocations), m.SetOutputMock.expectedInvocationsOrigin, afterSetOutputCounter)
	}
}

type mLoggerMockWarn struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWarnParams
	paramPtrs          *LoggerMockWarnParamPtrs
	expectationOrigins LoggerMockWarnExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	msg  string
	args []any
}

// LoggerMockWarnParamPtrs contains pointers to parameters of the Logger.Warn
type LoggerMockWarnParamPtrs struct {
	msg  *string
	args *[]any
}

// LoggerMockWarnOrigins contains origins of expectations of the Logger.Warn
type LoggerMockWarnExpectationOrigins struct {
	origin     string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarn *mLoggerMockWarn) Optional() *mLoggerMockWarn {
	mmWarn.optional = true
	return mmWarn
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(msg string, args ...any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.paramPtrs != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by ExpectParams functions")
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{msg, args}
	mmWarn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// ExpectMsgParam1 sets up expected param msg for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectMsgParam1(msg string) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.msg = &msg
	mmWarn.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmWarn
}

// ExpectArgsParam2 sets up expected param args for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectArgsParam2(args ...any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.args = &args
	mmWarn.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(msg string, args ...any)) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	mmWarn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(msg string, args ...any)) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	mmWarn.mock.funcWarnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// When sets expectation for the Logger.Warn which will trigger the result defined by the following
// Then helper
func (mmWarn *mLoggerMockWarn) When(msg string, args ...any) *LoggerMockWarnExpectation {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	expectation := &LoggerMockWarnExpectation{
		mock:               mmWarn.mock,
		params:             &LoggerMockWarnParams{msg, args},
		expectationOrigins: LoggerMockWarnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarn.expectations = append(mmWarn.expectations, expectation)
	return expectation
}

// Then sets up Logger.Warn return parameters for the expectation previously defined by the When method
func (e *LoggerMockWarnExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Warn should be invoked
func (mmWarn *mLoggerMockWarn) Times(n uint64) *mLoggerMockWarn {
	if n == 0 {
		mmWarn.mock.t.Fatalf("Times of LoggerMock.Warn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarn.expectedInvocations, n)
	mmWarn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarn
}

func (mmWarn *mLoggerMockWarn) invocationsDone() bool {
	if len(mmWarn.expectations) == 0 && mmWarn.defaultExpectation == nil && mmWarn.mock.funcWarn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarn.mock.afterWarnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warn implements mm_pkg.Logger
func (mmWarn *LoggerMock) Warn(msg string, args ...any) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	mmWarn.t.Helper()

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, args...)
	}

	mm_params := LoggerMockWarnParams{msg, args}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_want_ptrs := mmWarn.WarnMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnParams{msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarn.WarnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, args...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v %v", msg, args)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	if m.WarnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnMock.invocationsDone()
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnCounter := mm_atomic.LoadUint64(&m.afterWarnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && afterWarnCounter < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.WarnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", m.WarnMock.defaultExpectation.expectationOrigins.origin, *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && afterWarnCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.funcWarnOrigin)
	}

	if !m.WarnMock.invocationsDone() && afterWarnCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnMock.expectedInvocations), m.WarnMock.expectedInvocationsOrigin, afterWarnCounter)
	}
}

type mLoggerMockWarnContext struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnContextExpectation
	expectations       []*LoggerMockWarnContextExpectation

	callArgs []*LoggerMockWarnContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWarnContextExpectation specifies expectation struct of the Logger.WarnContext
type LoggerMockWarnContextExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWarnContextParams
	paramPtrs          *LoggerMockWarnContextParamPtrs
	expectationOrigins LoggerMockWarnContextExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockWarnContextParams contains parameters of the Logger.WarnContext
type LoggerMockWarnContextParams struct {
	ctx  context.Context
	msg  string
	args []any
}

// LoggerMockWarnContextParamPtrs contains pointers to parameters of the Logger.WarnContext
type LoggerMockWarnContextParamPtrs struct {
	ctx  *context.Context
	msg  *string
	args *[]any
}

// LoggerMockWarnContextOrigins contains origins of expectations of the Logger.WarnContext
type LoggerMockWarnContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originMsg  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarnContext *mLoggerMockWarnContext) Optional() *mLoggerMockWarnContext {
	mmWarnContext.optional = true
	return mmWarnContext
}

// Expect sets up expected params for Logger.WarnContext
func (mmWarnContext *mLoggerMockWarnContext) Expect(ctx context.Context, msg string, args ...any) *mLoggerMockWarnContext {
	if mmWarnContext.mock.funcWarnContext != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Set")
	}

	if mmWarnContext.defaultExpectation == nil {
		mmWarnContext.defaultExpectation = &LoggerMockWarnContextExpectation{}
	}

	if mmWarnContext.defaultExpectation.paramPtrs != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by ExpectParams functions")
	}

	mmWarnContext.defaultExpectation.params = &LoggerMockWarnContextParams{ctx, msg, args}
	mmWarnContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarnContext.expectations {
		if minimock.Equal(e.params, mmWarnContext.defaultExpectation.params) {
			mmWarnContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnContext.defaultExpectation.params)
		}
	}

	return mmWarnContext
}

// ExpectCtxParam1 sets up expected param ctx for Logger.WarnContext
func (mmWarnContext *mLoggerMockWarnContext) ExpectCtxParam1(ctx context.Context) *mLoggerMockWarnContext {
	if mmWarnContext.mock.funcWarnContext != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Set")
	}

	if mmWarnContext.defaultExpectation == nil {
		mmWarnContext.defaultExpectation = &LoggerMockWarnContextExpectation{}
	}

	if mmWarnContext.defaultExpectation.params != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Expect")
	}

	if mmWarnContext.defaultExpectation.paramPtrs == nil {
		mmWarnContext.defaultExpectation.paramPtrs = &LoggerMockWarnContextParamPtrs{}
	}
	mmWarnContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmWarnContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWarnContext
}

// ExpectMsgParam2 sets up expected param msg for Logger.WarnContext
func (mmWarnContext *mLoggerMockWarnContext) ExpectMsgParam2(msg string) *mLoggerMockWarnContext {
	if mmWarnContext.mock.funcWarnContext != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Set")
	}

	if mmWarnContext.defaultExpectation == nil {
		mmWarnContext.defaultExpectation = &LoggerMockWarnContextExpectation{}
	}

	if mmWarnContext.defaultExpectation.params != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Expect")
	}

	if mmWarnContext.defaultExpectation.paramPtrs == nil {
		mmWarnContext.defaultExpectation.paramPtrs = &LoggerMockWarnContextParamPtrs{}
	}
	mmWarnContext.defaultExpectation.paramPtrs.msg = &msg
	mmWarnContext.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmWarnContext
}

// ExpectArgsParam3 sets up expected param args for Logger.WarnContext
func (mmWarnContext *mLoggerMockWarnContext) ExpectArgsParam3(args ...any) *mLoggerMockWarnContext {
	if mmWarnContext.mock.funcWarnContext != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Set")
	}

	if mmWarnContext.defaultExpectation == nil {
		mmWarnContext.defaultExpectation = &LoggerMockWarnContextExpectation{}
	}

	if mmWarnContext.defaultExpectation.params != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Expect")
	}

	if mmWarnContext.defaultExpectation.paramPtrs == nil {
		mmWarnContext.defaultExpectation.paramPtrs = &LoggerMockWarnContextParamPtrs{}
	}
	mmWarnContext.defaultExpectation.paramPtrs.args = &args
	mmWarnContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmWarnContext
}

// Inspect accepts an inspector function that has same arguments as the Logger.WarnContext
func (mmWarnContext *mLoggerMockWarnContext) Inspect(f func(ctx context.Context, msg string, args ...any)) *mLoggerMockWarnContext {
	if mmWarnContext.mock.inspectFuncWarnContext != nil {
		mmWarnContext.mock.t.Fatalf("Inspect function is already set for LoggerMock.WarnContext")
	}

	mmWarnContext.mock.inspectFuncWarnContext = f

	return mmWarnContext
}

// Return sets up results that will be returned by Logger.WarnContext
func (mmWarnContext *mLoggerMockWarnContext) Return() *LoggerMock {
	if mmWarnContext.mock.funcWarnContext != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Set")
	}

	if mmWarnContext.defaultExpectation == nil {
		mmWarnContext.defaultExpectation = &LoggerMockWarnContextExpectation{mock: mmWarnContext.mock}
	}

	mmWarnContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarnContext.mock
}

// Set uses given function f to mock the Logger.WarnContext method
func (mmWarnContext *mLoggerMockWarnContext) Set(f func(ctx context.Context, msg string, args ...any)) *LoggerMock {
	if mmWarnContext.defaultExpectation != nil {
		mmWarnContext.mock.t.Fatalf("Default expectation is already set for the Logger.WarnContext method")
	}

	if len(mmWarnContext.expectations) > 0 {
		mmWarnContext.mock.t.Fatalf("Some expectations are already set for the Logger.WarnContext method")
	}

	mmWarnContext.mock.funcWarnContext = f
	mmWarnContext.mock.funcWarnContextOrigin = minimock.CallerInfo(1)
	return mmWarnContext.mock
}

// When sets expectation for the Logger.WarnContext which will trigger the result defined by the following
// Then helper
func (mmWarnContext *mLoggerMockWarnContext) When(ctx context.Context, msg string, args ...any) *LoggerMockWarnContextExpectation {
	if mmWarnContext.mock.funcWarnContext != nil {
		mmWarnContext.mock.t.Fatalf("LoggerMock.WarnContext mock is already set by Set")
	}

	expectation := &LoggerMockWarnContextExpectation{
		mock:               mmWarnContext.mock,
		params:             &LoggerMockWarnContextParams{ctx, msg, args},
		expectationOrigins: LoggerMockWarnContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarnContext.expectations = append(mmWarnContext.expectations, expectation)
	return expectation
}

// Then sets up Logger.WarnContext return parameters for the expectation previously defined by the When method
func (e *LoggerMockWarnContextExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.WarnContext should be invoked
func (mmWarnContext *mLoggerMockWarnContext) Times(n uint64) *mLoggerMockWarnContext {
	if n == 0 {
		mmWarnContext.mock.t.Fatalf("Times of LoggerMock.WarnContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarnContext.expectedInvocations, n)
	mmWarnContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarnContext
}

func (mmWarnContext *mLoggerMockWarnContext) invocationsDone() bool {
	if len(mmWarnContext.expectations) == 0 && mmWarnContext.defaultExpectation == nil && mmWarnContext.mock.funcWarnContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarnContext.mock.afterWarnContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarnContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WarnContext implements mm_pkg.Logger
func (mmWarnContext *LoggerMock) WarnContext(ctx context.Context, msg string, args ...any) {
	mm_atomic.AddUint64(&mmWarnContext.beforeWarnContextCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnContext.afterWarnContextCounter, 1)

	mmWarnContext.t.Helper()

	if mmWarnContext.inspectFuncWarnContext != nil {
		mmWarnContext.inspectFuncWarnContext(ctx, msg, args...)
	}

	mm_params := LoggerMockWarnContextParams{ctx, msg, args}

	// Record call args
	mmWarnContext.WarnContextMock.mutex.Lock()
	mmWarnContext.WarnContextMock.callArgs = append(mmWarnContext.WarnContextMock.callArgs, &mm_params)
	mmWarnContext.WarnContextMock.mutex.Unlock()

	for _, e := range mmWarnContext.WarnContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnContext.WarnContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnContext.WarnContextMock.defaultExpectation.Counter, 1)
		mm_want := mmWarnContext.WarnContextMock.defaultExpectation.params
		mm_want_ptrs := mmWarnContext.WarnContextMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnContextParams{ctx, msg, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWarnContext.t.Errorf("LoggerMock.WarnContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnContext.WarnContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmWarnContext.t.Errorf("LoggerMock.WarnContext got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnContext.WarnContextMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmWarnContext.t.Errorf("LoggerMock.WarnContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnContext.WarnContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarnContext.t.Errorf("LoggerMock.WarnContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarnContext.WarnContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarnContext.funcWarnContext != nil {
		mmWarnContext.funcWarnContext(ctx, msg, args...)
		return
	}
	mmWarnContext.t.Fatalf("Unexpected call to LoggerMock.WarnContext. %v %v %v", ctx, msg, args)

}

// WarnContextAfterCounter returns a count of finished LoggerMock.WarnContext invocations
func (mmWarnContext *LoggerMock) WarnContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnContext.afterWarnContextCounter)
}

// WarnContextBeforeCounter returns a count of LoggerMock.WarnContext invocations
func (mmWarnContext *LoggerMock) WarnContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnContext.beforeWarnContextCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WarnContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnContext *mLoggerMockWarnContext) Calls() []*LoggerMockWarnContextParams {
	mmWarnContext.mutex.RLock()

	argCopy := make([]*LoggerMockWarnContextParams, len(mmWarnContext.callArgs))
	copy(argCopy, mmWarnContext.callArgs)

	mmWarnContext.mutex.RUnlock()

	return argCopy
}

// MinimockWarnContextDone returns true if the count of the WarnContext invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnContextDone() bool {
	if m.WarnContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnContextMock.invocationsDone()
}

// MinimockWarnContextInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnContextInspect() {
	for _, e := range m.WarnContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WarnContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnContextCounter := mm_atomic.LoadUint64(&m.afterWarnContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnContextMock.defaultExpectation != nil && afterWarnContextCounter < 1 {
		if m.WarnContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.WarnContext at\n%s", m.WarnContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.WarnContext at\n%s with params: %#v", m.WarnContextMock.defaultExpectation.expectationOrigins.origin, *m.WarnContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnContext != nil && afterWarnContextCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.WarnContext at\n%s", m.funcWarnContextOrigin)
	}

	if !m.WarnContextMock.invocationsDone() && afterWarnContextCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.WarnContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnContextMock.expectedInvocations), m.WarnContextMock.expectedInvocationsOrigin, afterWarnContextCounter)
	}
}

type mLoggerMockWith struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithExpectation
	expectations       []*LoggerMockWithExpectation

	callArgs []*LoggerMockWithParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWithExpectation specifies expectation struct of the Logger.With
type LoggerMockWithExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWithParams
	paramPtrs          *LoggerMockWithParamPtrs
	expectationOrigins LoggerMockWithExpectationOrigins
	results            *LoggerMockWithResults
	returnOrigin       string
	Counter            uint64
}

// LoggerMockWithParams contains parameters of the Logger.With
type LoggerMockWithParams struct {
	args []any
}

// LoggerMockWithParamPtrs contains pointers to parameters of the Logger.With
type LoggerMockWithParamPtrs struct {
	args *[]any
}

// LoggerMockWithResults contains results of the Logger.With
type LoggerMockWithResults struct {
	lp1 *log.Logger
}

// LoggerMockWithOrigins contains origins of expectations of the Logger.With
type LoggerMockWithExpectationOrigins struct {
	origin     string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWith *mLoggerMockWith) Optional() *mLoggerMockWith {
	mmWith.optional = true
	return mmWith
}

// Expect sets up expected params for Logger.With
func (mmWith *mLoggerMockWith) Expect(args ...any) *mLoggerMockWith {
	if mmWith.mock.funcWith != nil {
		mmWith.mock.t.Fatalf("LoggerMock.With mock is already set by Set")
	}

	if mmWith.defaultExpectation == nil {
		mmWith.defaultExpectation = &LoggerMockWithExpectation{}
	}

	if mmWith.defaultExpectation.paramPtrs != nil {
		mmWith.mock.t.Fatalf("LoggerMock.With mock is already set by ExpectParams functions")
	}

	mmWith.defaultExpectation.params = &LoggerMockWithParams{args}
	mmWith.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWith.expectations {
		if minimock.Equal(e.params, mmWith.defaultExpectation.params) {
			mmWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWith.defaultExpectation.params)
		}
	}

	return mmWith
}

// ExpectArgsParam1 sets up expected param args for Logger.With
func (mmWith *mLoggerMockWith) ExpectArgsParam1(args ...any) *mLoggerMockWith {
	if mmWith.mock.funcWith != nil {
		mmWith.mock.t.Fatalf("LoggerMock.With mock is already set by Set")
	}

	if mmWith.defaultExpectation == nil {
		mmWith.defaultExpectation = &LoggerMockWithExpectation{}
	}

	if mmWith.defaultExpectation.params != nil {
		mmWith.mock.t.Fatalf("LoggerMock.With mock is already set by Expect")
	}

	if mmWith.defaultExpectation.paramPtrs == nil {
		mmWith.defaultExpectation.paramPtrs = &LoggerMockWithParamPtrs{}
	}
	mmWith.defaultExpectation.paramPtrs.args = &args
	mmWith.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmWith
}

// Inspect accepts an inspector function that has same arguments as the Logger.With
func (mmWith *mLoggerMockWith) Inspect(f func(args ...any)) *mLoggerMockWith {
	if mmWith.mock.inspectFuncWith != nil {
		mmWith.mock.t.Fatalf("Inspect function is already set for LoggerMock.With")
	}

	mmWith.mock.inspectFuncWith = f

	return mmWith
}

// Return sets up results that will be returned by Logger.With
func (mmWith *mLoggerMockWith) Return(lp1 *log.Logger) *LoggerMock {
	if mmWith.mock.funcWith != nil {
		mmWith.mock.t.Fatalf("LoggerMock.With mock is already set by Set")
	}

	if mmWith.defaultExpectation == nil {
		mmWith.defaultExpectation = &LoggerMockWithExpectation{mock: mmWith.mock}
	}
	mmWith.defaultExpectation.results = &LoggerMockWithResults{lp1}
	mmWith.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWith.mock
}

// Set uses given function f to mock the Logger.With method
func (mmWith *mLoggerMockWith) Set(f func(args ...any) (lp1 *log.Logger)) *LoggerMock {
	if mmWith.defaultExpectation != nil {
		mmWith.mock.t.Fatalf("Default expectation is already set for the Logger.With method")
	}

	if len(mmWith.expectations) > 0 {
		mmWith.mock.t.Fatalf("Some expectations are already set for the Logger.With method")
	}

	mmWith.mock.funcWith = f
	mmWith.mock.funcWithOrigin = minimock.CallerInfo(1)
	return mmWith.mock
}

// When sets expectation for the Logger.With which will trigger the result defined by the following
// Then helper
func (mmWith *mLoggerMockWith) When(args ...any) *LoggerMockWithExpectation {
	if mmWith.mock.funcWith != nil {
		mmWith.mock.t.Fatalf("LoggerMock.With mock is already set by Set")
	}

	expectation := &LoggerMockWithExpectation{
		mock:               mmWith.mock,
		params:             &LoggerMockWithParams{args},
		expectationOrigins: LoggerMockWithExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWith.expectations = append(mmWith.expectations, expectation)
	return expectation
}

// Then sets up Logger.With return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithExpectation) Then(lp1 *log.Logger) *LoggerMock {
	e.results = &LoggerMockWithResults{lp1}
	return e.mock
}

// Times sets number of times Logger.With should be invoked
func (mmWith *mLoggerMockWith) Times(n uint64) *mLoggerMockWith {
	if n == 0 {
		mmWith.mock.t.Fatalf("Times of LoggerMock.With mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWith.expectedInvocations, n)
	mmWith.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWith
}

func (mmWith *mLoggerMockWith) invocationsDone() bool {
	if len(mmWith.expectations) == 0 && mmWith.defaultExpectation == nil && mmWith.mock.funcWith == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWith.mock.afterWithCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWith.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// With implements mm_pkg.Logger
func (mmWith *LoggerMock) With(args ...any) (lp1 *log.Logger) {
	mm_atomic.AddUint64(&mmWith.beforeWithCounter, 1)
	defer mm_atomic.AddUint64(&mmWith.afterWithCounter, 1)

	mmWith.t.Helper()

	if mmWith.inspectFuncWith != nil {
		mmWith.inspectFuncWith(args...)
	}

	mm_params := LoggerMockWithParams{args}

	// Record call args
	mmWith.WithMock.mutex.Lock()
	mmWith.WithMock.callArgs = append(mmWith.WithMock.callArgs, &mm_params)
	mmWith.WithMock.mutex.Unlock()

	for _, e := range mmWith.WithMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1
		}
	}

	if mmWith.WithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWith.WithMock.defaultExpectation.Counter, 1)
		mm_want := mmWith.WithMock.defaultExpectation.params
		mm_want_ptrs := mmWith.WithMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWithParams{args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmWith.t.Errorf("LoggerMock.With got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWith.WithMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWith.t.Errorf("LoggerMock.With got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWith.WithMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWith.WithMock.defaultExpectation.results
		if mm_results == nil {
			mmWith.t.Fatal("No results are set for the LoggerMock.With")
		}
		return (*mm_results).lp1
	}
	if mmWith.funcWith != nil {
		return mmWith.funcWith(args...)
	}
	mmWith.t.Fatalf("Unexpected call to LoggerMock.With. %v", args)
	return
}

// WithAfterCounter returns a count of finished LoggerMock.With invocations
func (mmWith *LoggerMock) WithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWith.afterWithCounter)
}

// WithBeforeCounter returns a count of LoggerMock.With invocations
func (mmWith *LoggerMock) WithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWith.beforeWithCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.With.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWith *mLoggerMockWith) Calls() []*LoggerMockWithParams {
	mmWith.mutex.RLock()

	argCopy := make([]*LoggerMockWithParams, len(mmWith.callArgs))
	copy(argCopy, mmWith.callArgs)

	mmWith.mutex.RUnlock()

	return argCopy
}

// MinimockWithDone returns true if the count of the With invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithDone() bool {
	if m.WithMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithMock.invocationsDone()
}

// MinimockWithInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithInspect() {
	for _, e := range m.WithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.With at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithCounter := mm_atomic.LoadUint64(&m.afterWithCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithMock.defaultExpectation != nil && afterWithCounter < 1 {
		if m.WithMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.With at\n%s", m.WithMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.With at\n%s with params: %#v", m.WithMock.defaultExpectation.expectationOrigins.origin, *m.WithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWith != nil && afterWithCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.With at\n%s", m.funcWithOrigin)
	}

	if !m.WithMock.invocationsDone() && afterWithCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.With at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithMock.expectedInvocations), m.WithMock.expectedInvocationsOrigin, afterWithCounter)
	}
}

type mLoggerMockWithGroup struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithGroupExpectation
	expectations       []*LoggerMockWithGroupExpectation

	callArgs []*LoggerMockWithGroupParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWithGroupExpectation specifies expectation struct of the Logger.WithGroup
type LoggerMockWithGroupExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWithGroupParams
	paramPtrs          *LoggerMockWithGroupParamPtrs
	expectationOrigins LoggerMockWithGroupExpectationOrigins
	results            *LoggerMockWithGroupResults
	returnOrigin       string
	Counter            uint64
}

// LoggerMockWithGroupParams contains parameters of the Logger.WithGroup
type LoggerMockWithGroupParams struct {
	name string
}

// LoggerMockWithGroupParamPtrs contains pointers to parameters of the Logger.WithGroup
type LoggerMockWithGroupParamPtrs struct {
	name *string
}

// LoggerMockWithGroupResults contains results of the Logger.WithGroup
type LoggerMockWithGroupResults struct {
	lp1 *log.Logger
}

// LoggerMockWithGroupOrigins contains origins of expectations of the Logger.WithGroup
type LoggerMockWithGroupExpectationOrigins struct {
	origin     string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithGroup *mLoggerMockWithGroup) Optional() *mLoggerMockWithGroup {
	mmWithGroup.optional = true
	return mmWithGroup
}

// Expect sets up expected params for Logger.WithGroup
func (mmWithGroup *mLoggerMockWithGroup) Expect(name string) *mLoggerMockWithGroup {
	if mmWithGroup.mock.funcWithGroup != nil {
		mmWithGroup.mock.t.Fatalf("LoggerMock.WithGroup mock is already set by Set")
	}

	if mmWithGroup.defaultExpectation == nil {
		mmWithGroup.defaultExpectation = &LoggerMockWithGroupExpectation{}
	}

	if mmWithGroup.defaultExpectation.paramPtrs != nil {
		mmWithGroup.mock.t.Fatalf("LoggerMock.WithGroup mock is already set by ExpectParams functions")
	}

	mmWithGroup.defaultExpectation.params = &LoggerMockWithGroupParams{name}
	mmWithGroup.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithGroup.expectations {
		if minimock.Equal(e.params, mmWithGroup.defaultExpectation.params) {
			mmWithGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithGroup.defaultExpectation.params)
		}
	}

	return mmWithGroup
}

// ExpectNameParam1 sets up expected param name for Logger.WithGroup
func (mmWithGroup *mLoggerMockWithGroup) ExpectNameParam1(name string) *mLoggerMockWithGroup {
	if mmWithGroup.mock.funcWithGroup != nil {
		mmWithGroup.mock.t.Fatalf("LoggerMock.WithGroup mock is already set by Set")
	}

	if mmWithGroup.defaultExpectation == nil {
		mmWithGroup.defaultExpectation = &LoggerMockWithGroupExpectation{}
	}

	if mmWithGroup.defaultExpectation.params != nil {
		mmWithGroup.mock.t.Fatalf("LoggerMock.WithGroup mock is already set by Expect")
	}

	if mmWithGroup.defaultExpectation.paramPtrs == nil {
		mmWithGroup.defaultExpectation.paramPtrs = &LoggerMockWithGroupParamPtrs{}
	}
	mmWithGroup.defaultExpectation.paramPtrs.name = &name
	mmWithGroup.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmWithGroup
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithGroup
func (mmWithGroup *mLoggerMockWithGroup) Inspect(f func(name string)) *mLoggerMockWithGroup {
	if mmWithGroup.mock.inspectFuncWithGroup != nil {
		mmWithGroup.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithGroup")
	}

	mmWithGroup.mock.inspectFuncWithGroup = f

	return mmWithGroup
}

// Return sets up results that will be returned by Logger.WithGroup
func (mmWithGroup *mLoggerMockWithGroup) Return(lp1 *log.Logger) *LoggerMock {
	if mmWithGroup.mock.funcWithGroup != nil {
		mmWithGroup.mock.t.Fatalf("LoggerMock.WithGroup mock is already set by Set")
	}

	if mmWithGroup.defaultExpectation == nil {
		mmWithGroup.defaultExpectation = &LoggerMockWithGroupExpectation{mock: mmWithGroup.mock}
	}
	mmWithGroup.defaultExpectation.results = &LoggerMockWithGroupResults{lp1}
	mmWithGroup.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithGroup.mock
}

// Set uses given function f to mock the Logger.WithGroup method
func (mmWithGroup *mLoggerMockWithGroup) Set(f func(name string) (lp1 *log.Logger)) *LoggerMock {
	if mmWithGroup.defaultExpectation != nil {
		mmWithGroup.mock.t.Fatalf("Default expectation is already set for the Logger.WithGroup method")
	}

	if len(mmWithGroup.expectations) > 0 {
		mmWithGroup.mock.t.Fatalf("Some expectations are already set for the Logger.WithGroup method")
	}

	mmWithGroup.mock.funcWithGroup = f
	mmWithGroup.mock.funcWithGroupOrigin = minimock.CallerInfo(1)
	return mmWithGroup.mock
}

// When sets expectation for the Logger.WithGroup which will trigger the result defined by the following
// Then helper
func (mmWithGroup *mLoggerMockWithGroup) When(name string) *LoggerMockWithGroupExpectation {
	if mmWithGroup.mock.funcWithGroup != nil {
		mmWithGroup.mock.t.Fatalf("LoggerMock.WithGroup mock is already set by Set")
	}

	expectation := &LoggerMockWithGroupExpectation{
		mock:               mmWithGroup.mock,
		params:             &LoggerMockWithGroupParams{name},
		expectationOrigins: LoggerMockWithGroupExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithGroup.expectations = append(mmWithGroup.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithGroup return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithGroupExpectation) Then(lp1 *log.Logger) *LoggerMock {
	e.results = &LoggerMockWithGroupResults{lp1}
	return e.mock
}

// Times sets number of times Logger.WithGroup should be invoked
func (mmWithGroup *mLoggerMockWithGroup) Times(n uint64) *mLoggerMockWithGroup {
	if n == 0 {
		mmWithGroup.mock.t.Fatalf("Times of LoggerMock.WithGroup mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithGroup.expectedInvocations, n)
	mmWithGroup.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithGroup
}

func (mmWithGroup *mLoggerMockWithGroup) invocationsDone() bool {
	if len(mmWithGroup.expectations) == 0 && mmWithGroup.defaultExpectation == nil && mmWithGroup.mock.funcWithGroup == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithGroup.mock.afterWithGroupCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithGroup.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithGroup implements mm_pkg.Logger
func (mmWithGroup *LoggerMock) WithGroup(name string) (lp1 *log.Logger) {
	mm_atomic.AddUint64(&mmWithGroup.beforeWithGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmWithGroup.afterWithGroupCounter, 1)

	mmWithGroup.t.Helper()

	if mmWithGroup.inspectFuncWithGroup != nil {
		mmWithGroup.inspectFuncWithGroup(name)
	}

	mm_params := LoggerMockWithGroupParams{name}

	// Record call args
	mmWithGroup.WithGroupMock.mutex.Lock()
	mmWithGroup.WithGroupMock.callArgs = append(mmWithGroup.WithGroupMock.callArgs, &mm_params)
	mmWithGroup.WithGroupMock.mutex.Unlock()

	for _, e := range mmWithGroup.WithGroupMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1
		}
	}

	if mmWithGroup.WithGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithGroup.WithGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmWithGroup.WithGroupMock.defaultExpectation.params
		mm_want_ptrs := mmWithGroup.WithGroupMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWithGroupParams{name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmWithGroup.t.Errorf("LoggerMock.WithGroup got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithGroup.WithGroupMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithGroup.t.Errorf("LoggerMock.WithGroup got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithGroup.WithGroupMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithGroup.WithGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmWithGroup.t.Fatal("No results are set for the LoggerMock.WithGroup")
		}
		return (*mm_results).lp1
	}
	if mmWithGroup.funcWithGroup != nil {
		return mmWithGroup.funcWithGroup(name)
	}
	mmWithGroup.t.Fatalf("Unexpected call to LoggerMock.WithGroup. %v", name)
	return
}

// WithGroupAfterCounter returns a count of finished LoggerMock.WithGroup invocations
func (mmWithGroup *LoggerMock) WithGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithGroup.afterWithGroupCounter)
}

// WithGroupBeforeCounter returns a count of LoggerMock.WithGroup invocations
func (mmWithGroup *LoggerMock) WithGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithGroup.beforeWithGroupCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithGroup *mLoggerMockWithGroup) Calls() []*LoggerMockWithGroupParams {
	mmWithGroup.mutex.RLock()

	argCopy := make([]*LoggerMockWithGroupParams, len(mmWithGroup.callArgs))
	copy(argCopy, mmWithGroup.callArgs)

	mmWithGroup.mutex.RUnlock()

	return argCopy
}

// MinimockWithGroupDone returns true if the count of the WithGroup invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithGroupDone() bool {
	if m.WithGroupMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithGroupMock.invocationsDone()
}

// MinimockWithGroupInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithGroupInspect() {
	for _, e := range m.WithGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithGroup at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithGroupCounter := mm_atomic.LoadUint64(&m.afterWithGroupCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithGroupMock.defaultExpectation != nil && afterWithGroupCounter < 1 {
		if m.WithGroupMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.WithGroup at\n%s", m.WithGroupMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithGroup at\n%s with params: %#v", m.WithGroupMock.defaultExpectation.expectationOrigins.origin, *m.WithGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithGroup != nil && afterWithGroupCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.WithGroup at\n%s", m.funcWithGroupOrigin)
	}

	if !m.WithGroupMock.invocationsDone() && afterWithGroupCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.WithGroup at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithGroupMock.expectedInvocations), m.WithGroupMock.expectedInvocationsOrigin, afterWithGroupCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugInspect()

			m.MinimockDebugContextInspect()

			m.MinimockEnabledInspect()

			m.MinimockErrorInspect()

			m.MinimockErrorContextInspect()

			m.MinimockFatalInspect()

			m.MinimockGetLevelInspect()

			m.MinimockHandlerInspect()

			m.MinimockInfoInspect()

			m.MinimockInfoContextInspect()

			m.MinimockLogInspect()

			m.MinimockLogAttrsInspect()

			m.MinimockNamedInspect()

			m.MinimockSetLevelInspect()

			m.MinimockSetOutputInspect()

			m.MinimockWarnInspect()

			m.MinimockWarnContextInspect()

			m.MinimockWithInspect()

			m.MinimockWithGroupInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockDebugContextDone() &&
		m.MinimockEnabledDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorContextDone() &&
		m.MinimockFatalDone() &&
		m.MinimockGetLevelDone() &&
		m.MinimockHandlerDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfoContextDone() &&
		m.MinimockLogDone() &&
		m.MinimockLogAttrsDone() &&
		m.MinimockNamedDone() &&
		m.MinimockSetLevelDone() &&
		m.MinimockSetOutputDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnContextDone() &&
		m.MinimockWithDone() &&
		m.MinimockWithGroupDone()
}
