// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/module-sdk/pkg.EMMetricsCollector -o metrics_collector_mock.go -n MetricsCollectorMock -p mock

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/module-sdk/pkg"
	"github.com/gojuno/minimock/v3"
)

// MetricsCollectorMock implements mm_pkg.EMMetricsCollector
type MetricsCollectorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)
	funcAddOrigin    string
	inspectFuncAdd   func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mMetricsCollectorMockAdd

	funcExpire          func(group string)
	funcExpireOrigin    string
	inspectFuncExpire   func(group string)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mMetricsCollectorMockExpire

	funcInc          func(name string, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)
	funcIncOrigin    string
	inspectFuncInc   func(name string, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)
	afterIncCounter  uint64
	beforeIncCounter uint64
	IncMock          mMetricsCollectorMockInc

	funcSet          func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)
	funcSetOrigin    string
	inspectFuncSet   func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mMetricsCollectorMockSet

	funcWriteOutput          func(writer io.Writer) (err error)
	funcWriteOutputOrigin    string
	inspectFuncWriteOutput   func(writer io.Writer)
	afterWriteOutputCounter  uint64
	beforeWriteOutputCounter uint64
	WriteOutputMock          mMetricsCollectorMockWriteOutput
}

// NewMetricsCollectorMock returns a mock for mm_pkg.EMMetricsCollector
func NewMetricsCollectorMock(t minimock.Tester) *MetricsCollectorMock {
	m := &MetricsCollectorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mMetricsCollectorMockAdd{mock: m}
	m.AddMock.callArgs = []*MetricsCollectorMockAddParams{}

	m.ExpireMock = mMetricsCollectorMockExpire{mock: m}
	m.ExpireMock.callArgs = []*MetricsCollectorMockExpireParams{}

	m.IncMock = mMetricsCollectorMockInc{mock: m}
	m.IncMock.callArgs = []*MetricsCollectorMockIncParams{}

	m.SetMock = mMetricsCollectorMockSet{mock: m}
	m.SetMock.callArgs = []*MetricsCollectorMockSetParams{}

	m.WriteOutputMock = mMetricsCollectorMockWriteOutput{mock: m}
	m.WriteOutputMock.callArgs = []*MetricsCollectorMockWriteOutputParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMetricsCollectorMockAdd struct {
	optional           bool
	mock               *MetricsCollectorMock
	defaultExpectation *MetricsCollectorMockAddExpectation
	expectations       []*MetricsCollectorMockAddExpectation

	callArgs []*MetricsCollectorMockAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricsCollectorMockAddExpectation specifies expectation struct of the EMMetricsCollector.Add
type MetricsCollectorMockAddExpectation struct {
	mock               *MetricsCollectorMock
	params             *MetricsCollectorMockAddParams
	paramPtrs          *MetricsCollectorMockAddParamPtrs
	expectationOrigins MetricsCollectorMockAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricsCollectorMockAddParams contains parameters of the EMMetricsCollector.Add
type MetricsCollectorMockAddParams struct {
	name   string
	value  float64
	labels map[string]string
	opts   []mm_pkg.MetricCollectorOption
}

// MetricsCollectorMockAddParamPtrs contains pointers to parameters of the EMMetricsCollector.Add
type MetricsCollectorMockAddParamPtrs struct {
	name   *string
	value  *float64
	labels *map[string]string
	opts   *[]mm_pkg.MetricCollectorOption
}

// MetricsCollectorMockAddOrigins contains origins of expectations of the EMMetricsCollector.Add
type MetricsCollectorMockAddExpectationOrigins struct {
	origin       string
	originName   string
	originValue  string
	originLabels string
	originOpts   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mMetricsCollectorMockAdd) Optional() *mMetricsCollectorMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for EMMetricsCollector.Add
func (mmAdd *mMetricsCollectorMockAdd) Expect(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) *mMetricsCollectorMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MetricsCollectorMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &MetricsCollectorMockAddParams{name, value, labels, opts}
	mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectNameParam1 sets up expected param name for EMMetricsCollector.Add
func (mmAdd *mMetricsCollectorMockAdd) ExpectNameParam1(name string) *mMetricsCollectorMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MetricsCollectorMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &MetricsCollectorMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.name = &name
	mmAdd.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectValueParam2 sets up expected param value for EMMetricsCollector.Add
func (mmAdd *mMetricsCollectorMockAdd) ExpectValueParam2(value float64) *mMetricsCollectorMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MetricsCollectorMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &MetricsCollectorMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.value = &value
	mmAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectLabelsParam3 sets up expected param labels for EMMetricsCollector.Add
func (mmAdd *mMetricsCollectorMockAdd) ExpectLabelsParam3(labels map[string]string) *mMetricsCollectorMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MetricsCollectorMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &MetricsCollectorMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.labels = &labels
	mmAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectOptsParam4 sets up expected param opts for EMMetricsCollector.Add
func (mmAdd *mMetricsCollectorMockAdd) ExpectOptsParam4(opts ...mm_pkg.MetricCollectorOption) *mMetricsCollectorMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MetricsCollectorMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &MetricsCollectorMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.opts = &opts
	mmAdd.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the EMMetricsCollector.Add
func (mmAdd *mMetricsCollectorMockAdd) Inspect(f func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)) *mMetricsCollectorMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for MetricsCollectorMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by EMMetricsCollector.Add
func (mmAdd *mMetricsCollectorMockAdd) Return() *MetricsCollectorMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MetricsCollectorMockAddExpectation{mock: mmAdd.mock}
	}

	mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// Set uses given function f to mock the EMMetricsCollector.Add method
func (mmAdd *mMetricsCollectorMockAdd) Set(f func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)) *MetricsCollectorMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the EMMetricsCollector.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the EMMetricsCollector.Add method")
	}

	mmAdd.mock.funcAdd = f
	mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// When sets expectation for the EMMetricsCollector.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mMetricsCollectorMockAdd) When(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) *MetricsCollectorMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MetricsCollectorMock.Add mock is already set by Set")
	}

	expectation := &MetricsCollectorMockAddExpectation{
		mock:               mmAdd.mock,
		params:             &MetricsCollectorMockAddParams{name, value, labels, opts},
		expectationOrigins: MetricsCollectorMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up EMMetricsCollector.Add return parameters for the expectation previously defined by the When method

func (e *MetricsCollectorMockAddExpectation) Then() *MetricsCollectorMock {
	return e.mock
}

// Times sets number of times EMMetricsCollector.Add should be invoked
func (mmAdd *mMetricsCollectorMockAdd) Times(n uint64) *mMetricsCollectorMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of MetricsCollectorMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAdd
}

func (mmAdd *mMetricsCollectorMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements mm_pkg.EMMetricsCollector
func (mmAdd *MetricsCollectorMock) Add(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	mmAdd.t.Helper()

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(name, value, labels, opts...)
	}

	mm_params := MetricsCollectorMockAddParams{name, value, labels, opts}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := MetricsCollectorMockAddParams{name, value, labels, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmAdd.t.Errorf("MetricsCollectorMock.Add got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAdd.t.Errorf("MetricsCollectorMock.Add got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmAdd.t.Errorf("MetricsCollectorMock.Add got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmAdd.t.Errorf("MetricsCollectorMock.Add got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("MetricsCollectorMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAdd.funcAdd != nil {
		mmAdd.funcAdd(name, value, labels, opts...)
		return
	}
	mmAdd.t.Fatalf("Unexpected call to MetricsCollectorMock.Add. %v %v %v %v", name, value, labels, opts)

}

// AddAfterCounter returns a count of finished MetricsCollectorMock.Add invocations
func (mmAdd *MetricsCollectorMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of MetricsCollectorMock.Add invocations
func (mmAdd *MetricsCollectorMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to MetricsCollectorMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mMetricsCollectorMockAdd) Calls() []*MetricsCollectorMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*MetricsCollectorMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *MetricsCollectorMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *MetricsCollectorMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricsCollectorMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricsCollectorMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricsCollectorMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Errorf("Expected call to MetricsCollectorMock.Add at\n%s", m.funcAddOrigin)
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricsCollectorMock.Add at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
	}
}

type mMetricsCollectorMockExpire struct {
	optional           bool
	mock               *MetricsCollectorMock
	defaultExpectation *MetricsCollectorMockExpireExpectation
	expectations       []*MetricsCollectorMockExpireExpectation

	callArgs []*MetricsCollectorMockExpireParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricsCollectorMockExpireExpectation specifies expectation struct of the EMMetricsCollector.Expire
type MetricsCollectorMockExpireExpectation struct {
	mock               *MetricsCollectorMock
	params             *MetricsCollectorMockExpireParams
	paramPtrs          *MetricsCollectorMockExpireParamPtrs
	expectationOrigins MetricsCollectorMockExpireExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricsCollectorMockExpireParams contains parameters of the EMMetricsCollector.Expire
type MetricsCollectorMockExpireParams struct {
	group string
}

// MetricsCollectorMockExpireParamPtrs contains pointers to parameters of the EMMetricsCollector.Expire
type MetricsCollectorMockExpireParamPtrs struct {
	group *string
}

// MetricsCollectorMockExpireOrigins contains origins of expectations of the EMMetricsCollector.Expire
type MetricsCollectorMockExpireExpectationOrigins struct {
	origin      string
	originGroup string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpire *mMetricsCollectorMockExpire) Optional() *mMetricsCollectorMockExpire {
	mmExpire.optional = true
	return mmExpire
}

// Expect sets up expected params for EMMetricsCollector.Expire
func (mmExpire *mMetricsCollectorMockExpire) Expect(group string) *mMetricsCollectorMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("MetricsCollectorMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &MetricsCollectorMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("MetricsCollectorMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &MetricsCollectorMockExpireParams{group}
	mmExpire.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectGroupParam1 sets up expected param group for EMMetricsCollector.Expire
func (mmExpire *mMetricsCollectorMockExpire) ExpectGroupParam1(group string) *mMetricsCollectorMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("MetricsCollectorMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &MetricsCollectorMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("MetricsCollectorMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &MetricsCollectorMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.group = &group
	mmExpire.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the EMMetricsCollector.Expire
func (mmExpire *mMetricsCollectorMockExpire) Inspect(f func(group string)) *mMetricsCollectorMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for MetricsCollectorMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by EMMetricsCollector.Expire
func (mmExpire *mMetricsCollectorMockExpire) Return() *MetricsCollectorMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("MetricsCollectorMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &MetricsCollectorMockExpireExpectation{mock: mmExpire.mock}
	}

	mmExpire.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// Set uses given function f to mock the EMMetricsCollector.Expire method
func (mmExpire *mMetricsCollectorMockExpire) Set(f func(group string)) *MetricsCollectorMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the EMMetricsCollector.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the EMMetricsCollector.Expire method")
	}

	mmExpire.mock.funcExpire = f
	mmExpire.mock.funcExpireOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// When sets expectation for the EMMetricsCollector.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mMetricsCollectorMockExpire) When(group string) *MetricsCollectorMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("MetricsCollectorMock.Expire mock is already set by Set")
	}

	expectation := &MetricsCollectorMockExpireExpectation{
		mock:               mmExpire.mock,
		params:             &MetricsCollectorMockExpireParams{group},
		expectationOrigins: MetricsCollectorMockExpireExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up EMMetricsCollector.Expire return parameters for the expectation previously defined by the When method

func (e *MetricsCollectorMockExpireExpectation) Then() *MetricsCollectorMock {
	return e.mock
}

// Times sets number of times EMMetricsCollector.Expire should be invoked
func (mmExpire *mMetricsCollectorMockExpire) Times(n uint64) *mMetricsCollectorMockExpire {
	if n == 0 {
		mmExpire.mock.t.Fatalf("Times of MetricsCollectorMock.Expire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpire.expectedInvocations, n)
	mmExpire.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExpire
}

func (mmExpire *mMetricsCollectorMockExpire) invocationsDone() bool {
	if len(mmExpire.expectations) == 0 && mmExpire.defaultExpectation == nil && mmExpire.mock.funcExpire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpire.mock.afterExpireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Expire implements mm_pkg.EMMetricsCollector
func (mmExpire *MetricsCollectorMock) Expire(group string) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	mmExpire.t.Helper()

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(group)
	}

	mm_params := MetricsCollectorMockExpireParams{group}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := MetricsCollectorMockExpireParams{group}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmExpire.t.Errorf("MetricsCollectorMock.Expire got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("MetricsCollectorMock.Expire got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExpire.ExpireMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmExpire.funcExpire != nil {
		mmExpire.funcExpire(group)
		return
	}
	mmExpire.t.Fatalf("Unexpected call to MetricsCollectorMock.Expire. %v", group)

}

// ExpireAfterCounter returns a count of finished MetricsCollectorMock.Expire invocations
func (mmExpire *MetricsCollectorMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of MetricsCollectorMock.Expire invocations
func (mmExpire *MetricsCollectorMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to MetricsCollectorMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mMetricsCollectorMockExpire) Calls() []*MetricsCollectorMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*MetricsCollectorMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *MetricsCollectorMock) MinimockExpireDone() bool {
	if m.ExpireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireMock.invocationsDone()
}

// MinimockExpireInspect logs each unmet expectation
func (m *MetricsCollectorMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricsCollectorMock.Expire at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExpireCounter := mm_atomic.LoadUint64(&m.afterExpireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && afterExpireCounter < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricsCollectorMock.Expire at\n%s", m.ExpireMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricsCollectorMock.Expire at\n%s with params: %#v", m.ExpireMock.defaultExpectation.expectationOrigins.origin, *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && afterExpireCounter < 1 {
		m.t.Errorf("Expected call to MetricsCollectorMock.Expire at\n%s", m.funcExpireOrigin)
	}

	if !m.ExpireMock.invocationsDone() && afterExpireCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricsCollectorMock.Expire at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireMock.expectedInvocations), m.ExpireMock.expectedInvocationsOrigin, afterExpireCounter)
	}
}

type mMetricsCollectorMockInc struct {
	optional           bool
	mock               *MetricsCollectorMock
	defaultExpectation *MetricsCollectorMockIncExpectation
	expectations       []*MetricsCollectorMockIncExpectation

	callArgs []*MetricsCollectorMockIncParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricsCollectorMockIncExpectation specifies expectation struct of the EMMetricsCollector.Inc
type MetricsCollectorMockIncExpectation struct {
	mock               *MetricsCollectorMock
	params             *MetricsCollectorMockIncParams
	paramPtrs          *MetricsCollectorMockIncParamPtrs
	expectationOrigins MetricsCollectorMockIncExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricsCollectorMockIncParams contains parameters of the EMMetricsCollector.Inc
type MetricsCollectorMockIncParams struct {
	name   string
	labels map[string]string
	opts   []mm_pkg.MetricCollectorOption
}

// MetricsCollectorMockIncParamPtrs contains pointers to parameters of the EMMetricsCollector.Inc
type MetricsCollectorMockIncParamPtrs struct {
	name   *string
	labels *map[string]string
	opts   *[]mm_pkg.MetricCollectorOption
}

// MetricsCollectorMockIncOrigins contains origins of expectations of the EMMetricsCollector.Inc
type MetricsCollectorMockIncExpectationOrigins struct {
	origin       string
	originName   string
	originLabels string
	originOpts   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInc *mMetricsCollectorMockInc) Optional() *mMetricsCollectorMockInc {
	mmInc.optional = true
	return mmInc
}

// Expect sets up expected params for EMMetricsCollector.Inc
func (mmInc *mMetricsCollectorMockInc) Expect(name string, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) *mMetricsCollectorMockInc {
	if mmInc.mock.funcInc != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Set")
	}

	if mmInc.defaultExpectation == nil {
		mmInc.defaultExpectation = &MetricsCollectorMockIncExpectation{}
	}

	if mmInc.defaultExpectation.paramPtrs != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by ExpectParams functions")
	}

	mmInc.defaultExpectation.params = &MetricsCollectorMockIncParams{name, labels, opts}
	mmInc.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInc.expectations {
		if minimock.Equal(e.params, mmInc.defaultExpectation.params) {
			mmInc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInc.defaultExpectation.params)
		}
	}

	return mmInc
}

// ExpectNameParam1 sets up expected param name for EMMetricsCollector.Inc
func (mmInc *mMetricsCollectorMockInc) ExpectNameParam1(name string) *mMetricsCollectorMockInc {
	if mmInc.mock.funcInc != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Set")
	}

	if mmInc.defaultExpectation == nil {
		mmInc.defaultExpectation = &MetricsCollectorMockIncExpectation{}
	}

	if mmInc.defaultExpectation.params != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Expect")
	}

	if mmInc.defaultExpectation.paramPtrs == nil {
		mmInc.defaultExpectation.paramPtrs = &MetricsCollectorMockIncParamPtrs{}
	}
	mmInc.defaultExpectation.paramPtrs.name = &name
	mmInc.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmInc
}

// ExpectLabelsParam2 sets up expected param labels for EMMetricsCollector.Inc
func (mmInc *mMetricsCollectorMockInc) ExpectLabelsParam2(labels map[string]string) *mMetricsCollectorMockInc {
	if mmInc.mock.funcInc != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Set")
	}

	if mmInc.defaultExpectation == nil {
		mmInc.defaultExpectation = &MetricsCollectorMockIncExpectation{}
	}

	if mmInc.defaultExpectation.params != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Expect")
	}

	if mmInc.defaultExpectation.paramPtrs == nil {
		mmInc.defaultExpectation.paramPtrs = &MetricsCollectorMockIncParamPtrs{}
	}
	mmInc.defaultExpectation.paramPtrs.labels = &labels
	mmInc.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmInc
}

// ExpectOptsParam3 sets up expected param opts for EMMetricsCollector.Inc
func (mmInc *mMetricsCollectorMockInc) ExpectOptsParam3(opts ...mm_pkg.MetricCollectorOption) *mMetricsCollectorMockInc {
	if mmInc.mock.funcInc != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Set")
	}

	if mmInc.defaultExpectation == nil {
		mmInc.defaultExpectation = &MetricsCollectorMockIncExpectation{}
	}

	if mmInc.defaultExpectation.params != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Expect")
	}

	if mmInc.defaultExpectation.paramPtrs == nil {
		mmInc.defaultExpectation.paramPtrs = &MetricsCollectorMockIncParamPtrs{}
	}
	mmInc.defaultExpectation.paramPtrs.opts = &opts
	mmInc.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmInc
}

// Inspect accepts an inspector function that has same arguments as the EMMetricsCollector.Inc
func (mmInc *mMetricsCollectorMockInc) Inspect(f func(name string, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)) *mMetricsCollectorMockInc {
	if mmInc.mock.inspectFuncInc != nil {
		mmInc.mock.t.Fatalf("Inspect function is already set for MetricsCollectorMock.Inc")
	}

	mmInc.mock.inspectFuncInc = f

	return mmInc
}

// Return sets up results that will be returned by EMMetricsCollector.Inc
func (mmInc *mMetricsCollectorMockInc) Return() *MetricsCollectorMock {
	if mmInc.mock.funcInc != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Set")
	}

	if mmInc.defaultExpectation == nil {
		mmInc.defaultExpectation = &MetricsCollectorMockIncExpectation{mock: mmInc.mock}
	}

	mmInc.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInc.mock
}

// Set uses given function f to mock the EMMetricsCollector.Inc method
func (mmInc *mMetricsCollectorMockInc) Set(f func(name string, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)) *MetricsCollectorMock {
	if mmInc.defaultExpectation != nil {
		mmInc.mock.t.Fatalf("Default expectation is already set for the EMMetricsCollector.Inc method")
	}

	if len(mmInc.expectations) > 0 {
		mmInc.mock.t.Fatalf("Some expectations are already set for the EMMetricsCollector.Inc method")
	}

	mmInc.mock.funcInc = f
	mmInc.mock.funcIncOrigin = minimock.CallerInfo(1)
	return mmInc.mock
}

// When sets expectation for the EMMetricsCollector.Inc which will trigger the result defined by the following
// Then helper
func (mmInc *mMetricsCollectorMockInc) When(name string, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) *MetricsCollectorMockIncExpectation {
	if mmInc.mock.funcInc != nil {
		mmInc.mock.t.Fatalf("MetricsCollectorMock.Inc mock is already set by Set")
	}

	expectation := &MetricsCollectorMockIncExpectation{
		mock:               mmInc.mock,
		params:             &MetricsCollectorMockIncParams{name, labels, opts},
		expectationOrigins: MetricsCollectorMockIncExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInc.expectations = append(mmInc.expectations, expectation)
	return expectation
}

// Then sets up EMMetricsCollector.Inc return parameters for the expectation previously defined by the When method

func (e *MetricsCollectorMockIncExpectation) Then() *MetricsCollectorMock {
	return e.mock
}

// Times sets number of times EMMetricsCollector.Inc should be invoked
func (mmInc *mMetricsCollectorMockInc) Times(n uint64) *mMetricsCollectorMockInc {
	if n == 0 {
		mmInc.mock.t.Fatalf("Times of MetricsCollectorMock.Inc mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInc.expectedInvocations, n)
	mmInc.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInc
}

func (mmInc *mMetricsCollectorMockInc) invocationsDone() bool {
	if len(mmInc.expectations) == 0 && mmInc.defaultExpectation == nil && mmInc.mock.funcInc == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInc.mock.afterIncCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInc.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Inc implements mm_pkg.EMMetricsCollector
func (mmInc *MetricsCollectorMock) Inc(name string, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) {
	mm_atomic.AddUint64(&mmInc.beforeIncCounter, 1)
	defer mm_atomic.AddUint64(&mmInc.afterIncCounter, 1)

	mmInc.t.Helper()

	if mmInc.inspectFuncInc != nil {
		mmInc.inspectFuncInc(name, labels, opts...)
	}

	mm_params := MetricsCollectorMockIncParams{name, labels, opts}

	// Record call args
	mmInc.IncMock.mutex.Lock()
	mmInc.IncMock.callArgs = append(mmInc.IncMock.callArgs, &mm_params)
	mmInc.IncMock.mutex.Unlock()

	for _, e := range mmInc.IncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInc.IncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInc.IncMock.defaultExpectation.Counter, 1)
		mm_want := mmInc.IncMock.defaultExpectation.params
		mm_want_ptrs := mmInc.IncMock.defaultExpectation.paramPtrs

		mm_got := MetricsCollectorMockIncParams{name, labels, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmInc.t.Errorf("MetricsCollectorMock.Inc got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInc.IncMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmInc.t.Errorf("MetricsCollectorMock.Inc got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInc.IncMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmInc.t.Errorf("MetricsCollectorMock.Inc got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInc.IncMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInc.t.Errorf("MetricsCollectorMock.Inc got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInc.IncMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInc.funcInc != nil {
		mmInc.funcInc(name, labels, opts...)
		return
	}
	mmInc.t.Fatalf("Unexpected call to MetricsCollectorMock.Inc. %v %v %v", name, labels, opts)

}

// IncAfterCounter returns a count of finished MetricsCollectorMock.Inc invocations
func (mmInc *MetricsCollectorMock) IncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInc.afterIncCounter)
}

// IncBeforeCounter returns a count of MetricsCollectorMock.Inc invocations
func (mmInc *MetricsCollectorMock) IncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInc.beforeIncCounter)
}

// Calls returns a list of arguments used in each call to MetricsCollectorMock.Inc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInc *mMetricsCollectorMockInc) Calls() []*MetricsCollectorMockIncParams {
	mmInc.mutex.RLock()

	argCopy := make([]*MetricsCollectorMockIncParams, len(mmInc.callArgs))
	copy(argCopy, mmInc.callArgs)

	mmInc.mutex.RUnlock()

	return argCopy
}

// MinimockIncDone returns true if the count of the Inc invocations corresponds
// the number of defined expectations
func (m *MetricsCollectorMock) MinimockIncDone() bool {
	if m.IncMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncMock.invocationsDone()
}

// MinimockIncInspect logs each unmet expectation
func (m *MetricsCollectorMock) MinimockIncInspect() {
	for _, e := range m.IncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricsCollectorMock.Inc at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIncCounter := mm_atomic.LoadUint64(&m.afterIncCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncMock.defaultExpectation != nil && afterIncCounter < 1 {
		if m.IncMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricsCollectorMock.Inc at\n%s", m.IncMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricsCollectorMock.Inc at\n%s with params: %#v", m.IncMock.defaultExpectation.expectationOrigins.origin, *m.IncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInc != nil && afterIncCounter < 1 {
		m.t.Errorf("Expected call to MetricsCollectorMock.Inc at\n%s", m.funcIncOrigin)
	}

	if !m.IncMock.invocationsDone() && afterIncCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricsCollectorMock.Inc at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncMock.expectedInvocations), m.IncMock.expectedInvocationsOrigin, afterIncCounter)
	}
}

type mMetricsCollectorMockSet struct {
	optional           bool
	mock               *MetricsCollectorMock
	defaultExpectation *MetricsCollectorMockSetExpectation
	expectations       []*MetricsCollectorMockSetExpectation

	callArgs []*MetricsCollectorMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricsCollectorMockSetExpectation specifies expectation struct of the EMMetricsCollector.Set
type MetricsCollectorMockSetExpectation struct {
	mock               *MetricsCollectorMock
	params             *MetricsCollectorMockSetParams
	paramPtrs          *MetricsCollectorMockSetParamPtrs
	expectationOrigins MetricsCollectorMockSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricsCollectorMockSetParams contains parameters of the EMMetricsCollector.Set
type MetricsCollectorMockSetParams struct {
	name   string
	value  float64
	labels map[string]string
	opts   []mm_pkg.MetricCollectorOption
}

// MetricsCollectorMockSetParamPtrs contains pointers to parameters of the EMMetricsCollector.Set
type MetricsCollectorMockSetParamPtrs struct {
	name   *string
	value  *float64
	labels *map[string]string
	opts   *[]mm_pkg.MetricCollectorOption
}

// MetricsCollectorMockSetOrigins contains origins of expectations of the EMMetricsCollector.Set
type MetricsCollectorMockSetExpectationOrigins struct {
	origin       string
	originName   string
	originValue  string
	originLabels string
	originOpts   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mMetricsCollectorMockSet) Optional() *mMetricsCollectorMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for EMMetricsCollector.Set
func (mmSet *mMetricsCollectorMockSet) Expect(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) *mMetricsCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MetricsCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &MetricsCollectorMockSetParams{name, value, labels, opts}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectNameParam1 sets up expected param name for EMMetricsCollector.Set
func (mmSet *mMetricsCollectorMockSet) ExpectNameParam1(name string) *mMetricsCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MetricsCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &MetricsCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.name = &name
	mmSet.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmSet
}

// ExpectValueParam2 sets up expected param value for EMMetricsCollector.Set
func (mmSet *mMetricsCollectorMockSet) ExpectValueParam2(value float64) *mMetricsCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MetricsCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &MetricsCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value
	mmSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSet
}

// ExpectLabelsParam3 sets up expected param labels for EMMetricsCollector.Set
func (mmSet *mMetricsCollectorMockSet) ExpectLabelsParam3(labels map[string]string) *mMetricsCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MetricsCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &MetricsCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.labels = &labels
	mmSet.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmSet
}

// ExpectOptsParam4 sets up expected param opts for EMMetricsCollector.Set
func (mmSet *mMetricsCollectorMockSet) ExpectOptsParam4(opts ...mm_pkg.MetricCollectorOption) *mMetricsCollectorMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MetricsCollectorMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &MetricsCollectorMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.opts = &opts
	mmSet.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the EMMetricsCollector.Set
func (mmSet *mMetricsCollectorMockSet) Inspect(f func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)) *mMetricsCollectorMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for MetricsCollectorMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by EMMetricsCollector.Set
func (mmSet *mMetricsCollectorMockSet) Return() *MetricsCollectorMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MetricsCollectorMockSetExpectation{mock: mmSet.mock}
	}

	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the EMMetricsCollector.Set method
func (mmSet *mMetricsCollectorMockSet) Set(f func(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption)) *MetricsCollectorMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the EMMetricsCollector.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the EMMetricsCollector.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the EMMetricsCollector.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mMetricsCollectorMockSet) When(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) *MetricsCollectorMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MetricsCollectorMock.Set mock is already set by Set")
	}

	expectation := &MetricsCollectorMockSetExpectation{
		mock:               mmSet.mock,
		params:             &MetricsCollectorMockSetParams{name, value, labels, opts},
		expectationOrigins: MetricsCollectorMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up EMMetricsCollector.Set return parameters for the expectation previously defined by the When method

func (e *MetricsCollectorMockSetExpectation) Then() *MetricsCollectorMock {
	return e.mock
}

// Times sets number of times EMMetricsCollector.Set should be invoked
func (mmSet *mMetricsCollectorMockSet) Times(n uint64) *mMetricsCollectorMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of MetricsCollectorMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mMetricsCollectorMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_pkg.EMMetricsCollector
func (mmSet *MetricsCollectorMock) Set(name string, value float64, labels map[string]string, opts ...mm_pkg.MetricCollectorOption) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(name, value, labels, opts...)
	}

	mm_params := MetricsCollectorMockSetParams{name, value, labels, opts}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := MetricsCollectorMockSetParams{name, value, labels, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmSet.t.Errorf("MetricsCollectorMock.Set got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("MetricsCollectorMock.Set got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmSet.t.Errorf("MetricsCollectorMock.Set got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmSet.t.Errorf("MetricsCollectorMock.Set got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("MetricsCollectorMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSet.funcSet != nil {
		mmSet.funcSet(name, value, labels, opts...)
		return
	}
	mmSet.t.Fatalf("Unexpected call to MetricsCollectorMock.Set. %v %v %v %v", name, value, labels, opts)

}

// SetAfterCounter returns a count of finished MetricsCollectorMock.Set invocations
func (mmSet *MetricsCollectorMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of MetricsCollectorMock.Set invocations
func (mmSet *MetricsCollectorMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to MetricsCollectorMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mMetricsCollectorMockSet) Calls() []*MetricsCollectorMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*MetricsCollectorMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *MetricsCollectorMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *MetricsCollectorMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricsCollectorMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricsCollectorMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricsCollectorMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to MetricsCollectorMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricsCollectorMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

type mMetricsCollectorMockWriteOutput struct {
	optional           bool
	mock               *MetricsCollectorMock
	defaultExpectation *MetricsCollectorMockWriteOutputExpectation
	expectations       []*MetricsCollectorMockWriteOutputExpectation

	callArgs []*MetricsCollectorMockWriteOutputParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricsCollectorMockWriteOutputExpectation specifies expectation struct of the EMMetricsCollector.WriteOutput
type MetricsCollectorMockWriteOutputExpectation struct {
	mock               *MetricsCollectorMock
	params             *MetricsCollectorMockWriteOutputParams
	paramPtrs          *MetricsCollectorMockWriteOutputParamPtrs
	expectationOrigins MetricsCollectorMockWriteOutputExpectationOrigins
	results            *MetricsCollectorMockWriteOutputResults
	returnOrigin       string
	Counter            uint64
}

// MetricsCollectorMockWriteOutputParams contains parameters of the EMMetricsCollector.WriteOutput
type MetricsCollectorMockWriteOutputParams struct {
	writer io.Writer
}

// MetricsCollectorMockWriteOutputParamPtrs contains pointers to parameters of the EMMetricsCollector.WriteOutput
type MetricsCollectorMockWriteOutputParamPtrs struct {
	writer *io.Writer
}

// MetricsCollectorMockWriteOutputResults contains results of the EMMetricsCollector.WriteOutput
type MetricsCollectorMockWriteOutputResults struct {
	err error
}

// MetricsCollectorMockWriteOutputOrigins contains origins of expectations of the EMMetricsCollector.WriteOutput
type MetricsCollectorMockWriteOutputExpectationOrigins struct {
	origin       string
	originWriter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) Optional() *mMetricsCollectorMockWriteOutput {
	mmWriteOutput.optional = true
	return mmWriteOutput
}

// Expect sets up expected params for EMMetricsCollector.WriteOutput
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) Expect(writer io.Writer) *mMetricsCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("MetricsCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &MetricsCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.paramPtrs != nil {
		mmWriteOutput.mock.t.Fatalf("MetricsCollectorMock.WriteOutput mock is already set by ExpectParams functions")
	}

	mmWriteOutput.defaultExpectation.params = &MetricsCollectorMockWriteOutputParams{writer}
	mmWriteOutput.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWriteOutput.expectations {
		if minimock.Equal(e.params, mmWriteOutput.defaultExpectation.params) {
			mmWriteOutput.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteOutput.defaultExpectation.params)
		}
	}

	return mmWriteOutput
}

// ExpectWriterParam1 sets up expected param writer for EMMetricsCollector.WriteOutput
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) ExpectWriterParam1(writer io.Writer) *mMetricsCollectorMockWriteOutput {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("MetricsCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &MetricsCollectorMockWriteOutputExpectation{}
	}

	if mmWriteOutput.defaultExpectation.params != nil {
		mmWriteOutput.mock.t.Fatalf("MetricsCollectorMock.WriteOutput mock is already set by Expect")
	}

	if mmWriteOutput.defaultExpectation.paramPtrs == nil {
		mmWriteOutput.defaultExpectation.paramPtrs = &MetricsCollectorMockWriteOutputParamPtrs{}
	}
	mmWriteOutput.defaultExpectation.paramPtrs.writer = &writer
	mmWriteOutput.defaultExpectation.expectationOrigins.originWriter = minimock.CallerInfo(1)

	return mmWriteOutput
}

// Inspect accepts an inspector function that has same arguments as the EMMetricsCollector.WriteOutput
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) Inspect(f func(writer io.Writer)) *mMetricsCollectorMockWriteOutput {
	if mmWriteOutput.mock.inspectFuncWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("Inspect function is already set for MetricsCollectorMock.WriteOutput")
	}

	mmWriteOutput.mock.inspectFuncWriteOutput = f

	return mmWriteOutput
}

// Return sets up results that will be returned by EMMetricsCollector.WriteOutput
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) Return(err error) *MetricsCollectorMock {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("MetricsCollectorMock.WriteOutput mock is already set by Set")
	}

	if mmWriteOutput.defaultExpectation == nil {
		mmWriteOutput.defaultExpectation = &MetricsCollectorMockWriteOutputExpectation{mock: mmWriteOutput.mock}
	}
	mmWriteOutput.defaultExpectation.results = &MetricsCollectorMockWriteOutputResults{err}
	mmWriteOutput.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// Set uses given function f to mock the EMMetricsCollector.WriteOutput method
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) Set(f func(writer io.Writer) (err error)) *MetricsCollectorMock {
	if mmWriteOutput.defaultExpectation != nil {
		mmWriteOutput.mock.t.Fatalf("Default expectation is already set for the EMMetricsCollector.WriteOutput method")
	}

	if len(mmWriteOutput.expectations) > 0 {
		mmWriteOutput.mock.t.Fatalf("Some expectations are already set for the EMMetricsCollector.WriteOutput method")
	}

	mmWriteOutput.mock.funcWriteOutput = f
	mmWriteOutput.mock.funcWriteOutputOrigin = minimock.CallerInfo(1)
	return mmWriteOutput.mock
}

// When sets expectation for the EMMetricsCollector.WriteOutput which will trigger the result defined by the following
// Then helper
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) When(writer io.Writer) *MetricsCollectorMockWriteOutputExpectation {
	if mmWriteOutput.mock.funcWriteOutput != nil {
		mmWriteOutput.mock.t.Fatalf("MetricsCollectorMock.WriteOutput mock is already set by Set")
	}

	expectation := &MetricsCollectorMockWriteOutputExpectation{
		mock:               mmWriteOutput.mock,
		params:             &MetricsCollectorMockWriteOutputParams{writer},
		expectationOrigins: MetricsCollectorMockWriteOutputExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWriteOutput.expectations = append(mmWriteOutput.expectations, expectation)
	return expectation
}

// Then sets up EMMetricsCollector.WriteOutput return parameters for the expectation previously defined by the When method
func (e *MetricsCollectorMockWriteOutputExpectation) Then(err error) *MetricsCollectorMock {
	e.results = &MetricsCollectorMockWriteOutputResults{err}
	return e.mock
}

// Times sets number of times EMMetricsCollector.WriteOutput should be invoked
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) Times(n uint64) *mMetricsCollectorMockWriteOutput {
	if n == 0 {
		mmWriteOutput.mock.t.Fatalf("Times of MetricsCollectorMock.WriteOutput mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteOutput.expectedInvocations, n)
	mmWriteOutput.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWriteOutput
}

func (mmWriteOutput *mMetricsCollectorMockWriteOutput) invocationsDone() bool {
	if len(mmWriteOutput.expectations) == 0 && mmWriteOutput.defaultExpectation == nil && mmWriteOutput.mock.funcWriteOutput == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteOutput.mock.afterWriteOutputCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteOutput.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteOutput implements mm_pkg.EMMetricsCollector
func (mmWriteOutput *MetricsCollectorMock) WriteOutput(writer io.Writer) (err error) {
	mm_atomic.AddUint64(&mmWriteOutput.beforeWriteOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteOutput.afterWriteOutputCounter, 1)

	mmWriteOutput.t.Helper()

	if mmWriteOutput.inspectFuncWriteOutput != nil {
		mmWriteOutput.inspectFuncWriteOutput(writer)
	}

	mm_params := MetricsCollectorMockWriteOutputParams{writer}

	// Record call args
	mmWriteOutput.WriteOutputMock.mutex.Lock()
	mmWriteOutput.WriteOutputMock.callArgs = append(mmWriteOutput.WriteOutputMock.callArgs, &mm_params)
	mmWriteOutput.WriteOutputMock.mutex.Unlock()

	for _, e := range mmWriteOutput.WriteOutputMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWriteOutput.WriteOutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteOutput.WriteOutputMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteOutput.WriteOutputMock.defaultExpectation.params
		mm_want_ptrs := mmWriteOutput.WriteOutputMock.defaultExpectation.paramPtrs

		mm_got := MetricsCollectorMockWriteOutputParams{writer}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.writer != nil && !minimock.Equal(*mm_want_ptrs.writer, mm_got.writer) {
				mmWriteOutput.t.Errorf("MetricsCollectorMock.WriteOutput got unexpected parameter writer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.originWriter, *mm_want_ptrs.writer, mm_got.writer, minimock.Diff(*mm_want_ptrs.writer, mm_got.writer))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteOutput.t.Errorf("MetricsCollectorMock.WriteOutput got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWriteOutput.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteOutput.WriteOutputMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteOutput.t.Fatal("No results are set for the MetricsCollectorMock.WriteOutput")
		}
		return (*mm_results).err
	}
	if mmWriteOutput.funcWriteOutput != nil {
		return mmWriteOutput.funcWriteOutput(writer)
	}
	mmWriteOutput.t.Fatalf("Unexpected call to MetricsCollectorMock.WriteOutput. %v", writer)
	return
}

// WriteOutputAfterCounter returns a count of finished MetricsCollectorMock.WriteOutput invocations
func (mmWriteOutput *MetricsCollectorMock) WriteOutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.afterWriteOutputCounter)
}

// WriteOutputBeforeCounter returns a count of MetricsCollectorMock.WriteOutput invocations
func (mmWriteOutput *MetricsCollectorMock) WriteOutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteOutput.beforeWriteOutputCounter)
}

// Calls returns a list of arguments used in each call to MetricsCollectorMock.WriteOutput.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteOutput *mMetricsCollectorMockWriteOutput) Calls() []*MetricsCollectorMockWriteOutputParams {
	mmWriteOutput.mutex.RLock()

	argCopy := make([]*MetricsCollectorMockWriteOutputParams, len(mmWriteOutput.callArgs))
	copy(argCopy, mmWriteOutput.callArgs)

	mmWriteOutput.mutex.RUnlock()

	return argCopy
}

// MinimockWriteOutputDone returns true if the count of the WriteOutput invocations corresponds
// the number of defined expectations
func (m *MetricsCollectorMock) MinimockWriteOutputDone() bool {
	if m.WriteOutputMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteOutputMock.invocationsDone()
}

// MinimockWriteOutputInspect logs each unmet expectation
func (m *MetricsCollectorMock) MinimockWriteOutputInspect() {
	for _, e := range m.WriteOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricsCollectorMock.WriteOutput at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWriteOutputCounter := mm_atomic.LoadUint64(&m.afterWriteOutputCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteOutputMock.defaultExpectation != nil && afterWriteOutputCounter < 1 {
		if m.WriteOutputMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricsCollectorMock.WriteOutput at\n%s", m.WriteOutputMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricsCollectorMock.WriteOutput at\n%s with params: %#v", m.WriteOutputMock.defaultExpectation.expectationOrigins.origin, *m.WriteOutputMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteOutput != nil && afterWriteOutputCounter < 1 {
		m.t.Errorf("Expected call to MetricsCollectorMock.WriteOutput at\n%s", m.funcWriteOutputOrigin)
	}

	if !m.WriteOutputMock.invocationsDone() && afterWriteOutputCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricsCollectorMock.WriteOutput at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteOutputMock.expectedInvocations), m.WriteOutputMock.expectedInvocationsOrigin, afterWriteOutputCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MetricsCollectorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockExpireInspect()

			m.MinimockIncInspect()

			m.MinimockSetInspect()

			m.MinimockWriteOutputInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MetricsCollectorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MetricsCollectorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockExpireDone() &&
		m.MinimockIncDone() &&
		m.MinimockSetDone() &&
		m.MinimockWriteOutputDone()
}
